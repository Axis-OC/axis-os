-- AxisOS SecureBoot EEPROM v2.0
-- Halts on verification failure. DEL=Setup. Enter=Boot.
-- Must be minified to fit 4KB EEPROM.
local c, p = component, computer

-- Discover components
local g, s, e, d, f
for a, t in c.list() do
    local x = c.proxy(a)
    if t == "gpu" and not g then g = x
    elseif t == "screen" and not s then s = a
    elseif t == "eeprom" and not e then e = x
    elseif t == "data" and not d then d = x
    elseif t == "filesystem" and not f then
        if x.exists("/kernel.lua") then f = x end
    end
end
if not (g and s) then p.beep(1000, .2); error("NO GPU") end
g.bind(s)
local W, H = g.maxResolution()
g.setResolution(W, H)
g.setBackground(0)
g.setForeground(0xFFFFFF)
g.fill(1, 1, W, H, " ")

-- Helpers
local y = 1
local function pr(t, q)
    if q then g.setForeground(q) end
    g.set(2, y, t)
    y = y + 1
end

local function halt(r)
    g.setForeground(0xFF0000)
    g.set(2, H - 2, "BOOT BLOCKED")
    g.setForeground(0xFF5555)
    g.set(2, H - 1, tostring(r):sub(1, W - 4))
    p.beep(200, 1)
    while true do p.pullSignal(math.huge) end
end

local function hex(z)
    return z:gsub(".", function(b)
        return ("%02x"):format(b:byte())
    end)
end

local function rf(path)
    local h = f.open(path, "r")
    if not h then return end
    local t = {}
    while true do
        local s = f.read(h, 4096)
        if not s then break end
        t[#t + 1] = s
    end
    f.close(h)
    return table.concat(t)
end

local function rstr(s, o, n)
    local r = s:sub(o, o + n - 1)
    local z = r:find("\0", 1, true)
    return z and r:sub(1, z - 1) or r
end

if not f then halt("No system disk") end

pr("AxisOS SecureBoot", 0x00BCD4)
pr("")

local V, B, K = false, "", ""

if d then
    -- [1] Read stored attestation from EEPROM data + /boot/efi/ files
    local eb, eh = "", ""
    if e then
        local D = e.getData()
        if D and #D >= 144 and D:sub(1, 4) == "AXCF" then
            eb = rstr(D, 17, 64)
            eh = rstr(D, 81, 64)
        end
    end
    -- Fallback to filesystem
    if #eb == 0 then
        local x = rf("/boot/efi/machine.bind")
        if x then x = x:gsub("%s+", ""); if #x > 0 then eb = x end end
    end
    if #eh == 0 then
        local x = rf("/boot/efi/kernel.hash")
        if x then x = x:gsub("%s+", ""); if #x > 0 then eh = x end end
    end

    -- [2] Compute fresh machine binding
    pr("Binding...", 0xAAAAAA)
    B = hex(d.sha256((d.address or "") .. (e and e.address or "") .. (f.address or "")))

    -- [3] Compute kernel hash
    local kc = rf("/kernel.lua")
    if not kc or #kc < 100 then halt("Kernel corrupt") end
    pr("Hashing...", 0xAAAAAA)
    K = hex(d.sha256(kc))

    -- [4] Verify
    local bHasData = #eb > 0 or #eh > 0
    local bBindOk = #eb == 0 or B == eb
    local bHashOk = #eh == 0 or K == eh

    if bHasData and bBindOk and bHashOk then
        V = true
        pr("VERIFIED", 0x55FF55)
    elseif not bHasData then
        pr("NO ATTESTATION", 0xFFAA00)
    else
        -- HALT: attestation data exists but verification failed
        if not bBindOk then pr("BIND MISMATCH", 0xFF5555) end
        if not bHashOk then pr("HASH MISMATCH", 0xFF5555) end
        halt("Verification failed")
    end
else
    -- No data card: check if EEPROM has attestation data
    -- If it does, we MUST have a data card to verify â†’ halt
    local bNeedVerify = false
    if e then
        local D = e.getData()
        if D and #D >= 16 and D:sub(1, 4) == "AXCF" then
            for i = 17, 144 do
                if (D:byte(i) or 0) ~= 0 then
                    bNeedVerify = true
                    break
                end
            end
        end
    end
    if bNeedVerify then halt("Data card required") end
    pr("No data card", 0xFFAA00)
    if not rf("/kernel.lua") then halt("No kernel") end
end

pr("")
g.setForeground(0xAAAAAA)
g.set(math.floor((W - 24) / 2), H - 2, "Press DEL for BIOS Setup")
g.setForeground(V and 0x55FF55 or 0xFFAA00)
g.set(2, H, "SB:" .. (V and "OK" or "??"))

-- Wait for DEL or timeout
local dl = p.uptime() + 3
while p.uptime() < dl do
    local ev, _, _, cd = p.pullSignal(.1)
    if ev == "key_down" then
        if cd == 211 then
            p.beep(1000, .1)
            local s2 = rf("/boot/setup.lua")
            if s2 then
                local fn = load(s2, "@setup", "t",
                    setmetatable({component=c, computer=p}, {__index=_G}))
                if fn then pcall(fn) end
            end
            break
        elseif cd == 28 then break end
    end
end

-- Boot kernel
g.fill(1, 1, W, H, " ")
g.set(1, 1, "Booting...")
p.beep(900, .2)
local kc = rf("/kernel.lua")
if not kc or #kc < 100 then halt("Kernel missing") end
if kc:sub(1, 3) == "\239\187\191" then kc = kc:sub(4) end

-- Parse loader.cfg for boot params
local ba = {lvl="Info", safe="Disabled", wait="0", init="/bin/init.lua"}
pcall(function()
    local cfg = load(rf("/boot/loader.cfg"), "l", "t", {})()
    for _, en in ipairs(cfg.entries) do
        if en.id == (cfg.default or "axis") then
            ba.init = en.init or ba.init
            if en.params then
                ba.lvl = en.params.loglevel or ba.lvl
                if en.params.safemode then ba.safe = "Enabled" end
            end
            break
        end
    end
end)

local ke = {raw_component=c, raw_computer=p, boot_fs_address=f.address, boot_args=ba}
if V then
    ke.boot_security = {
        machine_binding = B, kernel_hash = K,
        data_card_addr = d.address, verified = true
    }
end
setmetatable(ke, {__index = _G})
local fn, err = load(kc, "=kernel", "t", ke)
if not fn then halt("PARSE:" .. tostring(err)) end
local ok, e2 = xpcall(fn, debug.traceback)
if not ok then halt("PANIC:" .. tostring(e2)) end