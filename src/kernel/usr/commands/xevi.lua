--
-- /usr/commands/xevi.lua
-- xevi v2 — XE Visual Editor for AxisOS
--
-- Major changes from v1:
--   • Diff-based undo (O(edits) memory, not O(lines×snapshots))
--   • Fuzzy command dropdown with descriptions (upward from : line)
--   • Config autogeneration + version migration
--   • vim-plug integration via /lib/xevi/plug.lua
--   • Per-line syntax cache (scroll without re-highlighting)
--   • Explicit memory management (nil dead refs, reduced maxUndo)
--

local fs = require("filesystem")
local xe = require("xe")

local HL = nil
pcall(function() HL = require("vi/highlight") end)

local oPlug = nil
pcall(function() oPlug = require("xevi/plug") end)

local tArgs = env.ARGS or {}

-- =============================================
-- 1. CONFIG AUTO-GENERATION
-- =============================================

local CFG_PATH = "/etc/xevi.cfg"
local CFG_VERSION = 4

local CFG_DEFAULTS = {
    _version     = CFG_VERSION,
    lineNumbers  = true,
    tabSize      = 2,
    scrollOff    = 3,
    autoIndent   = true,
    maxUndo      = 20,
    colors       = {},
    filetypes    = {},
    keymaps      = {},
    plugins      = {},
    plugin_opts  = {},
}

local function serializeCfg(t)
    local tL = {
        "--",
        "-- /etc/xevi.cfg — auto-generated by xevi",
        "-- Safe to edit. New fields injected on upgrade.",
        "--",
        "return {",
    }
    local function q(v)
        if type(v) == "string" then return '"'..v:gsub('"','\\"')..'"' end
        if type(v) == "number" then return tostring(v) end
        if type(v) == "boolean" then return tostring(v) end
        return "nil"
    end
    for k, v in pairs(t) do
        if type(v) ~= "table" then
            tL[#tL+1] = "    "..k.." = "..q(v)..","
        end
    end
    tL[#tL+1] = "    colors = {},"
    tL[#tL+1] = "    filetypes = {},"
    tL[#tL+1] = "    keymaps = {},"
    tL[#tL+1] = "    plugins = {},"
    tL[#tL+1] = "    plugin_opts = {},"
    tL[#tL+1] = "}"
    return table.concat(tL, "\n") .. "\n"
end

local function loadCfg()
    local cfg = {}
    for k,v in pairs(CFG_DEFAULTS) do cfg[k] = v end
    local h = fs.open(CFG_PATH, "r")
    if h then
        local s = fs.read(h, math.huge); fs.close(h)
        if s then
            local f = load(s, "xevi.cfg", "t", {})
            if f then
                local ok, t = pcall(f)
                if ok and type(t) == "table" then
                    for k,v in pairs(t) do cfg[k] = v end
                end
            end
        end
    end
    -- Auto-generate or upgrade
    if not cfg._version or cfg._version < CFG_VERSION then
        cfg._version = CFG_VERSION
        fs.mkdir("/etc")
        local hw = fs.open(CFG_PATH, "w")
        if hw then fs.write(hw, serializeCfg(cfg)); fs.close(hw) end
    end
    return cfg
end

local cfg = loadCfg()

-- =============================================
-- 2. XE CONTEXT
-- =============================================

local ctx = xe.createContext({
    theme = xe.THEMES.dark,
    extensions = {
        "XE_ui_shadow_buffering_render_batch",
        "XE_ui_diff_render_feature",
        "XE_ui_alt_screen_query",
        "XE_ui_deferred_clear",
        "XE_ui_imgui_navigation",
        "XE_ui_dirty_row_tracking",
        "XE_ui_run_length_grouping",
        "XE_ui_modal_prebuilt",
        "XE_ui_toast",
        "XE_ui_command_palette",
    },
})
if not ctx then print("xevi: cannot create XE context"); return end
local W, H = ctx.W, ctx.H

-- =============================================
-- 3. COLORS
-- =============================================

local CLR = {
    bg=0x0A0A1A, fg=0xCCCCDD, gutter=0x555566, gutterBg=0x0E0E22,
    curLine=0x141430, cursor=0xFFFFFF, tilde=0x333355,
    tabBg=0x0D2B52, tabFg=0xAAAAAA, tabAct=0xFFFF00, tabActBg=0x0A0A1A,
    barBg=0x0D2B52, barFg=0xFFFFFF,
    modeN=0x55FF55, modeI=0xFF5555, modeC=0x5599FF, modeS=0xFFFF55,
    dropBg=0x111133, dropSel=0xFFFF00, dropSelBg=0x222266,
    dropCmd=0x55DDDD, dropDesc=0x777799,
    startFg=0x557799, startAcc=0x55FFFF, startKey=0xFFFF55,
}

-- Merge plugin/config colors
if cfg.colors then for k,v in pairs(cfg.colors) do CLR[k]=v end end

-- =============================================
-- 4. PLUGIN SYSTEM INIT
-- =============================================

local g_tPlugCommands = {}
local g_tPlugApi = {}

local function initPlugins()
    if not oPlug then return end
    if cfg.plugins then oPlug.declare(cfg.plugins) end
    local tLoaded, tErrors = oPlug.loadAll(nil, cfg.plugin_opts or {})

    -- Merge plugin colors
    local tPC = oPlug.getColors()
    for k,v in pairs(tPC) do CLR[k] = v end

    -- Collect plugin commands
    g_tPlugCommands = oPlug.getCommands()

    -- Call on_load hooks
    for sName, tPlug in pairs(tLoaded or {}) do
        if tPlug.on_load then
            pcall(tPlug.on_load, g_tPlugApi, cfg.plugin_opts[sName] or {})
        end
    end

    -- Report errors
    for sName, sErr in pairs(tErrors or {}) do
        ctx:toastError("Plugin '" .. sName .. "': " .. sErr)
    end
end

-- =============================================
-- 5. STATE
-- =============================================

local tBuffers    = {}
local nActive     = 0
local bRunning    = true
local sMode       = "normal"
local sCmdBuf     = ""
local sSearchBuf  = ""
local sSearchTerm = ""
local sPending    = nil
local sMsg        = ""
local bPalette    = false
local sPromptId   = nil

-- Layout
local TAB_Y    = 1
local EDIT_Y   = 2
local EDIT_H   = H - 3
local STATUS_Y = H - 1
local CMD_Y    = H

-- Command suggestion state
local tCmdSugg   = {}   -- filtered suggestions
local nSuggSel   = 0    -- 0=none, 1..N=selected
local nSuggMax   = math.min(8, EDIT_H - 2)

-- =============================================
-- 6. COMMAND DEFINITIONS (for fuzzy search)
-- =============================================

local tCommandDefs = {
    {cmd="w",      desc="Write file",            alias={"write"}},
    {cmd="q",      desc="Quit",                  alias={"quit"}},
    {cmd="wq",     desc="Write and quit",        alias={"x"}},
    {cmd="q!",     desc="Force quit",            alias={}},
    {cmd="e",      desc="Open file...",          alias={"edit"}},
    {cmd="bn",     desc="Next buffer",           alias={"bnext"}},
    {cmd="bp",     desc="Previous buffer",       alias={"bprev"}},
    {cmd="bd",     desc="Close buffer",          alias={"bdelete"}},
    {cmd="bd!",    desc="Force close buffer",    alias={}},
    {cmd="new",    desc="New empty buffer",      alias={}},
    {cmd="set",    desc="Set option",            alias={}},
    {cmd="qa",     desc="Quit all",              alias={"qall"}},
}

-- Add plugin commands to the definitions
local function rebuildCommandDefs()
    -- Start with built-in
    local t = {}
    for i,v in ipairs(tCommandDefs) do t[i] = v end
    -- Add plugin commands
    if oPlug then
        for _, c in ipairs(g_tPlugCommands) do
            t[#t+1] = {cmd=c.cmd, desc=c.desc or "", alias={}, plugFunc=c.func, plug=c.plug}
        end
    end
    -- PlugInstall etc
    t[#t+1] = {cmd="PlugInstall", desc="Install declared plugins", alias={}}
    t[#t+1] = {cmd="PlugStatus",  desc="Show plugin status",      alias={}}
    t[#t+1] = {cmd="PlugUpdate",  desc="Update all plugins",      alias={}}
    t[#t+1] = {cmd="PlugClean",   desc="Remove undeclared",       alias={}}
    return t
end

local tAllCommands = {}

local function fuzzyMatch(sQuery, sTarget)
    if #sQuery == 0 then return true end
    local sQ = sQuery:lower()
    local sT = sTarget:lower()
    -- Prefix match first (highest priority)
    if sT:sub(1, #sQ) == sQ then return true, 100 end
    -- Substring match
    if sT:find(sQ, 1, true) then return true, 50 end
    -- Character-order match
    local qi = 1
    for ti = 1, #sT do
        if sT:sub(ti,ti) == sQ:sub(qi,qi) then
            qi = qi + 1
            if qi > #sQ then return true, 10 end
        end
    end
    return false, 0
end

local function updateSuggestions()
    tCmdSugg = {}
    if #sCmdBuf == 0 then
        -- Show all commands when empty
        for _, def in ipairs(tAllCommands) do
            tCmdSugg[#tCmdSugg+1] = {def=def, score=0}
        end
    else
        local sQ = sCmdBuf:match("^(%S+)") or sCmdBuf
        for _, def in ipairs(tAllCommands) do
            local bM, nS = fuzzyMatch(sQ, def.cmd)
            if not bM then
                -- Try aliases
                for _, a in ipairs(def.alias or {}) do
                    bM, nS = fuzzyMatch(sQ, a)
                    if bM then break end
                end
            end
            if not bM and def.desc then
                bM, nS = fuzzyMatch(sQ, def.desc)
                if bM then nS = nS - 20 end -- lower priority for desc matches
            end
            if bM then tCmdSugg[#tCmdSugg+1] = {def=def, score=nS} end
        end
    end
    table.sort(tCmdSugg, function(a,b) return a.score > b.score end)
    -- Cap suggestions
    while #tCmdSugg > nSuggMax do tCmdSugg[#tCmdSugg] = nil end
    -- Reset selection
    if nSuggSel > #tCmdSugg then nSuggSel = #tCmdSugg end
    if nSuggSel < 0 then nSuggSel = 0 end
end

-- =============================================
-- 7. BUFFER + DIFF-BASED UNDO
-- =============================================

local function newBuffer(sPath, tLines)
    return {
        tLines    = tLines or {""},
        nCL       = 1,
        nCC       = 1,
        nTop      = 1,
        nLeft     = 1,
        sPath     = sPath,
        bModified = false,
        -- Diff undo stack: each entry = {items={{op=,ln=,old=},...}}
        tUndo     = {},
        sYankBuf  = "",
        bYankLine = false,
        -- Syntax
        tLang       = HL and HL.detect(sPath) or nil,
        tBlkState   = {},
        bStateDirty = true,
        -- Per-line syntax cache: [lineNum] = {cacheKey, tSegments}
        tSegCache   = {},
        tLineVer    = {},
        nEditVer    = 0,
    }
end

local function bufName(buf)
    if not buf.sPath then return "[New]" end
    return buf.sPath:match("[^/]+$") or buf.sPath
end

local function addBuffer(buf)
    tBuffers[#tBuffers+1] = buf
    nActive = #tBuffers
    sMode = "normal"; sPending = nil
    return #tBuffers
end

local function closeBuffer(nIdx)
    if nIdx < 1 or nIdx > #tBuffers then return end
    local buf = tBuffers[nIdx]
    -- Explicit cleanup to help GC
    buf.tLines = nil; buf.tUndo = nil; buf.tSegCache = nil
    buf.tBlkState = nil; buf.tLineVer = nil
    table.remove(tBuffers, nIdx)
    if #tBuffers == 0 then nActive = 0
    elseif nActive > #tBuffers then nActive = #tBuffers end
    sMode = "normal"; sPending = nil
end

local function switchBuffer(n)
    if n >= 1 and n <= #tBuffers then nActive = n; sMode = "normal"; sPending = nil end
end

local function B() return tBuffers[nActive] end

-- Diff undo operations
local function undoPush(buf, tItems)
    buf.tUndo[#buf.tUndo+1] = {items=tItems}
    if #buf.tUndo > cfg.maxUndo then
        table.remove(buf.tUndo, 1)
    end
end

local function undoPushEdit(buf, nLn)
    undoPush(buf, {{op="set", ln=nLn, old=buf.tLines[nLn]}})
end

local function undoPushInsert(buf, nLn)
    undoPush(buf, {{op="ins", ln=nLn}})
end

local function undoPushDelete(buf, nLn)
    undoPush(buf, {{op="del", ln=nLn, old=buf.tLines[nLn]}})
end

local function undoPushBatch(buf, tOps)
    undoPush(buf, tOps)
end

local function undoPop(buf)
    if #buf.tUndo == 0 then sMsg = "Already at oldest change"; return end
    local tEntry = table.remove(buf.tUndo)
    -- Apply in reverse order
    for i = #tEntry.items, 1, -1 do
        local op = tEntry.items[i]
        if op.op == "set" then
            buf.tLines[op.ln] = op.old
        elseif op.op == "ins" then
            table.remove(buf.tLines, op.ln)
        elseif op.op == "del" then
            table.insert(buf.tLines, op.ln, op.old)
        end
    end
    buf.bModified = true; buf.bStateDirty = true
    -- Clamp cursor
    buf.nCL = math.max(1, math.min(buf.nCL, #buf.tLines))
end

local function markDirty(buf)
    buf.bModified = true; buf.bStateDirty = true
    buf.nEditVer = buf.nEditVer + 1
    buf.tLineVer[buf.nCL] = buf.nEditVer
end

-- =============================================
-- 8. FILE I/O
-- =============================================

local function loadFile(sPath)
    local h = fs.open(sPath, "r")
    if not h then return nil end
    local tC = {}
    while true do
        local s = fs.read(h, math.huge)
        if not s then break end
        tC[#tC+1] = s
    end
    fs.close(h)
    local sAll = table.concat(tC)
    tC = nil -- free immediately
    if #sAll == 0 then return {""} end
    local t = {}
    for sLine in (sAll.."\n"):gmatch("([^\n]*)\n") do
        t[#t+1] = sLine:gsub("\r","")
    end
    sAll = nil -- free
    if #t > 1 and t[#t] == "" then t[#t] = nil end
    if #t == 0 then t[1] = "" end
    return t
end

local function saveFile(buf)
    if not buf.sPath then return false, "No filename" end
    local h = fs.open(buf.sPath, "w")
    if not h then return false, "Cannot write: "..buf.sPath end
    fs.write(h, table.concat(buf.tLines, "\n").."\n")
    fs.close(h)
    buf.bModified = false
    return true
end

local function openFileInBuffer(sPath)
    if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/").."/"..sPath end
    sPath = sPath:gsub("//","/")
    for i,buf in ipairs(tBuffers) do
        if buf.sPath == sPath then switchBuffer(i); return i end
    end
    local tLines = loadFile(sPath)
    local buf = newBuffer(sPath, tLines)
    if tLines then ctx:toastSuccess(bufName(buf).." — "..#tLines.."L")
    else ctx:toastInfo(sPath.." [New]") end
    return addBuffer(buf)
end

-- =============================================
-- 9. EDITING HELPERS
-- =============================================

local function clamp(n,lo,hi) return math.max(lo,math.min(hi,n)) end
local function curLine(buf) return buf.tLines[buf.nCL] or "" end

local function fixCol(buf)
    local nMax = #curLine(buf)
    if sMode == "normal" then nMax = math.max(1,nMax) end
    if sMode == "insert" then nMax = nMax + 1 end
    buf.nCC = clamp(buf.nCC, 1, nMax)
end

local function gutterW(buf)
    if not cfg.lineNumbers then return 0 end
    return #tostring(#buf.tLines) + 2
end

local function ensureVisible(buf)
    local nSO = cfg.scrollOff
    if buf.nCL < buf.nTop + nSO then buf.nTop = math.max(1, buf.nCL - nSO) end
    if buf.nCL >= buf.nTop + EDIT_H - nSO then buf.nTop = buf.nCL - EDIT_H + nSO + 1 end
    local nTW = W - gutterW(buf)
    if buf.nCC < buf.nLeft then buf.nLeft = buf.nCC end
    if buf.nCC >= buf.nLeft + nTW then buf.nLeft = buf.nCC - nTW + 1 end
end

local function recomputeState(buf)
    if HL and buf.tLang then
        buf.tBlkState = HL.computeState(buf.tLines, buf.tLang)
    end
    buf.bStateDirty = false
end

local function searchFwd(buf, sTerm, nSL, nSC)
    if not sTerm or #sTerm == 0 then return nil end
    for i = nSL, #buf.tLines do
        local p = buf.tLines[i]:find(sTerm, (i==nSL) and (nSC+1) or 1, true)
        if p then return i, p end
    end
    for i = 1, nSL do
        local p = buf.tLines[i]:find(sTerm, 1, true)
        if p then return i, p end
    end
end

local function searchBwd(buf, sTerm, nSL, nSC)
    if not sTerm or #sTerm == 0 then return nil end
    for i = nSL, 1, -1 do
        local s = buf.tLines[i]
        local nMax = (i==nSL) and (nSC-1) or #s
        local nLast, nFrom = nil, 1
        while true do
            local p = s:find(sTerm, nFrom, true)
            if not p or p > nMax then break end
            nLast = p; nFrom = p + 1
        end
        if nLast then return i, nLast end
    end
end

local function nextWord(s,c)
    while c <= #s and s:sub(c,c) ~= " " do c=c+1 end
    while c <= #s and s:sub(c,c) == " " do c=c+1 end; return c
end

local function prevWord(s,c)
    c=c-1
    while c > 1 and s:sub(c,c) == " " do c=c-1 end
    while c > 1 and s:sub(c-1,c-1) ~= " " do c=c-1 end; return c
end

-- =============================================
-- 10. RENDERING
-- =============================================

local function renderTabBar()
    ctx:fill(1, TAB_Y, W, 1, " ", CLR.tabFg, CLR.tabBg)
    local nX = 2
    for i, buf in ipairs(tBuffers) do
        local bAct = (i == nActive)
        local sN = bufName(buf)
        if buf.bModified then sN = sN.."*" end
        local sL = " "..sN.." "
        if nX + #sL > W - 4 then ctx:text(nX, TAB_Y, "...", CLR.tabFg, CLR.tabBg); break end
        ctx:text(nX, TAB_Y, sL, bAct and CLR.tabAct or CLR.tabFg, bAct and CLR.tabActBg or CLR.tabBg)
        nX = nX + #sL + 1
    end
    if #tBuffers == 0 then ctx:text(2, TAB_Y, " Start ", CLR.tabAct, CLR.tabActBg) end
end

local function renderEditor()
    local buf = B()
    if not buf then return end
    if buf.bStateDirty then recomputeState(buf) end
    ensureVisible(buf)
    local nGW = gutterW(buf)
    local nTW = W - nGW

    for row = 1, EDIT_H do
        local nY = EDIT_Y + row - 1
        local nLine = buf.nTop + row - 1

        if nLine <= #buf.tLines then
            local sLine = buf.tLines[nLine]
            local bCur = (nLine == buf.nCL)
            local nBg = bCur and CLR.curLine or CLR.bg

            -- Gutter
            if cfg.lineNumbers then
                local sN = tostring(nLine)
                ctx:text(1, nY, string.rep(" ", nGW-1-#sN)..sN.." ", CLR.gutter, CLR.gutterBg)
            end

            -- Content with cached syntax
            local nX = nGW + 1
            if HL and buf.tLang then
                local bInBlk = buf.tBlkState[nLine] or false
                local lineVer = buf.tLineVer[nLine] or 0
                local cKey = lineVer * 2 + (bInBlk and 1 or 0)
                local cached = buf.tSegCache[nLine]
                local tSegs
                if cached and cached[1] == cKey and cached[3] == buf.nLeft and cached[4] == nTW then
                    tSegs = cached[2]
                else
                    tSegs = HL.segments(sLine, buf.nLeft, nTW, buf.tLang, bInBlk)
                    buf.tSegCache[nLine] = {cKey, tSegs, buf.nLeft, nTW}
                end
                for _, seg in ipairs(tSegs) do
                    ctx:text(nX, nY, seg[1], seg[2], nBg)
                    nX = nX + #seg[1]
                end
            else
                local sV = (#sLine >= buf.nLeft) and sLine:sub(buf.nLeft, buf.nLeft+nTW-1) or ""
                if #sV < nTW then sV = sV..string.rep(" ", nTW-#sV) end
                ctx:text(nX, nY, sV, CLR.fg, nBg)
            end

            -- Cursor
            if bCur then
                local nCX = nGW + buf.nCC - buf.nLeft + 1
                if nCX >= nGW+1 and nCX <= nGW+nTW then
                    local sC = (buf.nCC >= 1 and buf.nCC <= #sLine) and sLine:sub(buf.nCC,buf.nCC) or " "
                    ctx:text(nCX, nY, sC, CLR.bg, CLR.cursor)
                end
            end
        else
            if cfg.lineNumbers then
                ctx:text(1, nY, string.rep(" ", nGW), CLR.gutter, CLR.gutterBg)
            end
            ctx:text(nGW+1, nY, "~", CLR.tilde, CLR.bg)
        end
    end
end

local function renderStartScreen()
    local tLogo = {
        "               _  ",
        " __  _____ _ _(_) ",
        " \\ \\/ / -_) V / | ",
        "  >  <\\___|\\__/|_| ",
        " /_/\\_\\            ",
    }
    local nMY = math.floor(H/2) - 6
    local nMX = math.floor(W/2) - 10
    for i, s in ipairs(tLogo) do ctx:text(nMX, nMY+i, s, CLR.startAcc) end
    local nY = nMY + #tLogo + 2
    ctx:text(nMX, nY, "XE Visual Editor v2.0", CLR.startFg); nY=nY+2
    local tAct = {{"n","New buffer"},{"e","Open file..."},{"q","Quit"}}
    for _, t in ipairs(tAct) do
        ctx:text(nMX+2, nY, t[1], CLR.startKey)
        ctx:text(nMX+6, nY, t[2], CLR.fg); nY=nY+1
    end
    nY=nY+1
    ctx:text(nMX+2, nY, "F5", CLR.startKey)
    ctx:text(nMX+6, nY, "Command Palette", CLR.fg)
end

local function renderStatusBar()
    ctx:fill(1, STATUS_Y, W, 1, " ", CLR.barFg, CLR.barBg)
    if nActive == 0 then
        ctx:text(2, STATUS_Y, " xevi 2.0 ", CLR.barFg, CLR.barBg)
        return
    end
    local buf = B(); if not buf then return end
    local tM = {normal={" NORMAL ",CLR.modeN}, insert={" INSERT ",CLR.modeI},
                command={" COMMAND ",CLR.modeC}, search={" SEARCH ",CLR.modeS}}
    local m = tM[sMode] or {" ? ", CLR.barFg}
    ctx:text(1, STATUS_Y, m[1], CLR.bg, m[2])
    local nX = #m[1] + 2
    local sN = buf.sPath and bufName(buf) or "[No Name]"
    local sMod = buf.bModified and " [+]" or ""
    ctx:text(nX, STATUS_Y, sN..sMod, CLR.barFg, CLR.barBg)
    nX = nX + #sN + #sMod + 2
    if buf.tLang and buf.tLang.name ~= "Text" then
        ctx:text(nX, STATUS_Y, buf.tLang.name, CLR.tabFg, CLR.barBg)
    end
    local sR = string.format("Ln %d/%d Col %d  %d/%d ", buf.nCL, #buf.tLines, buf.nCC, nActive, #tBuffers)
    ctx:text(W-#sR+1, STATUS_Y, sR, CLR.barFg, CLR.barBg)
end

local function renderCommandLine()
    local sText = ""
    if sMode == "command" then sText = ":"..sCmdBuf.."_"
    elseif sMode == "search" then sText = "/"..sSearchBuf.."_"
    elseif #sMsg > 0 then sText = sMsg; sMsg = ""
    end
    ctx:textPad(1, CMD_Y, W, sText, CLR.fg, CLR.bg)
end

-- Fuzzy command suggestion dropdown (rendered upward from CMD_Y)
local function renderSuggestions()
    if sMode ~= "command" or #tCmdSugg == 0 then return end
    local nCount = math.min(#tCmdSugg, nSuggMax)
    local nDropW = math.min(42, W - 2)
    local nDropX = 2
    local nCmdW = 14
    local nDescW = nDropW - nCmdW - 3

    for i = 1, nCount do
        -- Render from bottom to top (closest match near command line)
        local nY = CMD_Y - 1 - (i - 1)
        if nY < EDIT_Y then break end

        local def = tCmdSugg[i].def
        local bSel = (i == nSuggSel)

        local sBg = bSel and CLR.dropSelBg or CLR.dropBg
        local sFgCmd = bSel and CLR.dropSel or CLR.dropCmd
        local sFgDesc = bSel and CLR.dropSel or CLR.dropDesc

        -- Background fill
        ctx:fill(nDropX, nY, nDropW, 1, " ", CLR.fg, sBg)

        -- Selection indicator
        local sInd = bSel and "> " or "  "
        ctx:text(nDropX, nY, sInd, CLR.dropSel, sBg)

        -- Command name
        local sCmd = def.cmd
        if #sCmd > nCmdW then sCmd = sCmd:sub(1, nCmdW-1).."…" end
        ctx:text(nDropX + 2, nY, sCmd, sFgCmd, sBg)

        -- Description
        if def.desc and nDescW > 4 then
            local sDesc = def.desc
            if #sDesc > nDescW then sDesc = sDesc:sub(1, nDescW-1).."…" end
            ctx:text(nDropX + 2 + nCmdW + 1, nY, sDesc, sFgDesc, sBg)
        end
    end
end

-- =============================================
-- 11. INPUT: NORMAL MODE
-- =============================================

local function handleNormal(k)
    local buf = B(); if not buf then return end

    if sPending == "g" then
        sPending = nil
        if k == "g" then buf.nCL=1; buf.nCC=1; fixCol(buf)
        elseif k == "t" then switchBuffer(nActive < #tBuffers and nActive+1 or 1)
        elseif k == "T" then switchBuffer(nActive > 1 and nActive-1 or #tBuffers) end
        return
    end
    if sPending == "d" then
        sPending = nil
        if k == "d" then
            undoPushDelete(buf, buf.nCL)
            buf.sYankBuf = buf.tLines[buf.nCL]; buf.bYankLine = true
            table.remove(buf.tLines, buf.nCL)
            if #buf.tLines == 0 then buf.tLines[1] = "" end
            buf.nCL = clamp(buf.nCL, 1, #buf.tLines); fixCol(buf); markDirty(buf)
        end; return
    end
    if sPending == "y" then
        sPending = nil
        if k == "y" then
            buf.sYankBuf = buf.tLines[buf.nCL]; buf.bYankLine = true
            sMsg = "1 line yanked"
        end; return
    end

    if     k=="h" or k=="\27[D" then buf.nCC=buf.nCC-1; fixCol(buf)
    elseif k=="l" or k=="\27[C" then buf.nCC=buf.nCC+1; fixCol(buf)
    elseif k=="j" or k=="\27[B" then buf.nCL=math.min(buf.nCL+1,#buf.tLines); fixCol(buf)
    elseif k=="k" or k=="\27[A" then buf.nCL=math.max(buf.nCL-1,1); fixCol(buf)
    elseif k=="0" or k=="\27[H" then buf.nCC=1
    elseif k=="$" or k=="\27[F" then buf.nCC=#curLine(buf); fixCol(buf)
    elseif k=="w" then buf.nCC=nextWord(curLine(buf),buf.nCC); fixCol(buf)
    elseif k=="b" then buf.nCC=prevWord(curLine(buf),buf.nCC); fixCol(buf)
    elseif k=="G" then buf.nCL=#buf.tLines; fixCol(buf)
    elseif k=="g" then sPending="g"
    elseif k=="\27[5~" then buf.nCL=math.max(1,buf.nCL-EDIT_H); fixCol(buf)
    elseif k=="\27[6~" then buf.nCL=math.min(#buf.tLines,buf.nCL+EDIT_H); fixCol(buf)
    elseif k=="i" then undoPushEdit(buf,buf.nCL); sMode="insert"
    elseif k=="a" then
        undoPushEdit(buf,buf.nCL); sMode="insert"
        if #curLine(buf)>0 then buf.nCC=buf.nCC+1 end
    elseif k=="A" then undoPushEdit(buf,buf.nCL); sMode="insert"; buf.nCC=#curLine(buf)+1
    elseif k=="o" then
        local sInd = ""
        if cfg.autoIndent then sInd = (buf.tLines[buf.nCL] or ""):match("^(%s*)") or "" end
        table.insert(buf.tLines, buf.nCL+1, sInd)
        undoPushInsert(buf, buf.nCL+1)
        buf.nCL=buf.nCL+1; buf.nCC=#sInd+1; sMode="insert"; markDirty(buf)
    elseif k=="O" then
        table.insert(buf.tLines, buf.nCL, "")
        undoPushInsert(buf, buf.nCL)
        buf.nCC=1; sMode="insert"; markDirty(buf)
    elseif k=="x" then
        local s=curLine(buf)
        if #s>0 and buf.nCC<=#s then
            undoPushEdit(buf,buf.nCL)
            buf.tLines[buf.nCL]=s:sub(1,buf.nCC-1)..s:sub(buf.nCC+1)
            fixCol(buf); markDirty(buf)
        end
    elseif k=="d" then sPending="d"
    elseif k=="y" then sPending="y"
    elseif k=="p" then
        if #buf.sYankBuf>0 then
            if buf.bYankLine then
                table.insert(buf.tLines, buf.nCL+1, buf.sYankBuf)
                undoPushInsert(buf, buf.nCL+1)
                buf.nCL=buf.nCL+1; buf.nCC=1
            else
                undoPushEdit(buf,buf.nCL)
                local s=curLine(buf)
                buf.tLines[buf.nCL]=s:sub(1,buf.nCC)..buf.sYankBuf..s:sub(buf.nCC+1)
                buf.nCC=buf.nCC+#buf.sYankBuf
            end
            markDirty(buf); fixCol(buf)
        end
    elseif k=="J" then
        if buf.nCL < #buf.tLines then
            local tOps = {
                {op="set", ln=buf.nCL, old=buf.tLines[buf.nCL]},
                {op="del", ln=buf.nCL+1, old=buf.tLines[buf.nCL+1]},
            }
            local nO=#curLine(buf)
            buf.tLines[buf.nCL]=curLine(buf).." "..buf.tLines[buf.nCL+1]
            table.remove(buf.tLines, buf.nCL+1)
            buf.nCC=nO+1; undoPushBatch(buf,tOps); markDirty(buf)
        end
    elseif k=="u" then undoPop(buf)
    elseif k=="/" then sMode="search"; sSearchBuf=""
    elseif k=="n" then
        local nl,nc = searchFwd(buf, sSearchTerm, buf.nCL, buf.nCC)
        if nl then buf.nCL=nl; buf.nCC=nc; fixCol(buf) else sMsg="Not found" end
    elseif k=="N" then
        local nl,nc = searchBwd(buf, sSearchTerm, buf.nCL, buf.nCC)
        if nl then buf.nCL=nl; buf.nCC=nc; fixCol(buf) else sMsg="Not found" end
    elseif k==":" then
        sMode="command"; sCmdBuf=""; nSuggSel=0; updateSuggestions()
    elseif k=="\27[15~" then bPalette=true
    elseif k=="\7" then
        sMsg=string.format('"%s" %s%dL %dC', buf.sPath or "[No Name]",
            buf.bModified and "[+] " or "", #buf.tLines, #curLine(buf))
    end
end

-- =============================================
-- 12. INPUT: INSERT MODE
-- =============================================

local function handleInsert(k)
    local buf = B(); if not buf then return end
    local s = curLine(buf)

    if k == "\27" then
        sMode="normal"; buf.nCC=math.max(1,buf.nCC-1); fixCol(buf); return
    end

    -- Plugin hook: on_insert_char
    if oPlug and k and #k==1 and k:byte()>=32 then
        local vResult = oPlug.hook("on_insert_char", g_tPlugApi, buf, k)
        if vResult and type(vResult) == "string" then k = vResult end
    end

    if k=="\b" then
        if buf.nCC > 1 then
            buf.tLines[buf.nCL]=s:sub(1,buf.nCC-2)..s:sub(buf.nCC)
            buf.nCC=buf.nCC-1; markDirty(buf)
        elseif buf.nCL > 1 then
            local tOps = {
                {op="set", ln=buf.nCL-1, old=buf.tLines[buf.nCL-1]},
                {op="del", ln=buf.nCL, old=buf.tLines[buf.nCL]},
            }
            local sPrev=buf.tLines[buf.nCL-1]; buf.nCC=#sPrev+1
            buf.tLines[buf.nCL-1]=sPrev..s
            table.remove(buf.tLines, buf.nCL)
            buf.nCL=buf.nCL-1; undoPushBatch(buf,tOps); markDirty(buf)
        end
    elseif k=="\n" then
        local sInd = ""
        if cfg.autoIndent then sInd = s:match("^(%s*)") or "" end
        local tOps = {{op="set", ln=buf.nCL, old=s}}
        buf.tLines[buf.nCL]=s:sub(1,buf.nCC-1)
        table.insert(buf.tLines, buf.nCL+1, sInd..s:sub(buf.nCC))
        tOps[2] = {op="ins", ln=buf.nCL+1}
        buf.nCL=buf.nCL+1; buf.nCC=#sInd+1
        undoPushBatch(buf,tOps); markDirty(buf)
    elseif k=="\t" then
        local sTab=string.rep(" ", cfg.tabSize)
        buf.tLines[buf.nCL]=s:sub(1,buf.nCC-1)..sTab..s:sub(buf.nCC)
        buf.nCC=buf.nCC+cfg.tabSize; markDirty(buf)
    elseif k=="\27[A" then buf.nCL=math.max(1,buf.nCL-1); fixCol(buf)
    elseif k=="\27[B" then buf.nCL=math.min(#buf.tLines,buf.nCL+1); fixCol(buf)
    elseif k=="\27[D" then buf.nCC=math.max(1,buf.nCC-1)
    elseif k=="\27[C" then buf.nCC=math.min(#s+1,buf.nCC+1)
    elseif k=="\27[H" then buf.nCC=1
    elseif k=="\27[F" then buf.nCC=#s+1
    elseif k=="\27[5~" then buf.nCL=math.max(1,buf.nCL-EDIT_H); fixCol(buf)
    elseif k=="\27[6~" then buf.nCL=math.min(#buf.tLines,buf.nCL+EDIT_H); fixCol(buf)
    elseif k and #k>=1 and k:byte()>=32 and k:byte()<127 then
        -- Handle multi-char from plugins (e.g. autopairs: "()")
        for ci = 1, #k do
            local ch = k:sub(ci,ci)
            local sL = buf.tLines[buf.nCL]
            buf.tLines[buf.nCL]=sL:sub(1,buf.nCC-1)..ch..sL:sub(buf.nCC)
            buf.nCC=buf.nCC+1
        end
        markDirty(buf)
    end
end

-- =============================================
-- 13. INPUT: COMMAND MODE (with fuzzy dropdown)
-- =============================================

local function executeCommand(sCmd)
    local sC = sCmd:match("^(%S+)")
    local sA = sCmd:match("^%S+%s+(.+)$")
    local buf = B()

    -- Check plugin commands first
    if oPlug then
        for _, pc in ipairs(g_tPlugCommands) do
            if pc.cmd == sC and pc.func then
                pcall(pc.func, g_tPlugApi)
                return
            end
        end
    end

    if sC=="w" or sC=="write" then
        if sA and buf then buf.sPath=sA; buf.tLang=HL and HL.detect(sA) or nil; buf.bStateDirty=true end
        if buf then
            local ok,err = saveFile(buf)
            if ok then ctx:toastSuccess("Written: "..bufName(buf))
            else ctx:toastError(err) end
            if oPlug then oPlug.hook("on_save", g_tPlugApi, buf) end
        end
    elseif sC=="q" or sC=="quit" then
        if buf and buf.bModified then sMsg="Unsaved changes (use :q!)"
        elseif #tBuffers<=1 then bRunning=false
        else closeBuffer(nActive) end
    elseif sC=="q!" then
        if #tBuffers<=1 then bRunning=false else closeBuffer(nActive) end
    elseif sC=="wq" or sC=="x" then
        if buf then
            if sA then buf.sPath=sA end
            local ok,err = saveFile(buf)
            if ok then
                if #tBuffers<=1 then bRunning=false else closeBuffer(nActive) end
            else ctx:toastError(err) end
        end
    elseif sC=="e" or sC=="edit" then
        if sA then openFileInBuffer(sA) else sPromptId="open" end
    elseif sC=="bn" or sC=="bnext" then switchBuffer(nActive<#tBuffers and nActive+1 or 1)
    elseif sC=="bp" or sC=="bprev" then switchBuffer(nActive>1 and nActive-1 or #tBuffers)
    elseif sC=="bd" or sC=="bdelete" then
        if buf and buf.bModified then sMsg="Unsaved (use :bd!)" else closeBuffer(nActive) end
    elseif sC=="bd!" then closeBuffer(nActive)
    elseif sC=="new" then addBuffer(newBuffer(nil))
    elseif sC=="set" then
        if sA=="number" or sA=="nu" then cfg.lineNumbers=true
        elseif sA=="nonumber" or sA=="nonu" then cfg.lineNumbers=false
        elseif sA and sA:match("^tabsize=") then cfg.tabSize=tonumber(sA:match("=(%d+)")) or 2
        elseif sA and sA:match("^scrolloff=") then cfg.scrollOff=tonumber(sA:match("=(%d+)")) or 3
        else sMsg="set: "..tostring(sA) end
    elseif sC=="qa" or sC=="qall" then bRunning=false
    elseif sC=="PlugInstall" then
        if oPlug then
            ctx:toastInfo("Installing plugins...")
            local nOk,nFail = oPlug.installAll(function(n,m) ctx:toastInfo(n..": "..m) end)
            ctx:toastSuccess(nOk.." installed, "..nFail.." failed")
            oPlug.loadAll(nil, cfg.plugin_opts or {})
            g_tPlugCommands = oPlug.getCommands()
            tAllCommands = rebuildCommandDefs()
        else sMsg="Plugin system not available" end
    elseif sC=="PlugStatus" then
        if oPlug then
            local tS = oPlug.status()
            for _, p in ipairs(tS) do
                local sI = p.loaded and "✓" or (p.installed and "○" or "✗")
                ctx:toast(sI.." "..p.name.." "..p.version, 4, CLR.fg, CLR.dropBg)
            end
        end
    elseif sC=="PlugUpdate" then
        if oPlug then
            local nOk,nFail = oPlug.updateAll(function(n,m) ctx:toastInfo(n..": "..m) end)
            ctx:toastSuccess(nOk.." updated, "..nFail.." failed")
        end
    elseif sC=="PlugClean" then
        if oPlug then
            local tR = oPlug.clean()
            if #tR > 0 then ctx:toastWarn("Removed: "..table.concat(tR, ", "))
            else ctx:toastInfo("Nothing to clean") end
        end
    elseif tonumber(sC) then
        if buf then buf.nCL=clamp(tonumber(sC),1,#buf.tLines); fixCol(buf) end
    else sMsg="Unknown: "..sCmd end
end

local function handleCommand(k)
    if k=="\27" then sMode="normal"; tCmdSugg={}; return end

    if k=="\t" then
        -- Tab: complete from selected suggestion
        if nSuggSel >= 1 and nSuggSel <= #tCmdSugg then
            sCmdBuf = tCmdSugg[nSuggSel].def.cmd
            updateSuggestions()
        elseif #tCmdSugg > 0 then
            nSuggSel = 1
        end
        return
    end

    -- Arrow keys navigate suggestions
    if k=="\27[A" then -- Up = next suggestion (further from cmd line)
        if #tCmdSugg > 0 then
            nSuggSel = nSuggSel + 1
            if nSuggSel > #tCmdSugg then nSuggSel = 1 end
        end
        return
    end
    if k=="\27[B" then -- Down = previous suggestion (closer to cmd line)
        if #tCmdSugg > 0 then
            nSuggSel = nSuggSel - 1
            if nSuggSel < 1 then nSuggSel = #tCmdSugg end
        end
        return
    end

    if k=="\n" then
        sMode="normal"
        local sExec = sCmdBuf
        -- If a suggestion is selected and buffer matches, use it
        if nSuggSel >= 1 and nSuggSel <= #tCmdSugg then
            local sDef = tCmdSugg[nSuggSel].def.cmd
            -- Only auto-complete if user hasn't typed something completely different
            local sFirst = sCmdBuf:match("^(%S+)") or sCmdBuf
            local bM = fuzzyMatch(sFirst, sDef)
            if bM and #sFirst > 0 then
                -- Replace command part, keep any arguments
                local sArgs = sCmdBuf:match("^%S+(.*)$") or ""
                sExec = sDef .. sArgs
            end
        end
        sCmdBuf=""; tCmdSugg={}; nSuggSel=0
        executeCommand(sExec)
        return
    end

    if k=="\b" then
        if #sCmdBuf > 0 then sCmdBuf=sCmdBuf:sub(1,-2)
        else sMode="normal"; tCmdSugg={}; return end
    elseif k and #k==1 and k:byte()>=32 then
        sCmdBuf = sCmdBuf .. k
    end

    -- Update fuzzy suggestions on every keystroke
    nSuggSel = 0  -- reset selection on new input
    updateSuggestions()
    -- Auto-select first if matches exist
    if #tCmdSugg > 0 then nSuggSel = 1 end
end

-- =============================================
-- 14. INPUT: SEARCH MODE
-- =============================================

local function handleSearch(k)
    if k=="\27" then sMode="normal"; return end
    if k=="\n" then
        sMode="normal"; sSearchTerm=sSearchBuf; sSearchBuf=""
        local buf = B()
        if buf then
            local nl,nc = searchFwd(buf, sSearchTerm, buf.nCL, buf.nCC)
            if nl then buf.nCL=nl; buf.nCC=nc; fixCol(buf)
            else sMsg="Not found: "..sSearchTerm end
        end; return
    end
    if k=="\b" then
        if #sSearchBuf>0 then sSearchBuf=sSearchBuf:sub(1,-2) else sMode="normal" end
    elseif k and #k==1 and k:byte()>=32 then sSearchBuf=sSearchBuf..k end
end

-- =============================================
-- 15. COMMAND PALETTE
-- =============================================

local tPaletteCommands = {
    {id="new",    label="New Buffer",           shortcut=":new"},
    {id="open",   label="Open File...",         shortcut=":e"},
    {id="save",   label="Save",                 shortcut=":w"},
    {id="saveas", label="Save As...",           shortcut=":w <path>"},
    {id="close",  label="Close Buffer",         shortcut=":bd"},
    {id="next",   label="Next Buffer",          shortcut="gt"},
    {id="prev",   label="Previous Buffer",      shortcut="gT"},
    {id="goto",   label="Go to Line...",        shortcut=":<n>"},
    {id="find",   label="Find...",              shortcut="/"},
    {id="nu_on",  label="Show Line Numbers",    shortcut=":set nu"},
    {id="nu_off", label="Hide Line Numbers",    shortcut=":set nonu"},
    {id="start",  label="Show Start Screen",    shortcut=""},
    {id="plug_i", label="Plugin: Install All",  shortcut=":PlugInstall"},
    {id="plug_s", label="Plugin: Status",       shortcut=":PlugStatus"},
    {id="plug_u", label="Plugin: Update All",   shortcut=":PlugUpdate"},
    {id="quit",   label="Quit xevi",            shortcut=":qa"},
}

local function handlePaletteResult(sId)
    bPalette = false
    local buf = B()
    if     sId=="new"    then addBuffer(newBuffer(nil))
    elseif sId=="open"   then sPromptId="open"
    elseif sId=="save"   then
        if buf then
            if buf.sPath then
                local ok,err=saveFile(buf)
                if ok then ctx:toastSuccess("Saved") else ctx:toastError(err) end
            else sPromptId="saveas" end
        end
    elseif sId=="saveas" then sPromptId="saveas"
    elseif sId=="close"  then if nActive>0 then closeBuffer(nActive) end
    elseif sId=="next"   then if #tBuffers>0 then switchBuffer(nActive<#tBuffers and nActive+1 or 1) end
    elseif sId=="prev"   then if #tBuffers>0 then switchBuffer(nActive>1 and nActive-1 or #tBuffers) end
    elseif sId=="goto"   then sPromptId="goto"
    elseif sId=="find"   then sPromptId="find"
    elseif sId=="nu_on"  then cfg.lineNumbers=true
    elseif sId=="nu_off" then cfg.lineNumbers=false
    elseif sId=="start"  then nActive=0; sMode="normal"
    elseif sId=="plug_i" then executeCommand("PlugInstall")
    elseif sId=="plug_s" then executeCommand("PlugStatus")
    elseif sId=="plug_u" then executeCommand("PlugUpdate")
    elseif sId=="quit"   then bRunning=false end
end

-- =============================================
-- 16. PLUGIN API (exposed to plugins)
-- =============================================

g_tPlugApi.toast = function(sMsg) ctx:toast(sMsg, 2) end
g_tPlugApi.toastInfo = function(s) ctx:toastInfo(s) end
g_tPlugApi.toastError = function(s) ctx:toastError(s) end
g_tPlugApi.getBuffer = function() return B() end
g_tPlugApi.getMode = function() return sMode end
g_tPlugApi.getCfg = function() return cfg end

-- =============================================
-- 17. INIT: OPEN FILES, LOAD PLUGINS
-- =============================================

-- Build full command list
initPlugins()
tAllCommands = rebuildCommandDefs()

for _, sArg in ipairs(tArgs) do
    if sArg:sub(1,1) ~= "-" then openFileInBuffer(sArg) end
end

-- =============================================
-- 18. MAIN LOOP
-- =============================================

while bRunning do
    ctx:beginFrame()
    ctx:clear(CLR.bg)

    renderTabBar()
    if nActive == 0 or #tBuffers == 0 then
        renderStartScreen()
    else
        renderEditor()
    end
    renderStatusBar()
    renderCommandLine()

    -- Command suggestion dropdown (rendered AFTER editor, overlays it)
    renderSuggestions()

    -- ── Modals ──
    if bPalette then
        local r = ctx:commandPalette("xevi_cp", tPaletteCommands)
        if r then handlePaletteResult(r)
        elseif r == false then bPalette=false end
    end
    if sPromptId=="open" then
        local r = ctx:prompt("xevi_open","Open File","Path:",env.PWD or "/")
        if type(r)=="string" and #r>0 then openFileInBuffer(r); sPromptId=nil
        elseif r==false then sPromptId=nil end
    end
    if sPromptId=="saveas" then
        local buf = B()
        local r = ctx:prompt("xevi_saveas","Save As","Path:",buf and buf.sPath or "")
        if type(r)=="string" and #r>0 then
            if buf then
                buf.sPath=r; buf.tLang=HL and HL.detect(r) or nil; buf.bStateDirty=true
                local ok,err=saveFile(buf)
                if ok then ctx:toastSuccess("Saved: "..r) else ctx:toastError(err) end
            end; sPromptId=nil
        elseif r==false then sPromptId=nil end
    end
    if sPromptId=="goto" then
        local r = ctx:prompt("xevi_goto","Go to Line","Line:","")
        if type(r)=="string" then
            local n=tonumber(r); local buf=B()
            if n and buf then buf.nCL=clamp(n,1,#buf.tLines); fixCol(buf) end
            sPromptId=nil
        elseif r==false then sPromptId=nil end
    end
    if sPromptId=="find" then
        local r = ctx:prompt("xevi_find","Find","Search:",sSearchTerm)
        if type(r)=="string" and #r>0 then
            sSearchTerm=r; local buf=B()
            if buf then
                local nl,nc=searchFwd(buf,sSearchTerm,buf.nCL,buf.nCC)
                if nl then buf.nCL=nl; buf.nCC=nc; fixCol(buf)
                else ctx:toastWarn("Not found: "..r) end
            end; sPromptId=nil
        elseif r==false then sPromptId=nil end
    end

    -- ── Input ──
    if not ctx:hasModal() then
        local k = ctx:key()
        if k then
            if k=="\3" then
                if sMode~="normal" then sMode="normal"; tCmdSugg={}
                    if B() then fixCol(B()) end
                elseif nActive==0 then bRunning=false end
            elseif k=="\27[15~" then bPalette=true
            elseif nActive==0 or #tBuffers==0 then
                if k=="n" or k=="i" then addBuffer(newBuffer(nil))
                elseif k=="e" then sPromptId="open"
                elseif k=="q" then bRunning=false end
            elseif sMode=="normal" then handleNormal(k)
            elseif sMode=="insert" then handleInsert(k)
            elseif sMode=="command" then handleCommand(k)
            elseif sMode=="search" then handleSearch(k) end
        end
    end

    ctx:endFrame()
end

ctx:destroy()