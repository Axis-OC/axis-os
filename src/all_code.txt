axis-os\src\kernel\bin\init.lua
```
--
-- /bin/init.lua
-- Paranoid Mode
--
local oFs = require("filesystem")
local oSys = require("syscall")

local hStdin = oFs.open("/dev/tty", "r")
local hStdout = oFs.open("/dev/tty", "w")

if not hStdin or not hStdout then
  syscall("kernel_log", "[INIT] FATAL: Could not open /dev/tty!")
end

local function readFileSimple(sPath)
  local h = oFs.open(sPath, "r")
  if not h then return nil end
  local d = oFs.read(h, math.huge)
  oFs.close(h)
  if type(d) ~= "string" then return nil end
  return d:gsub("\n", "")
end

local sHostname = readFileSimple("/etc/hostname") or "localhost"

local function fHash(sPassword)
  return string.reverse(sPassword) .. "AURA_SALT"
end

local tPasswdDb = {}

local function fLoadPasswd()
  local sContent = readFileSimple("/etc/passwd.lua")
  if sContent and #sContent > 0 then
      local f, err = load(sContent, "passwd", "t", {})
      if f then 
         local tResult = f()
         if type(tResult) == "table" then tPasswdDb = tResult end
      end
  end
  if not tPasswdDb or not next(tPasswdDb) then
     tPasswdDb = { root = { hash = fHash("root"), home = "/", shell = "/bin/sh.lua", uid=0 } }
  end
end

fLoadPasswd()

oFs.write(hStdout, "\f")


-- Replace the main loop in init.lua:
while true do
  io.write("    _        _          ___   ____  ",
 "   / \\  __ _(_)_______/ _ \\/ ___| ",
 "  / _ \\ \\ \\/ / / __| | | \\___ \\ ",
 " / ___ \\ >  <| \\__ \\ |_| |___) |",
 "/_/   \\_/_/\\_\\_|___/\\___/|____/ ")

  io.write("AxisOS v0.32-alpha1\n")
  io.write("")
  io.write("\n________________________________________________\n\n")
  io.write("XEN XKA v0.32A1 on " .. sHostname .. "\n\n")
  
  io.write(sHostname .. " login: ")   -- No buffering, appears immediately
  
  local sUsername = oFs.read(hStdin)
  
  if sUsername then
    sUsername = sUsername:gsub("\n", ""):gsub(" ", "")
    
    local tUserEntry = tPasswdDb[sUsername]
    
    io.write("Password: ")             -- No buffering
    
    local sPassword = oFs.read(hStdin) 
    if sPassword then sPassword = sPassword:gsub("\n", "") end

    if tUserEntry and tUserEntry.hash == fHash(sPassword or "") then
      io.write("\nAccess Granted.\n")
      
      local nTargetRing = tUserEntry.ring or 3
      
      if nTargetRing == 0 then
         io.write("\27[31mWARNING: SPAWNING IN RING 0 (KERNEL MODE)\27[37m\n")
      end

      local nPid = oSys.spawn(tUserEntry.shell, nTargetRing, { 
        USER = sUsername,
        UID = tUserEntry.uid,
        HOME = tUserEntry.home,
        PWD = tUserEntry.home,
        PATH = "/usr/commands",
        HOSTNAME = sHostname
      })
      
      if nPid then
        oSys.wait(nPid)
        io.write("\f")
      end
    else
      io.write("\nLogin incorrect\n")
      syscall("process_yield")  -- yield instead of wait(0) which does nothing
    end
  else
    syscall("kernel_log", "[INIT] Error reading stdin. Retrying...")
    syscall("process_yield")
  end
end
```


axis-os\src\kernel\bin\sh.lua
```
--
-- /bin/sh.lua
-- AxisOS Shell v2
-- Tab completion, command history, proper line editing.
--

local oFs = require("filesystem")
local oSys = require("syscall")

local hStdin = oFs.open("/dev/tty", "r")
local hStdout = oFs.open("/dev/tty", "w")
local hStderr = hStdout

if not hStdin then syscall("kernel_panic", "SH: No TTY") end

local ENV = env or {}
ENV.PWD = ENV.PWD or "/"
ENV.PATH = ENV.PATH or "/usr/commands"
ENV.USER = ENV.USER or "user"
ENV.HOME = ENV.HOME or "/"
ENV.HOSTNAME = ENV.HOSTNAME or "box"

-- =============================================
-- PARSING
-- =============================================

local function parseLine(line)
  local args = {}
  local current = ""
  local inQuote = false
  for i = 1, #line do
    local c = line:sub(i,i)
    if c == '"' then
      inQuote = not inQuote
    elseif c == ' ' and not inQuote then
      if #current > 0 then table.insert(args, current); current = "" end
    elseif c ~= "\n" then
      current = current .. c
    end
  end
  if #current > 0 then table.insert(args, current) end
  return args
end

-- =============================================
-- PROMPT
-- =============================================

local function getPromptString()
  local r = syscall("process_get_ring")
  local char = (r == 2.5) and "#" or "$"
  local path = ENV.PWD
  if ENV.HOME and #ENV.HOME > 0 and path:sub(1, #ENV.HOME) == ENV.HOME then
    path = "~" .. path:sub(#ENV.HOME + 1)
  end
  return string.format("\27[32m%s@%s\27[37m:\27[34m%s\27[37m%s ", ENV.USER, ENV.HOSTNAME, path, char)
end

-- local function getPrompt()
--  return "\n" .. getPromptString()
-- end

-- =============================================
-- COMMAND RESOLUTION
-- =============================================

local function findExecutable(cmd)
  if cmd:sub(1,1) == "/" or cmd:sub(1,2) == "./" then
    local path = cmd
    if path:sub(1,2) == "./" then path = ENV.PWD .. path:sub(2) end
    return path
  end
  for path in string.gmatch(ENV.PATH, "[^:]+") do
    local full = path .. "/" .. cmd .. ".lua"
    local h = oFs.open(full, "r")
    if h then
      oFs.close(h)
      return full
    end
  end
  return nil
end

-- =============================================
-- BUILTINS
-- =============================================

local builtins = {}

function builtins.cd(args)
  local newDir = args[1] or ENV.HOME
  if newDir == ".." then
    ENV.PWD = ENV.PWD:match("(.*/)[^/]+/?$") or "/"
    if ENV.PWD:sub(#ENV.PWD) == "/" and #ENV.PWD > 1 then
      ENV.PWD = ENV.PWD:sub(1, -2)
    end
    return true
  end
  if newDir:sub(1,1) ~= "/" then
    newDir = ENV.PWD .. (ENV.PWD == "/" and "" or "/") .. newDir
  end
  local list = oFs.list(newDir)
  if list then
    ENV.PWD = newDir
  else
    oFs.write(hStderr, "cd: " .. newDir .. ": No such directory\n")
  end
  return true
end

function builtins.exit() return false end

function builtins.pwd()
  oFs.write(hStdout, ENV.PWD .. "\n")
  return true
end

function builtins.export(args)
  if args[1] then
    local k, v = args[1]:match("([^=]+)=(.*)")
    if k then ENV[k] = v end
  end
  return true
end

function builtins.history()
  -- defined below after tHistory is declared
  return true
end

-- =============================================
-- TAB COMPLETION (regex-free)
-- =============================================

local function startsWith(s, prefix)
  if #prefix == 0 then return true end
  return s:sub(1, #prefix) == prefix
end

local function findCommonPrefix(tStrings)
  if #tStrings == 0 then return "" end
  if #tStrings == 1 then return tStrings[1] end
  local sFirst = tStrings[1]
  local nLen = #sFirst
  for i = 2, #tStrings do
    local s = tStrings[i]
    local nMinLen = math.min(nLen, #s)
    nLen = nMinLen
    for j = 1, nMinLen do
      if sFirst:sub(j, j) ~= s:sub(j, j) then
        nLen = j - 1
        break
      end
    end
  end
  return sFirst:sub(1, nLen)
end

local function getCompletions(sPartial, bIsCommand)
  local tMatches = {}

  if bIsCommand then
    -- Search PATH directories
    for sDir in string.gmatch(ENV.PATH, "[^:]+") do
      local tList = oFs.list(sDir)
      if tList and type(tList) == "table" then
        for _, sName in ipairs(tList) do
          local sClean = sName
          if sClean:sub(-1) == "/" then sClean = sClean:sub(1, -2) end
          -- Strip .lua extension for command names
          local sCmd = sClean
          if sCmd:sub(-4) == ".lua" then sCmd = sCmd:sub(1, -5) end
          if startsWith(sCmd, sPartial) then
            table.insert(tMatches, sCmd)
          end
        end
      end
    end
    -- Also search builtins
    for sName, _ in pairs(builtins) do
      if startsWith(sName, sPartial) then
        table.insert(tMatches, sName)
      end
    end
  else
    -- File/directory completion
    local sDir, sPrefix
    -- Find last / in partial
    local nLastSlash = 0
    for i = #sPartial, 1, -1 do
      if sPartial:sub(i, i) == "/" then nLastSlash = i; break end
    end

    if nLastSlash > 0 then
      sDir = sPartial:sub(1, nLastSlash)
      sPrefix = sPartial:sub(nLastSlash + 1)
    else
      sDir = ENV.PWD .. (ENV.PWD == "/" and "" or "/")
      sPrefix = sPartial
    end

    -- Resolve relative path
    if sDir:sub(1,1) ~= "/" then
      sDir = ENV.PWD .. (ENV.PWD == "/" and "" or "/") .. sDir
    end

    local tList = oFs.list(sDir)
    if tList and type(tList) == "table" then
      for _, sName in ipairs(tList) do
        local sClean = sName
        local bIsDir = (sClean:sub(-1) == "/")
        if bIsDir then sClean = sClean:sub(1, -2) end

        if startsWith(sClean, sPrefix) then
          local sEntry = sClean
          if bIsDir then sEntry = sEntry .. "/" end
          table.insert(tMatches, sEntry)
        end
      end
    end
  end

  table.sort(tMatches)
  -- Deduplicate
  local tUnique = {}
  local sPrev = nil
  for _, s in ipairs(tMatches) do
    if s ~= sPrev then
      table.insert(tUnique, s)
      sPrev = s
    end
  end
  return tUnique
end

-- =============================================
-- HISTORY
-- =============================================

local tHistory = {}
local nHistoryIdx = 0

builtins.history = function()
  for i, sLine in ipairs(tHistory) do
    oFs.write(hStdout, string.format(" %3d  %s\n", i, sLine))
  end
  return true
end

-- =============================================
-- LINE EDITOR (uses TTY cooked mode with tab/arrow signals)
-- =============================================

local function eraseLine(sText)
  -- Send backspaces to erase sText from screen
  for i = 1, #sText do
    oFs.write(hStdout, "\b")
  end
end

local function replaceLine(sOld, sNew)
  eraseLine(sOld)
  oFs.write(hStdout, sNew)
  oFs.flush(hStdout)
  oFs.deviceControl(hStdin, "set_buffer", {sNew})
end

local function handleTab(sCurrentBuffer)
  local sLastWord = ""
  local nWordStart = #sCurrentBuffer + 1
  for i = #sCurrentBuffer, 1, -1 do
    if sCurrentBuffer:sub(i, i) == " " then break end
    nWordStart = i
  end
  sLastWord = sCurrentBuffer:sub(nWordStart)

  local sBeforeWord = sCurrentBuffer:sub(1, nWordStart - 1)
  local bIsCommand = true
  for i = 1, #sBeforeWord do
    if sBeforeWord:sub(i, i) ~= " " then
      bIsCommand = false
      break
    end
  end

  local tMatches = getCompletions(sLastWord, bIsCommand)

  -- For file paths, extract just the filename prefix (after last /)
  -- Commands: sTypedPrefix == sLastWord (no slashes)
  -- Files:    "/etc/p" → sTypedPrefix = "p"
  local sTypedPrefix = sLastWord
  if not bIsCommand then
    for i = #sLastWord, 1, -1 do
      if sLastWord:sub(i, i) == "/" then
        sTypedPrefix = sLastWord:sub(i + 1)
        break
      end
    end
  end

  if #tMatches == 0 then
    -- No matches — restore buffer, no visual change
    oFs.deviceControl(hStdin, "set_buffer", {sCurrentBuffer})

  elseif #tMatches == 1 then
    local sCompletion = tMatches[1]
    local sToAdd = sCompletion:sub(#sTypedPrefix + 1)
    if bIsCommand and sToAdd:sub(-1) ~= "/" then
      sToAdd = sToAdd .. " "
    end
    local sNewBuffer = sCurrentBuffer .. sToAdd
    if #sToAdd > 0 then
      io.write(sToAdd)
    end
    oFs.deviceControl(hStdin, "set_buffer", {sNewBuffer})

  else
    -- Multiple matches
    io.write("\n")
    for _, s in ipairs(tMatches) do
      io.write("\27[32m" .. s .. "\27[37m  ")
    end

    local sCommon = findCommonPrefix(tMatches)
    local sToAdd = ""
    if #sCommon > #sTypedPrefix then
      sToAdd = sCommon:sub(#sTypedPrefix + 1)
    end

    local sNewBuffer = sCurrentBuffer .. sToAdd
    io.write("\n" .. getPromptString() .. sNewBuffer)
    oFs.deviceControl(hStdin, "set_buffer", {sNewBuffer})
  end
end

local function handleHistoryUp(sCurrentBuffer)
  if #tHistory == 0 then
    oFs.deviceControl(hStdin, "set_buffer", {sCurrentBuffer})
    return
  end
  if nHistoryIdx < #tHistory then
    nHistoryIdx = nHistoryIdx + 1
  end
  local sLine = tHistory[#tHistory - nHistoryIdx + 1]
  replaceLine(sCurrentBuffer, sLine)
end

local function handleHistoryDown(sCurrentBuffer)
  if nHistoryIdx > 1 then
    nHistoryIdx = nHistoryIdx - 1
    local sLine = tHistory[#tHistory - nHistoryIdx + 1]
    replaceLine(sCurrentBuffer, sLine)
  elseif nHistoryIdx == 1 then
    nHistoryIdx = 0
    replaceLine(sCurrentBuffer, "")
  else
    oFs.deviceControl(hStdin, "set_buffer", {sCurrentBuffer})
  end
end

local function readLine()
  local sResult = oFs.read(hStdin)
  if not sResult then return nil end

  -- Check for special prefixes from TTY
  if sResult:sub(1, 1) == "\t" then
    -- Tab pressed
    handleTab(sResult:sub(2))
    return readLine() -- recurse to continue reading

  elseif sResult:sub(1, 3) == "\27[A" then
    -- Up arrow
    handleHistoryUp(sResult:sub(4))
    return readLine()

  elseif sResult:sub(1, 3) == "\27[B" then
    -- Down arrow
    handleHistoryDown(sResult:sub(4))
    return readLine()
  end

  -- Normal line (after Enter)
  nHistoryIdx = 0
  return sResult
end


local function parseRedirects(tArgs)
    -- Returns: cleaned args, output file path, append mode
    local tClean = {}
    local sOutFile = nil
    local bAppend = false
    local i = 1
    while i <= #tArgs do
        if tArgs[i] == ">>" then
            bAppend = true
            i = i + 1
            if i <= #tArgs then sOutFile = tArgs[i] end
        elseif tArgs[i] == ">" then
            bAppend = false
            i = i + 1
            if i <= #tArgs then sOutFile = tArgs[i] end
        elseif tArgs[i]:sub(-2) == ">>" then
            -- handle "file>>" edge case? no, keep it simple
            table.insert(tClean, tArgs[i])
        elseif tArgs[i]:sub(-1) == ">" then
            -- "echo>file" without space — not supported, treat as arg
            table.insert(tClean, tArgs[i])
        else
            table.insert(tClean, tArgs[i])
        end
        i = i + 1
    end
    -- resolve output path
    if sOutFile and sOutFile:sub(1,1) ~= "/" then
        sOutFile = ENV.PWD .. (ENV.PWD == "/" and "" or "/") .. sOutFile
        sOutFile = sOutFile:gsub("//", "/")
    end
    return tClean, sOutFile, bAppend
end

local function splitPipeline(tArgs)
    -- Split argument list on "|" tokens
    local tSegments = {}
    local tCurrent = {}
    for _, sToken in ipairs(tArgs) do
        if sToken == "|" then
            if #tCurrent > 0 then
                table.insert(tSegments, tCurrent)
            end
            tCurrent = {}
        else
            table.insert(tCurrent, sToken)
        end
    end
    if #tCurrent > 0 then
        table.insert(tSegments, tCurrent)
    end
    return tSegments
end


-- =============================================
-- PIPELINE & REDIRECTION HELPERS
-- =============================================

local function executeSimpleCommand(tArgs, sOutFile, bAppend)
    if #tArgs == 0 then return true end

    local cmd = tArgs[1]
    local cmdArgs = {}
    for i = 2, #tArgs do table.insert(cmdArgs, tArgs[i]) end

    if builtins[cmd] then
        return builtins[cmd](cmdArgs)
    end

    local execPath = findExecutable(cmd)
    if not execPath then
        oFs.write(hStderr, "sh: " .. cmd .. ": command not found\n")
        return true
    end

    local ring = syscall("process_get_ring")
    local myPid = syscall("process_get_pid")

    local tChildEnv = {
        ARGS = cmdArgs,
        PWD = ENV.PWD,
        PATH = ENV.PATH,
        USER = ENV.USER,
        HOME = ENV.HOME,
        HOSTNAME = ENV.HOSTNAME,
    }

    -- === REDIRECT: save/swap/restore ===
    local hRedirectFile = nil
    local sOrigStdout = nil

    if sOutFile then
        tChildEnv.NO_COLOR = "1"  -- strip ANSI in child output
        local sMode = bAppend and "a" or "w"
        hRedirectFile = oFs.open(sOutFile, sMode)
        if not hRedirectFile then
            oFs.write(hStderr, "sh: cannot open " .. sOutFile .. " for writing\n")
            return true
        end
        sOrigStdout = syscall("ob_get_standard_handle", myPid, -11)
        syscall("ob_set_standard_handle", myPid, -11, hRedirectFile._token)
    end

    local pid, err = syscall("process_spawn", execPath, ring, tChildEnv)

    -- restore immediately so shell's own output is normal
    if sOrigStdout then
        syscall("ob_set_standard_handle", myPid, -11, sOrigStdout)
    end

    if pid then
        syscall("process_wait", pid)
    else
        oFs.write(hStderr, "sh: " .. tostring(err) .. "\n")
    end

    if hRedirectFile then
        oFs.close(hRedirectFile)
    end

    return true
end

local function executePipeline(tSegments)
    local sPrevTempPath = nil
    local myPid = syscall("process_get_pid")

    for nStage = 1, #tSegments do
        local tStageArgs = tSegments[nStage]
        if #tStageArgs == 0 then goto pipe_continue end

        local cmd = tStageArgs[1]
        local cmdArgs = {}
        for i = 2, #tStageArgs do table.insert(cmdArgs, tStageArgs[i]) end

        local sOutFile, bAppend = nil, false
        if nStage == #tSegments then
            tStageArgs, sOutFile, bAppend = parseRedirects(tStageArgs)
            cmd = tStageArgs[1]
            cmdArgs = {}
            for i = 2, #tStageArgs do table.insert(cmdArgs, tStageArgs[i]) end
        end

        if builtins[cmd] then
            builtins[cmd](cmdArgs)
            goto pipe_continue
        end

        local execPath = findExecutable(cmd)
        if not execPath then
            oFs.write(hStderr, "sh: " .. cmd .. ": command not found\n")
            return true
        end

        local ring = syscall("process_get_ring")

        local sThisTempPath = nil
        if nStage < #tSegments then
            sThisTempPath = "/tmp/.pipe_" .. tostring(nStage) .. "_" .. tostring(math.random(10000, 99999))
        end

        local tChildEnv = {
            ARGS = cmdArgs,
            PWD = ENV.PWD,
            PATH = ENV.PATH,
            USER = ENV.USER,
            HOME = ENV.HOME,
            HOSTNAME = ENV.HOSTNAME,
        }

        -- strip ANSI if output goes to a temp file or redirect
        if sThisTempPath or sOutFile then
            tChildEnv.NO_COLOR = "1"
        end

        -- === SAVE current standard handles ===
        local sOrigStdout = syscall("ob_get_standard_handle", myPid, -11)
        local sOrigStdin  = syscall("ob_get_standard_handle", myPid, -10)

        -- === SWAP stdin if reading from previous stage ===
        local hPipeIn = nil
        if sPrevTempPath then
            hPipeIn = oFs.open(sPrevTempPath, "r")
            if hPipeIn then
                syscall("ob_set_standard_handle", myPid, -10, hPipeIn._token)
            end
        end

        -- === SWAP stdout for pipe output or file redirect ===
        local hOutFile = nil
        if sThisTempPath then
            hOutFile = oFs.open(sThisTempPath, "w")
            if hOutFile then
                syscall("ob_set_standard_handle", myPid, -11, hOutFile._token)
            end
        elseif sOutFile then
            local sMode = bAppend and "a" or "w"
            hOutFile = oFs.open(sOutFile, sMode)
            if hOutFile then
                syscall("ob_set_standard_handle", myPid, -11, hOutFile._token)
            end
        end

        -- === SPAWN (child inherits swapped handles) ===
        local pid, err = syscall("process_spawn", execPath, ring, tChildEnv)

        -- === RESTORE immediately ===
        if sOrigStdout then syscall("ob_set_standard_handle", myPid, -11, sOrigStdout) end
        if sOrigStdin  then syscall("ob_set_standard_handle", myPid, -10, sOrigStdin)  end

        if pid then
            syscall("process_wait", pid)
        else
            oFs.write(hStderr, "sh: " .. tostring(err) .. "\n")
        end

        -- cleanup handles
        if hOutFile then oFs.close(hOutFile) end
        if hPipeIn  then oFs.close(hPipeIn)  end

        -- === DELETE previous stage's temp file (we finished reading it) ===
        if sPrevTempPath then
            oFs.remove(sPrevTempPath)
        end

        sPrevTempPath = sThisTempPath
        ::pipe_continue::
    end

    -- cleanup last temp (edge case: last stage had piped input)
    if sPrevTempPath then
        oFs.remove(sPrevTempPath)
    end

    return true
end

-- =============================================
-- MAIN LOOP
-- =============================================


while true do
  io.write("\n" .. getPromptString())

  local line = readLine()
  if not line then break end

  -- Ctrl+C: discard and show new prompt
  if line == "\3" then
    oFs.write(hStdout, "^C\n")
    goto main_continue
  end

  -- Trim
  local sLine = line
  sLine = sLine:match("^%s*(.-)%s*$") or ""

  if #sLine > 0 then
    -- Add to history (skip duplicates of last entry)
    if #tHistory == 0 or tHistory[#tHistory] ~= sLine then
      table.insert(tHistory, sLine)
      if #tHistory > 100 then table.remove(tHistory, 1) end
    end

    local args = parseLine(sLine)
    if #args > 0 then

      -- Check for pipeline
      local tSegments = splitPipeline(args)

      if #tSegments > 1 then
        -- Multi-command pipeline
        executePipeline(tSegments)

      else
        -- Single command — check for redirects
        local tCleanArgs, sOutFile, bAppend = parseRedirects(args)

        if #tCleanArgs > 0 then
          local bContinue = executeSimpleCommand(tCleanArgs, sOutFile, bAppend)
          if not bContinue then break end
        end
      end

    end
  end

  ::main_continue::
end

oFs.close(hStdin)
oFs.close(hStdout)
```


axis-os\src\kernel\boot\boot.lua
```
local a,b,c=component,computer,unicode;local d,e;for f,g in a.list()do if g=="gpu"then d=a.proxy(f)end;if g=="screen"then e=f end end;if not d or not e then b.beep(1000,0.2)error("NO GPU")end;d.bind(e)local h,i=d.maxResolution()d.setResolution(h,i)local j,k=d.getResolution()local l={lvl="Info",safe="Disabled",wait="2",quick="Disabled",init="/bin/init.lua"}local m,n,o,p,q,r=0x0000AA,0xAA0000,0xFFFF00,0xFFFFFF,0xC0C0C0,0x000000;local function s(t,u)d.setBackground(t)d.setForeground(u)end;local function v(t)s(t,q)d.fill(1,1,j,k," ")end;local function w(x,g,u)if u then d.setForeground(u)end;d.set(math.floor((j-c.len(g))/2),x,g)end;local function y(z,x,A,B)local C=string.rep("=",A-2)d.set(z,x,"+"..C.."+")d.set(z,x+B-1,"+"..C.."+")for D=1,B-2 do d.set(z,x+D,"|")d.set(z+A-1,x+D,"|")end end;local function E(g)return b.pullSignal(g)end;local F={{l="Features",t="sub",i={{id="lvl",l="Log Level",o={"Debug","Info","Warn","Error"}},{id="safe",l="Safe Mode",o={"Enabled","Disabled"}}}},{l="Save & Exit",t="act",f=function()return true end},{l="Exit",t="act",f=function()b.shutdown(true)end}}local function G(H)local e,I=1,H.i;local A,B=math.floor(j*0.8),#I+4;local J,K=math.floor((j-A)/2),math.floor((k-B)/2)while true do s(m,q)d.fill(J,K,A,B," ")y(J,K,A,B)s(q,r)d.set(J+2,K," "..H.l.." ")for D,L in ipairs(I)do local x,M=K+1+D,l[L.id]if L.v then M=L.v end;if not M then M=""end;local N=A-4-c.len(L.l)-c.len(M)local O=" "..L.l..string.rep(" ",N)..M.." "if D==e then s(n,p)else s(m,q)end;d.set(J+2,x,O)end;local P,Q,R,S=E()if P=="key_down"then if S==1 or S==14 then return elseif S==200 and e>1 then e=e-1 elseif S==208 and e<#I then e=e+1 elseif S==28 then local L=I[e]if L.o then local T=1;for U,z in ipairs(L.o)do if z==l[L.id]then T=U end end;T=T+1;if T>#L.o then T=1 end;l[L.id]=L.o[T]elseif L.t=="inp"then s(n,p)local V,W=30,3;local X,Y=math.floor((j-V)/2),math.floor((k-W)/2)d.fill(X,Y,V,W," ")y(X,Y,V,W)local Z=""while true do d.set(X+2,Y+1,Z.."_  ")local _,Q,a0,a1=E()if _=="key_down"then if a1==28 then l[L.id]=Z;break elseif a1==14 then Z=c.sub(Z,1,-2)elseif a0>32 and a0<127 and c.len(Z)<V-4 then Z=Z..c.char(a0)end end end end end end end end;local function a2()local e,i=1,k-6;while true do v(m)s(q,r)d.fill(1,1,j,1," ")w(1,"AXIS BIOS SETUP")s(m,p)y(2,3,j-4,i)y(2,k-3,j-4,4)s(m,o)d.set(4,k-2,"Esc:Quit  ARROWS:Select  Enter:Open  F10:Save")for D,H in ipairs(F)do local z,x,A=4,3+D,j-8;local a3=H.l;if H.t=="sub"then a3="> "..a3 end;if D==e then s(n,p)a3=a3 ..string.rep(" ",A-c.len(a3))else s(m,o)end;d.set(z,x,a3)end;local P,Q,Q,S=E()if P=="key_down"then if S==200 then e=e-1;if e<1 then e=#F end elseif S==208 then e=e+1;if e>#F then e=1 end elseif S==1 then return elseif S==68 or S==28 then local H=F[e]if H.t=="sub"then G(H)elseif H.t=="act"then if H.f()then return end end end end end end;local a4={"    _        _      ___  ____  ","   / \\  __ _(_)___ / _ \\/ ___| ","  / _ \\ \\ \\/ / / __| | | \\___ \\ "," / ___ \\ >  <| \\__ \\ |_| |___) |","/_/   \\_/_/\\_\\_|___/\\___/|____/ "}local function a5()v(r)s(r,p)d.set(1,1,"AxisBIOS v0.4")d.set(1,2,"(C) 2025 Axis Corp")d.set(1,4,"Xen XKA")b.beep(1100,0.1)s(r,q)local a6=math.floor(k/3)for D,a7 in ipairs(a4)do w(a6+D,a7)end;s(r,p)w(k-2,"Press DEL to enter SETUP",q)local a8=tonumber(l.wait)or 2;if l.quick=="Enabled"then a8=0.1 end;local g=b.uptime()+a8;while b.uptime()<g do local e,Q,Q,S=b.pullSignal(0.1)if e=="key_down"and S==211 then return"S"end end end;if a5()=="S"then b.beep(1000,0.1)a2()a5()end;local a9;for f in a.list("filesystem")do if a.proxy(f).exists("/kernel.lua")then a9=f;break end end;if not a9 then v(r)d.set(1,1,"NO SYSTEM DISK")while true do b.pullSignal()end end;v(r)d.set(1,1,"booting")local N=a.proxy(a9)local aa=N.open("/kernel.lua","r")b.beep(900,0.2)local R=""while true do local a8=N.read(aa,math.huge)if not a8 then break end;R=R..a8 end;N.close(aa)if R:sub(1,3)=="\239\187\191"then R=R:sub(4)end;local ab={raw_component=a,raw_computer=b,boot_fs_address=a9,boot_args=l}setmetatable(ab,{__index=_G})local u,P=load(R,"=kernel","t",ab)if not u then error(P)end;u()
```


axis-os\src\kernel\boot\eeprom_axfs.lua
```
-- AxisOS AXFS Bootloader (no SecureBoot)
-- Boots kernel.lua from first AXFS partition on first unmanaged drive.
-- Falls back to managed filesystem if no drive found.

local c = component
local cp = computer

local gpu_addr = c.list("gpu")()
local scr_addr = c.list("screen")()
local drv_addr = c.list("drive")()
local fs_addr  = c.list("filesystem")()

local W, H = 80, 25
local g
if gpu_addr and scr_addr then
  g = c.proxy(gpu_addr)
  g.bind(scr_addr)
  W, H = g.getResolution()
  g.setBackground(0x000000); g.setForeground(0xFFFFFF)
  g.fill(1, 1, W, H, " ")
end

local y = 1
local function p(s, col)
  if not g then return end
  g.setForeground(col or 0xFFFFFF)
  g.set(2, y, tostring(s)); y = y + 1
end

local function halt(reason)
  p("", 0)
  p("BOOT FAILURE: " .. tostring(reason), 0xFF5555)
  p("System halted.", 0xAAAAAA)
  cp.beep(200, 1)
  while true do cp.pullSignal(math.huge) end
end

local function r16(s,o) return s:byte(o)*256+s:byte(o+1) end
local function r32(s,o) return s:byte(o)*16777216+s:byte(o+1)*65536+s:byte(o+2)*256+s:byte(o+3) end
local function rstr(s,o,n) local r=s:sub(o,o+n-1); local z=r:find("\0",1,true); return z and r:sub(1,z-1) or r end

p("AxisOS Boot", 0x00BCD4)

-- =============================================
-- TRY AXFS ON UNMANAGED DRIVE
-- =============================================

local boot_mode = nil
local drv, ss, pOff, pCnt
local oFs, readfile

if drv_addr then
  drv = c.proxy(drv_addr)
  ss = drv.getSectorSize()

  local h0 = drv.readSector(1)  -- sector 0
  if h0 and h0:sub(1,4) == "AXRD" then
    local nP = h0:byte(12)
    for i = 1, nP do
      local ps = drv.readSector(i + 1)
      if ps and ps:sub(1,4) == "AXPT" and rstr(ps,22,8) == "axfs" then
        pOff = r32(ps, 30); pCnt = r32(ps, 34)
        break
      end
    end
  end
end

if pOff then
  boot_mode = "axfs"
  p("AXFS at sector " .. pOff, 0x55FF55)

  local function prs(n) return drv.readSector(pOff + n + 1) end
  local sb = prs(0)
  if not sb or sb:sub(1,4) ~= "AXFS" then halt("Bad AXFS superblock") end
  local nDS = r16(sb, 20)
  local ips = math.floor(ss / 64)

  local function ri(n)
    local sec=3+math.floor(n/ips); local off=(n%ips)*64
    local sd=prs(sec); if not sd then return nil end; local o=off+1
    local t={iType=r16(sd,o),size=r32(sd,o+8),nBlk=r16(sd,o+22),dir={},ind=r16(sd,o+44)}
    for i=1,10 do t.dir[i]=r16(sd,o+24+(i-1)*2) end; return t
  end
  local function rb(n) return prs(nDS+n) end
  local function blks(t)
    local r={}
    for i=1,math.min(10,t.nBlk) do if t.dir[i] and t.dir[i]>0 then r[#r+1]=t.dir[i] end end
    if t.nBlk>10 and t.ind>0 then
      local si=rb(t.ind); if si then
        for i=1,math.floor(ss/2) do local p2=r16(si,(i-1)*2+1); if p2>0 then r[#r+1]=p2 end end
      end
    end; return r
  end
  local function dfind(di,nm)
    local dpb=math.floor(ss/32)
    for _,bn in ipairs(blks(di)) do
      local sd=rb(bn); if sd then
        for i=0,dpb-1 do local o=i*32+1; local ino=r16(sd,o)
          if ino>0 then local nl=sd:byte(o+3); if sd:sub(o+4,o+3+nl)==nm then return ino end end
        end
      end
    end
  end
  local function resolve(path)
    local cur=1
    for seg in path:gmatch("[^/]+") do
      local t=ri(cur); if not t or t.iType~=2 then return nil end
      cur=dfind(t,seg); if not cur then return nil end
    end; return cur
  end

  readfile = function(path)
    local n=resolve(path); if not n then return nil end
    local t=ri(n); if not t or t.iType~=1 then return nil end
    local ch={}; local rem=t.size
    for _,bn in ipairs(blks(t)) do
      local sd=rb(bn); if sd then ch[#ch+1]=sd:sub(1,math.min(rem,ss)); rem=rem-ss end
      if rem<=0 then break end
    end; return table.concat(ch)
  end

elseif fs_addr then
  boot_mode = "managed"
  oFs = c.proxy(fs_addr)
  p("Managed FS boot", 0xFFAA00)

  readfile = function(path)
    local h = oFs.open(path, "r")
    if not h then return nil end
    local ch = {}
    while true do local s = oFs.read(h, 8192); if not s then break end; ch[#ch+1] = s end
    oFs.close(h)
    return table.concat(ch)
  end

else
  halt("No bootable device")
end

-- =============================================
-- LOAD KERNEL
-- =============================================

p("Loading kernel...", 0xAAAAAA)
local kcode = readfile("/kernel.lua")
if not kcode or #kcode < 100 then halt("/kernel.lua not found or empty") end
p("Kernel: " .. #kcode .. " bytes", 0x55FF55)

-- Pass boot info
if boot_mode == "axfs" then
  _G.boot_fs_type = "axfs"
  _G.boot_drive_addr = drv_addr
  _G.boot_part_offset = pOff
  _G.boot_part_size = pCnt
  _G.boot_fs_address = drv_addr
else
  _G.boot_fs_type = "managed"
  _G.boot_fs_address = fs_addr
end
_G.boot_args = {}
_G.boot_security = nil  -- no security checks

cp.pullSignal(0.1)

local fn, err = load(kcode, "=kernel", "t", _G)
if not fn then halt("PARSE: " .. tostring(err)) end

local ok, err2 = xpcall(fn, debug.traceback)
if not ok then halt("PANIC: " .. tostring(err2)) end
```


axis-os\src\kernel\boot\eeprom_secureboot_axfs.lua
```
-- AxisOS Secure Boot + AXFS Bootloader
-- Verifies machine binding, kernel hash, manifest — then boots from AXFS.
-- Fits in 4KB EEPROM.

local PK_FINGERPRINT = "%%PK_FP%%"
local EXPECTED_KERNEL_HASH = "%%KERN_H%%"
local MACHINE_BINDING = "%%MACH_B%%"
local MANIFEST_HASH = "%%MANIF_H%%"

local c = component
local cp = computer

-- Component discovery
local gpu_addr = c.list("gpu")()
local scr_addr = c.list("screen")()
local eeprom   = c.list("eeprom")()
local data_addr= c.list("data")()
local drv_addr = c.list("drive")()
local fs_addr  = c.list("filesystem")()  -- fallback

local W, H = 80, 25
local g
if gpu_addr and scr_addr then
  g = c.proxy(gpu_addr)
  g.bind(scr_addr)
  W, H = g.getResolution()
  g.setBackground(0x000000); g.setForeground(0xFFFFFF)
  g.fill(1, 1, W, H, " ")
end

local y = 1
local function p(s, col)
  if not g then return end
  g.setForeground(col or 0xFFFFFF)
  g.set(2, y, tostring(s)); y = y + 1
end

local function halt(reason)
  if g then
    g.setForeground(0xFF0000); g.set(2, H-2, "SECURE BOOT FAILURE")
    g.setForeground(0xFF5555); g.set(2, H-1, tostring(reason):sub(1, W-4))
    g.setForeground(0xAAAAAA); g.set(2, H, "System halted.")
  end
  cp.beep(200, 2)
  while true do cp.pullSignal(math.huge) end
end

local function hex(s)
  local t = {}
  for i = 1, #s do t[i] = string.format("%02x", s:byte(i)) end
  return table.concat(t)
end

-- Binary helpers
local function r16(s,o) return s:byte(o)*256+s:byte(o+1) end
local function r32(s,o) return s:byte(o)*16777216+s:byte(o+1)*65536+s:byte(o+2)*256+s:byte(o+3) end
local function rstr(s,o,n) local r=s:sub(o,o+n-1); local z=r:find("\0",1,true); return z and r:sub(1,z-1) or r end

-- =============================================
-- HEADER
-- =============================================

p("AxisOS Secure Boot + AXFS v1.0", 0x00BCD4)
p(string.rep("=", 40), 0x333333)
p("")

-- =============================================
-- [0/5] EEPROM INTEGRITY
-- =============================================

p("[0/5] Verifying boot ROM integrity...", 0xAAAAAA)
local eep = c.proxy(eeprom)
local stored_data = eep.getData()
if not stored_data or #stored_data < 64 then
  halt("EEPROM data area corrupt or empty")
end

-- =============================================
-- [1/5] MACHINE BINDING
-- =============================================

p("[1/5] Validating machine binding...", 0xAAAAAA)

if not data_addr then
  halt("NO DATA CARD: Cannot verify")
end
local data = c.proxy(data_addr)

local machine_id = data.sha256(
  data_addr .. eeprom .. (drv_addr or fs_addr or "NO_DEV")
)
local current_binding = hex(machine_id)

if MACHINE_BINDING ~= "%%MACH_B%%" then
  if current_binding ~= MACHINE_BINDING then
    halt("MACHINE BINDING MISMATCH: " ..
         current_binding:sub(1,16) .. " != " .. MACHINE_BINDING:sub(1,16))
  end
  p("[1/5] Machine binding: VERIFIED", 0x00FF00)
else
  p("[1/5] Machine binding: FIRST BOOT (unbound)", 0xFFAA00)
end

-- =============================================
-- [2/5] LOCATE BOOT DEVICE
-- =============================================

p("[2/5] Locating boot device...", 0xAAAAAA)

-- Try AXFS on unmanaged drive first, fall back to managed FS
local boot_mode   -- "axfs" or "managed"
local drv, ss, pOff, pCnt
local oFs

if drv_addr then
  drv = c.proxy(drv_addr)
  ss = drv.getSectorSize()
  local function rs(n) return drv.readSector(n + 1) end

  local h0 = rs(0)
  if h0 and h0:sub(1,4) == "AXRD" then
    local nParts = h0:byte(12)
    for i = 1, nParts do
      local ps = rs(i)
      if ps and ps:sub(1,4) == "AXPT" and rstr(ps,22,8) == "axfs" then
        pOff = r32(ps, 30); pCnt = r32(ps, 34)
        break
      end
    end
  end
end

if pOff then
  boot_mode = "axfs"
  p("[2/5] AXFS partition found at sector " .. pOff, 0x00FF00)
elseif fs_addr then
  boot_mode = "managed"
  oFs = c.proxy(fs_addr)
  p("[2/5] Falling back to managed filesystem", 0xFFAA00)
else
  halt("NO BOOTABLE DEVICE FOUND")
end

-- =============================================
-- AXFS READER (inline, no requires)
-- =============================================

local readfile  -- forward declaration

if boot_mode == "axfs" then
  local function prs(n) return drv.readSector(pOff + n + 1) end
  local sb = prs(0)
  if not sb or sb:sub(1,4) ~= "AXFS" then halt("Bad AXFS superblock") end
  local nDS = r16(sb, 20)
  local ips = math.floor(ss / 64)

  local function ri(n)
    local sec=3+math.floor(n/ips); local off=(n%ips)*64
    local sd=prs(sec); if not sd then return nil end; local o=off+1
    local t={iType=r16(sd,o),size=r32(sd,o+8),nBlk=r16(sd,o+22),dir={},ind=r16(sd,o+44)}
    for i=1,10 do t.dir[i]=r16(sd,o+24+(i-1)*2) end; return t
  end
  local function rb(n) return prs(nDS+n) end
  local function blks(t)
    local r={}
    for i=1,math.min(10,t.nBlk) do if t.dir[i] and t.dir[i]>0 then r[#r+1]=t.dir[i] end end
    if t.nBlk>10 and t.ind>0 then
      local si=rb(t.ind); if si then
        for i=1,math.floor(ss/2) do local p2=r16(si,(i-1)*2+1); if p2>0 then r[#r+1]=p2 end end
      end
    end; return r
  end
  local function dfind(di,nm)
    local dpb=math.floor(ss/32)
    for _,bn in ipairs(blks(di)) do
      local sd=rb(bn); if sd then
        for i=0,dpb-1 do local o=i*32+1; local ino=r16(sd,o)
          if ino>0 then local nl=sd:byte(o+3); if sd:sub(o+4,o+3+nl)==nm then return ino end end
        end
      end
    end
  end
  local function resolve(path)
    local cur=1
    for seg in path:gmatch("[^/]+") do
      local t=ri(cur); if not t or t.iType~=2 then return nil end
      cur=dfind(t,seg); if not cur then return nil end
    end; return cur
  end

  readfile = function(path)
    local n=resolve(path); if not n then return nil end
    local t=ri(n); if not t or t.iType~=1 then return nil end
    local ch={}; local rem=t.size
    for _,bn in ipairs(blks(t)) do
      local sd=rb(bn); if sd then ch[#ch+1]=sd:sub(1,math.min(rem,ss)); rem=rem-ss end
      if rem<=0 then break end
    end; return table.concat(ch)
  end

else
  -- Managed FS reader
  readfile = function(path)
    local h = oFs.open(path, "r")
    if not h then return nil end
    local ch = {}
    while true do
      local s = oFs.read(h, 8192); if not s then break end; ch[#ch+1] = s
    end
    oFs.close(h)
    return table.concat(ch)
  end
end

-- =============================================
-- [3/5] KERNEL INTEGRITY
-- =============================================

p("[3/5] Measuring kernel...", 0xAAAAAA)

local kernel_code = readfile("/kernel.lua")
if not kernel_code or #kernel_code < 100 then
  halt("KERNEL NOT FOUND or corrupt")
end

local kernel_hash = hex(data.sha256(kernel_code))

if EXPECTED_KERNEL_HASH ~= "%%KERN_H%%" then
  if kernel_hash ~= EXPECTED_KERNEL_HASH then
    halt("KERNEL HASH MISMATCH: " ..
         kernel_hash:sub(1,16) .. " != " .. EXPECTED_KERNEL_HASH:sub(1,16))
  end
  p("[3/5] Kernel integrity: VERIFIED (" .. kernel_hash:sub(1,8) .. "...)", 0x00FF00)
else
  p("[3/5] Kernel hash: " .. kernel_hash:sub(1,16) .. " (unverified)", 0xFFAA00)
end

-- =============================================
-- [4/5] BOOT MANIFEST
-- =============================================

p("[4/5] Checking boot manifest...", 0xAAAAAA)

local mdata = readfile("/boot/manifest.sig")
if mdata then
  local manifest_hash = hex(data.sha256(mdata))
  if MANIFEST_HASH ~= "%%MANIF_H%%" and manifest_hash ~= MANIFEST_HASH then
    halt("BOOT MANIFEST TAMPERED")
  end
  p("[4/5] Boot manifest: PRESENT", 0x00FF00)
else
  if MANIFEST_HASH ~= "%%MANIF_H%%" then
    halt("BOOT MANIFEST MISSING (required by policy)")
  end
  p("[4/5] Boot manifest: NOT PRESENT (warning)", 0xFFAA00)
end

-- =============================================
-- [5/5] LAUNCH KERNEL
-- =============================================

p("[5/5] Loading verified kernel...", 0x00BCD4)
p("")
p("Trust chain: EEPROM -> kernel -> PM -> drivers", 0x555555)

_G.boot_security = {
  machine_binding = current_binding,
  kernel_hash = kernel_hash,
  data_card_addr = data_addr,
  pk_fingerprint = PK_FINGERPRINT,
  verified = (EXPECTED_KERNEL_HASH ~= "%%KERN_H%%"),
  sealed = (MACHINE_BINDING ~= "%%MACH_B%%"),
}

if boot_mode == "axfs" then
  _G.boot_fs_type = "axfs"
  _G.boot_drive_addr = drv_addr
  _G.boot_part_offset = pOff
  _G.boot_part_size = pCnt
  _G.boot_fs_address = drv_addr
else
  _G.boot_fs_type = "managed"
  _G.boot_fs_address = fs_addr
end
_G.boot_args = {}

cp.pullSignal(0.1)

local fn, err = load(kernel_code, "=kernel", "t", _G)
if not fn then halt("KERNEL PARSE: " .. tostring(err)) end

local ok, err2 = xpcall(fn, debug.traceback)
if not ok then halt("KERNEL PANIC: " .. tostring(err2)) end
```


axis-os\src\kernel\boot\eeprom_template.lua
```
-- AxisOS Secure Boot + AXFS Bootloader
-- Verifies machine binding, kernel hash, manifest — then boots from AXFS.
-- Fits in 4KB EEPROM.

local PK_FINGERPRINT = "%%PK_FP%%"
local EXPECTED_KERNEL_HASH = "%%KERN_H%%"
local MACHINE_BINDING = "%%MACH_B%%"
local MANIFEST_HASH = "%%MANIF_H%%"

local c = component
local cp = computer

-- Component discovery
local gpu_addr = c.list("gpu")()
local scr_addr = c.list("screen")()
local eeprom   = c.list("eeprom")()
local data_addr= c.list("data")()
local drv_addr = c.list("drive")()
local fs_addr  = c.list("filesystem")()  -- fallback

local W, H = 80, 25
local g
if gpu_addr and scr_addr then
  g = c.proxy(gpu_addr)
  g.bind(scr_addr)
  W, H = g.getResolution()
  g.setBackground(0x000000); g.setForeground(0xFFFFFF)
  g.fill(1, 1, W, H, " ")
end

local y = 1
local function p(s, col)
  if not g then return end
  g.setForeground(col or 0xFFFFFF)
  g.set(2, y, tostring(s)); y = y + 1
end

local function halt(reason)
  if g then
    g.setForeground(0xFF0000); g.set(2, H-2, "SECURE BOOT FAILURE")
    g.setForeground(0xFF5555); g.set(2, H-1, tostring(reason):sub(1, W-4))
    g.setForeground(0xAAAAAA); g.set(2, H, "System halted.")
  end
  cp.beep(200, 2)
  while true do cp.pullSignal(math.huge) end
end

local function hex(s)
  local t = {}
  for i = 1, #s do t[i] = string.format("%02x", s:byte(i)) end
  return table.concat(t)
end

-- Binary helpers
local function r16(s,o) return s:byte(o)*256+s:byte(o+1) end
local function r32(s,o) return s:byte(o)*16777216+s:byte(o+1)*65536+s:byte(o+2)*256+s:byte(o+3) end
local function rstr(s,o,n) local r=s:sub(o,o+n-1); local z=r:find("\0",1,true); return z and r:sub(1,z-1) or r end

-- =============================================
-- HEADER
-- =============================================

p("AxisOS Secure Boot + AXFS v1.0", 0x00BCD4)
p(string.rep("=", 40), 0x333333)
p("")

-- =============================================
-- [0/5] EEPROM INTEGRITY
-- =============================================

p("[0/5] Verifying boot ROM integrity...", 0xAAAAAA)
local eep = c.proxy(eeprom)
local stored_data = eep.getData()
if not stored_data or #stored_data < 64 then
  halt("EEPROM data area corrupt or empty")
end

-- =============================================
-- [1/5] MACHINE BINDING
-- =============================================

p("[1/5] Validating machine binding...", 0xAAAAAA)

if not data_addr then
  halt("NO DATA CARD: Cannot verify")
end
local data = c.proxy(data_addr)

local machine_id = data.sha256(
  data_addr .. eeprom .. (drv_addr or fs_addr or "NO_DEV")
)
local current_binding = hex(machine_id)

if MACHINE_BINDING ~= "%%MACH_B%%" then
  if current_binding ~= MACHINE_BINDING then
    halt("MACHINE BINDING MISMATCH: " ..
         current_binding:sub(1,16) .. " != " .. MACHINE_BINDING:sub(1,16))
  end
  p("[1/5] Machine binding: VERIFIED", 0x00FF00)
else
  p("[1/5] Machine binding: FIRST BOOT (unbound)", 0xFFAA00)
end

-- =============================================
-- [2/5] LOCATE BOOT DEVICE
-- =============================================

p("[2/5] Locating boot device...", 0xAAAAAA)

-- Try AXFS on unmanaged drive first, fall back to managed FS
local boot_mode   -- "axfs" or "managed"
local drv, ss, pOff, pCnt
local oFs

if drv_addr then
  drv = c.proxy(drv_addr)
  ss = drv.getSectorSize()
  local function rs(n) return drv.readSector(n + 1) end

  local h0 = rs(0)
  if h0 and h0:sub(1,4) == "AXRD" then
    local nParts = h0:byte(12)
    for i = 1, nParts do
      local ps = rs(i)
      if ps and ps:sub(1,4) == "AXPT" and rstr(ps,22,8) == "axfs" then
        pOff = r32(ps, 30); pCnt = r32(ps, 34)
        break
      end
    end
  end
end

if pOff then
  boot_mode = "axfs"
  p("[2/5] AXFS partition found at sector " .. pOff, 0x00FF00)
elseif fs_addr then
  boot_mode = "managed"
  oFs = c.proxy(fs_addr)
  p("[2/5] Falling back to managed filesystem", 0xFFAA00)
else
  halt("NO BOOTABLE DEVICE FOUND")
end

-- =============================================
-- AXFS READER (inline, no requires)
-- =============================================

local readfile  -- forward declaration

if boot_mode == "axfs" then
  local function prs(n) return drv.readSector(pOff + n + 1) end
  local sb = prs(0)
  if not sb or sb:sub(1,4) ~= "AXFS" then halt("Bad AXFS superblock") end
  local nDS = r16(sb, 20)
  local ips = math.floor(ss / 64)

  local function ri(n)
    local sec=3+math.floor(n/ips); local off=(n%ips)*64
    local sd=prs(sec); if not sd then return nil end; local o=off+1
    local t={iType=r16(sd,o),size=r32(sd,o+8),nBlk=r16(sd,o+22),dir={},ind=r16(sd,o+44)}
    for i=1,10 do t.dir[i]=r16(sd,o+24+(i-1)*2) end; return t
  end
  local function rb(n) return prs(nDS+n) end
  local function blks(t)
    local r={}
    for i=1,math.min(10,t.nBlk) do if t.dir[i] and t.dir[i]>0 then r[#r+1]=t.dir[i] end end
    if t.nBlk>10 and t.ind>0 then
      local si=rb(t.ind); if si then
        for i=1,math.floor(ss/2) do local p2=r16(si,(i-1)*2+1); if p2>0 then r[#r+1]=p2 end end
      end
    end; return r
  end
  local function dfind(di,nm)
    local dpb=math.floor(ss/32)
    for _,bn in ipairs(blks(di)) do
      local sd=rb(bn); if sd then
        for i=0,dpb-1 do local o=i*32+1; local ino=r16(sd,o)
          if ino>0 then local nl=sd:byte(o+3); if sd:sub(o+4,o+3+nl)==nm then return ino end end
        end
      end
    end
  end
  local function resolve(path)
    local cur=1
    for seg in path:gmatch("[^/]+") do
      local t=ri(cur); if not t or t.iType~=2 then return nil end
      cur=dfind(t,seg); if not cur then return nil end
    end; return cur
  end

  readfile = function(path)
    local n=resolve(path); if not n then return nil end
    local t=ri(n); if not t or t.iType~=1 then return nil end
    local ch={}; local rem=t.size
    for _,bn in ipairs(blks(t)) do
      local sd=rb(bn); if sd then ch[#ch+1]=sd:sub(1,math.min(rem,ss)); rem=rem-ss end
      if rem<=0 then break end
    end; return table.concat(ch)
  end

else
  -- Managed FS reader
  readfile = function(path)
    local h = oFs.open(path, "r")
    if not h then return nil end
    local ch = {}
    while true do
      local s = oFs.read(h, 8192); if not s then break end; ch[#ch+1] = s
    end
    oFs.close(h)
    return table.concat(ch)
  end
end

-- =============================================
-- [3/5] KERNEL INTEGRITY
-- =============================================

p("[3/5] Measuring kernel...", 0xAAAAAA)

local kernel_code = readfile("/kernel.lua")
if not kernel_code or #kernel_code < 100 then
  halt("KERNEL NOT FOUND or corrupt")
end

local kernel_hash = hex(data.sha256(kernel_code))

if EXPECTED_KERNEL_HASH ~= "%%KERN_H%%" then
  if kernel_hash ~= EXPECTED_KERNEL_HASH then
    halt("KERNEL HASH MISMATCH: " ..
         kernel_hash:sub(1,16) .. " != " .. EXPECTED_KERNEL_HASH:sub(1,16))
  end
  p("[3/5] Kernel integrity: VERIFIED (" .. kernel_hash:sub(1,8) .. "...)", 0x00FF00)
else
  p("[3/5] Kernel hash: " .. kernel_hash:sub(1,16) .. " (unverified)", 0xFFAA00)
end

-- =============================================
-- [4/5] BOOT MANIFEST
-- =============================================

p("[4/5] Checking boot manifest...", 0xAAAAAA)

local mdata = readfile("/boot/manifest.sig")
if mdata then
  local manifest_hash = hex(data.sha256(mdata))
  if MANIFEST_HASH ~= "%%MANIF_H%%" and manifest_hash ~= MANIFEST_HASH then
    halt("BOOT MANIFEST TAMPERED")
  end
  p("[4/5] Boot manifest: PRESENT", 0x00FF00)
else
  if MANIFEST_HASH ~= "%%MANIF_H%%" then
    halt("BOOT MANIFEST MISSING (required by policy)")
  end
  p("[4/5] Boot manifest: NOT PRESENT (warning)", 0xFFAA00)
end

-- =============================================
-- [5/5] LAUNCH KERNEL
-- =============================================

p("[5/5] Loading verified kernel...", 0x00BCD4)
p("")
p("Trust chain: EEPROM -> kernel -> PM -> drivers", 0x555555)

_G.boot_security = {
  machine_binding = current_binding,
  kernel_hash = kernel_hash,
  data_card_addr = data_addr,
  pk_fingerprint = PK_FINGERPRINT,
  verified = (EXPECTED_KERNEL_HASH ~= "%%KERN_H%%"),
  sealed = (MACHINE_BINDING ~= "%%MACH_B%%"),
}

if boot_mode == "axfs" then
  _G.boot_fs_type = "axfs"
  _G.boot_drive_addr = drv_addr
  _G.boot_part_offset = pOff
  _G.boot_part_size = pCnt
  _G.boot_fs_address = drv_addr
else
  _G.boot_fs_type = "managed"
  _G.boot_fs_address = fs_addr
end
_G.boot_args = {}

cp.pullSignal(0.1)

local fn, err = load(kernel_code, "=kernel", "t", _G)
if not fn then halt("KERNEL PARSE: " .. tostring(err)) end

local ok, err2 = xpcall(fn, debug.traceback)
if not ok then halt("KERNEL PANIC: " .. tostring(err2)) end
```


axis-os\src\kernel\drivers\blkdev.sys.lua
```
--
-- /drivers/blkdev.sys.lua
-- CMD driver for unmanaged OC 'drive' components
--
local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = {
  sDriverName = "AxisBlockDev",
  sDriverType = tDKStructs.DRIVER_TYPE_CMD,
  nLoadPriority = 300,
  sVersion = "1.0.0",
  sSupportedComponent = "drive",
}

local g_pDev = nil
local g_oProxy = nil

local function fCreate(d,i) oKMD.DkCompleteRequest(i, tStatus.STATUS_SUCCESS) end
local function fClose(d,i) oKMD.DkCompleteRequest(i, tStatus.STATUS_SUCCESS) end

local function fCtl(d, i)
  local m = i.tParameters.sMethod
  local a = i.tParameters.tArgs or {}
  if not g_oProxy then oKMD.DkCompleteRequest(i, tStatus.STATUS_DEVICE_NOT_READY); return end

  if m == "info" then
    local ss = g_oProxy.getSectorSize()
    oKMD.DkCompleteRequest(i, tStatus.STATUS_SUCCESS, {
      sectorSize = ss,
      capacity = g_oProxy.getCapacity(),
      platters = g_oProxy.getPlatterCount(),
      sectorCount = math.floor(g_oProxy.getCapacity() / ss),
    })
  elseif m == "read_sector" then
    local n = a[1]; if not n then oKMD.DkCompleteRequest(i, tStatus.STATUS_INVALID_PARAMETER); return end
    local ok, d2 = pcall(g_oProxy.readSector, n)
    if ok then oKMD.DkCompleteRequest(i, tStatus.STATUS_SUCCESS, d2)
    else oKMD.DkCompleteRequest(i, tStatus.STATUS_UNSUCCESSFUL, d2) end
  elseif m == "write_sector" then
    local n, sd = a[1], a[2]
    if not n or not sd then oKMD.DkCompleteRequest(i, tStatus.STATUS_INVALID_PARAMETER); return end
    local ok, e = pcall(g_oProxy.writeSector, n, sd)
    if ok then oKMD.DkCompleteRequest(i, tStatus.STATUS_SUCCESS)
    else oKMD.DkCompleteRequest(i, tStatus.STATUS_UNSUCCESSFUL, e) end
  elseif m == "batch_read" then
    local t = a[1]; if not t then oKMD.DkCompleteRequest(i, tStatus.STATUS_INVALID_PARAMETER); return end
    local r = {}; for _, n in ipairs(t) do
      local ok, d2 = pcall(g_oProxy.readSector, n); r[#r+1] = ok and d2 or false
    end
    oKMD.DkCompleteRequest(i, tStatus.STATUS_SUCCESS, r)
  elseif m == "batch_write" then
    local t = a[1]; if not t then oKMD.DkCompleteRequest(i, tStatus.STATUS_INVALID_PARAMETER); return end
    local n = 0; for _, op in ipairs(t) do
      if pcall(g_oProxy.writeSector, op[1], op[2]) then n = n + 1 end
    end
    oKMD.DkCompleteRequest(i, tStatus.STATUS_SUCCESS, n)
  else
    oKMD.DkCompleteRequest(i, tStatus.STATUS_NOT_IMPLEMENTED)
  end
end

function DriverEntry(pDO)
  oKMD.DkPrint("AxisBlockDev: Init")
  pDO.tDispatch[tDKStructs.IRP_MJ_CREATE] = fCreate
  pDO.tDispatch[tDKStructs.IRP_MJ_CLOSE] = fClose
  pDO.tDispatch[tDKStructs.IRP_MJ_DEVICE_CONTROL] = fCtl
  local st, dev = oKMD.DkCreateComponentDevice(pDO, "drive")
  if st ~= tStatus.STATUS_SUCCESS then return st end
  g_pDev = dev
  local addr = env.address
  local ps, p = oKMD.DkGetHardwareProxy(addr)
  if ps ~= tStatus.STATUS_SUCCESS then return ps end
  g_oProxy = p
  local ss = p.getSectorSize(); local cap = p.getCapacity()
  oKMD.DkPrint(string.format("AxisBlockDev: %dKB, %d-byte sectors", cap/1024, ss))
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDO)
  if g_pDev and g_pDev.pDeviceExtension.sAutoSymlink then
    oKMD.DkDeleteSymbolicLink(g_pDev.pDeviceExtension.sAutoSymlink)
  end
  oKMD.DkDeleteDevice(g_pDev); return tStatus.STATUS_SUCCESS
end

while true do
  local b, pid, sig, p1, p2 = syscall("signal_pull")
  if b then
    if sig == "driver_init" then
      p1.fDriverUnload = DriverUnload
      local st = DriverEntry(p1)
      syscall("signal_send", pid, "driver_init_complete", st, p1)
    elseif sig == "irp_dispatch" then
      p2(g_pDev, p1)
    end
  end
end
```


axis-os\src\kernel\drivers\computer.sys.lua
```
-- /drivers/computer.sys.lua - Stub Driver
local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = { sDriverName = "AxisComputerStub", sDriverType = tDKStructs.DRIVER_TYPE_KMD, nLoadPriority = 500 }

function DriverEntry(pDriverObject)
  oKMD.DkPrint("Computer Stub Driver loaded. Exposes... the computer? Sure.")
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject) return tStatus.STATUS_SUCCESS end

while true do
  local bOk, nSenderPid, sSignalName, p1 = syscall("signal_pull")
  if bOk and sSignalName == "driver_init" then
    local pDriverObject = p1
    pDriverObject.fDriverUnload = DriverUnload
    local nStatus = DriverEntry(pDriverObject)
    syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
  end
end
```


axis-os\src\kernel\drivers\eeprom.sys.lua
```
-- /drivers/eeprom.sys.lua - Stub Driver
local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = { sDriverName = "AxisEEPROMStub", sDriverType = tDKStructs.DRIVER_TYPE_KMD, nLoadPriority = 500 }

function DriverEntry(pDriverObject)
  oKMD.DkPrint("EEPROM Stub Driver loaded. Doing nothing.")
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject) return tStatus.STATUS_SUCCESS end

while true do
  local bOk, nSenderPid, sSignalName, p1 = syscall("signal_pull")
  if bOk and sSignalName == "driver_init" then
    local pDriverObject = p1
    pDriverObject.fDriverUnload = DriverUnload
    local nStatus = DriverEntry(pDriverObject)
    syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
  end
end
```


axis-os\src\kernel\drivers\filesystem.sys.lua
```
-- /drivers/filesystem.sys.lua - Stub Driver
-- note: this is for secondary filesystems. the root fs is handled by the kernel/pm.
-- this driver would be responsible for mounting other partitions in the future.
local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = { sDriverName = "AxisFSStub", sDriverType = tDKStructs.DRIVER_TYPE_KMD, nLoadPriority = 500 }

function DriverEntry(pDriverObject)
  oKMD.DkPrint("Filesystem Stub Driver loaded. Ready to mount future devices.")
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject) return tStatus.STATUS_SUCCESS end

while true do
  local bOk, nSenderPid, sSignalName, p1 = syscall("signal_pull")
  if bOk and sSignalName == "driver_init" then
    local pDriverObject = p1
    pDriverObject.fDriverUnload = DriverUnload
    local nStatus = DriverEntry(pDriverObject)
    syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
  end
end
```


axis-os\src\kernel\drivers\gpu.sys.lua
```
--
-- /drivers/gpu.sys.lua
-- the gpu driver, remade for the new world order.
-- it's still a middleman, but now it's a middleman with a fancy suit and a proper job title.
-- it exposes the gpu component as a standard system device.
--

-- our driver development kit. don't leave home without it.
local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

-- static info for DKMS. this is our driver's resume.
g_tDriverInfo = {
  sDriverName = "AxisGPU",
  sDriverType = tDKStructs.DRIVER_TYPE_KMD,
  nLoadPriority = 150, -- important, but less so than the initial TTY
  sVersion = "1.0.0",
}

-- module-level state. we only manage one device, so this is fine.
local g_pDeviceObject = nil

-------------------------------------------------
-- IRP HANDLERS
-- the functions that do the actual work when someone talks to our device.
-------------------------------------------------

-- called on fs.open("/dev/gpu0")
-- lets an application get a handle to us.
local function fGpuDispatchCreate(pDeviceObject, pIrp)
  oKMD.DkPrint("GPU: IRP_MJ_CREATE received. Granting handle.")
  -- nothing to do here but say "ok".
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

-- called on fs.close(handle)
local function fGpuDispatchClose(pDeviceObject, pIrp)
  oKMD.DkPrint("GPU: IRP_MJ_CLOSE received. Releasing handle.")
  -- again, nothing to clean up per-handle.
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

-- this is the main one. it's the "do stuff" command.
-- replaces the old custom 'gpu_invoke' signal.
local function fGpuDispatchDeviceControl(pDeviceObject, pIrp)
  local tParams = pIrp.tParameters
  local sMethod = tParams.sMethod
  local tArgs = tParams.tArgs
  
  if not sMethod or type(tArgs) ~= "table" then
    oKMD.DkPrint("GPU: Invalid parameters for DEVICE_CONTROL.")
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER)
    return
  end
  
  oKMD.DkPrint("GPU: DEVICE_CONTROL for method '" .. sMethod .. "'")
  
  -- get our hardware proxy from the scratchpad we saved it in
  local oProxy = pDeviceObject.pDeviceExtension.oGpuProxy
  if not oProxy then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_DEVICE_NOT_READY)
    return
  end
  
  -- the actual hardware call. wrap it in a pcall because who knows what the user sent us.
  local bIsOk, ... = pcall(oProxy[sMethod], table.unpack(tArgs))
  
  if bIsOk then
    -- success! pack the return values and complete the request.
    local tReturnValues = {...}
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, tReturnValues)
  else
    -- the component call failed. report the error.
    local sErrorMsg = ...
    oKMD.DkPrint("GPU: Hardware invocation failed: " .. tostring(sErrorMsg))
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, sErrorMsg)
  end
end


-------------------------------------------------
-- DRIVER ENTRY & EXIT
-- the birth and death of our driver.
-------------------------------------------------

-- DKMS calls this function after it creates our process. this is where we set everything up.
function DriverEntry(pDriverObject)
  oKMD.DkPrint("AxisGPU DriverEntry starting.")
  
  -- 1. Set up our IRP dispatch table. this tells DKMS which functions to call for which actions.
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CREATE] = fGpuDispatchCreate
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CLOSE] = fGpuDispatchClose
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_DEVICE_CONTROL] = fGpuDispatchDeviceControl
  
  -- 2. Create our device object. this is our representation in the kernel's device tree.
  local nStatus, pDeviceObj = oKMD.DkCreateDevice(pDriverObject, "\\Device\\Gpu0")
  if nStatus ~= tStatus.STATUS_SUCCESS then
    oKMD.DkPrint("GPU: Failed to create device object! Status: " .. nStatus)
    return nStatus
  end
  g_pDeviceObject = pDeviceObj
  
  -- 3. Create a symbolic link. this gives our device a friendly name in the VFS.
  nStatus = oKMD.DkCreateSymbolicLink("/dev/gpu0", "\\Device\\Gpu0")
  if nStatus ~= tStatus.STATUS_SUCCESS then
    oKMD.DkPrint("GPU: Failed to create symbolic link!")
    oKMD.DkDeleteDevice(pDeviceObj) -- cleanup what we already created
    return nStatus
  end
  
  -- 4. Initialize hardware and store state in the device extension.
  local sMyAddress = env.address
  if not sMyAddress then
    oKMD.DkPrint("GPU: No component address passed in environment!")
    return tStatus.STATUS_INVALID_PARAMETER
  end
  
  local nProxyStatus, oProxy = oKMD.DkGetHardwareProxy(sMyAddress)
  if nProxyStatus ~= tStatus.STATUS_SUCCESS then
    oKMD.DkPrint("GPU: Failed to get hardware proxy!")
    return nProxyStatus
  end
  
  -- the device extension is our private scratchpad for this device instance.
  g_pDeviceObject.pDeviceExtension.oGpuProxy = oProxy
  
  oKMD.DkPrint("AxisGPU DriverEntry completed successfully.")
  return tStatus.STATUS_SUCCESS
end

-- DKMS calls this when it's time to unload the driver.
function DriverUnload(pDriverObject)
  oKMD.DkPrint("AxisGPU DriverUnload starting.")
  
  -- cleanup in reverse order of creation.
  oKMD.DkDeleteSymbolicLink("/dev/gpu0")
  oKMD.DkDeleteDevice(g_pDeviceObject)
  
  oKMD.DkPrint("AxisGPU DriverUnload completed.")
  return tStatus.STATUS_SUCCESS
end

-------------------------------------------------
-- MAIN DRIVER LOOP
-- the driver process just sits here, waiting for instructions from the kernel/dkms.
-------------------------------------------------
while true do
  local bOk, nSenderPid, sSignalName, p1, p2 = syscall("signal_pull")
  
  if bOk then
    if sSignalName == "driver_init" then
      -- DKMS is telling us to initialize.
      local pDriverObject = p1
      pDriverObject.fDriverUnload = DriverUnload -- register our unload function
      local nStatus = DriverEntry(pDriverObject)
      
      -- report back with status AND the modified driver object.
      syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
      
    elseif sSignalName == "irp_dispatch" then
      -- DKMS has a job for us.
      local pIrp = p1
      local fHandler = p2 -- DKMS tells us which of our functions to run
      fHandler(g_pDeviceObject, pIrp)
    end
  end
end
```


axis-os\src\kernel\drivers\internet.sys.lua
```
--
-- /drivers/internet.sys.lua
-- AxisOS Network Driver v2.1
-- Fixed timing: uses computer.uptime() instead of os.clock()
--

local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = {
  sDriverName = "AxisNet",
  sDriverType = tDKStructs.DRIVER_TYPE_KMD,
  nLoadPriority = 250,
  sVersion = "2.1.0",
}

local g_pDeviceObject = nil
local g_oNetProxy = nil
-- local g_oNetfilter = nil

-- =============================================
-- ROBUST TIME FUNCTION
-- computer.uptime() is wall time in OC.
-- Accessible through sandbox __index → _G chain.
-- =============================================

local function fNow()
  local bOk, nTime = pcall(function() return computer.uptime() end)
  if bOk and nTime then return nTime end
  -- fallback: raw_computer (Ring 0 only)
  bOk, nTime = pcall(function() return raw_computer.uptime() end)
  if bOk and nTime then return nTime end
  -- last resort
  return os.clock()
end

-- =============================================
-- SESSION MANAGEMENT
-- =============================================

local g_tSessions = {}
local g_nNextSession = 1
local MAX_SESSIONS = 32
local DEFAULT_TIMEOUT = 10
local MAX_WAIT_YIELDS = 500

local function fAllocSession(sType)
  if g_nNextSession > 99999 then g_nNextSession = 1 end
  local nId = g_nNextSession
  g_nNextSession = g_nNextSession + 1
  g_tSessions[nId] = {
    nId           = nId,
    sType         = sType,
    oHandle       = nil,
    sStatus       = "new",
    sError        = nil,
    nHttpCode     = nil,
    sHttpMsg      = nil,
    tHttpHeaders  = nil,
    sUrl          = nil,
    sMethod       = nil,
    nStartTime    = fNow(),
    nConnectTime  = nil,
    nBytesRead    = 0,
    nBytesWritten = 0,
  }
  return nId, g_tSessions[nId]
end

local function fCloseSession(nId)
  local s = g_tSessions[nId]
  if not s then return false end
  if s.oHandle then pcall(s.oHandle.close) end
  s.oHandle = nil
  s.sStatus = "closed"
  return true
end

local function fDestroySession(nId)
  fCloseSession(nId)
  g_tSessions[nId] = nil
end

local function fCountSessions()
  local n = 0
  for _ in pairs(g_tSessions) do n = n + 1 end
  return n
end

local function fCleanupStale()
  local nCleaned = 0
  for nId, s in pairs(g_tSessions) do
    if s.sStatus == "closed" or s.sStatus == "error" then
      g_tSessions[nId] = nil
      nCleaned = nCleaned + 1
    elseif s.sStatus ~= "new" and (fNow() - s.nStartTime) > 120 then
      fCloseSession(nId)
      g_tSessions[nId] = nil
      nCleaned = nCleaned + 1
    end
  end
  return nCleaned
end

-- =============================================
-- CONNECTION WAIT (fixed timing)
-- =============================================

local function fWaitConnect(oHandle, nTimeout)
  local nDeadline = fNow() + (nTimeout or DEFAULT_TIMEOUT)
  local nYields = 0

  while nYields < MAX_WAIT_YIELDS do
    -- check wall-clock deadline
    if fNow() >= nDeadline then
      return nil, "Connection timed out"
    end

    -- probe connection status (safely)
    local bPcallOk, r1, r2 = pcall(oHandle.finishConnect)

    if not bPcallOk then
      -- finishConnect threw an error
      return nil, tostring(r1)
    end

    if r1 == true then
      -- connected!
      return true
    end

    if r1 == nil and r2 then
      -- connection error (nil, "reason")
      return nil, tostring(r2)
    end

    -- r1 == false or (r1 == nil, r2 == nil): still connecting
    nYields = nYields + 1
    syscall("process_yield")
  end

  return nil, "Connection timed out (yield limit)"
end

local function fLoadNetfilter()
  local bOk, oNF = pcall(require, "netfilter")
  if not bOk or not oNF then
    oKMD.DkPrint("AxisNet: netfilter not available (no policy enforcement)")
    return nil
  end

  local bRulesOk, sRulesData = syscall("vfs_read_file", "/etc/netpolicy.lua")
  if bRulesOk and sRulesData then
    oNF.LoadRules(sRulesData)
    oKMD.DkPrint("AxisNet: Loaded /etc/netpolicy.lua")
  else
    oKMD.DkPrint("AxisNet: No /etc/netpolicy.lua (default: allow all)")
  end

  local bHostsOk, sHostsData = syscall("vfs_read_file", "/etc/hosts")
  if bHostsOk and sHostsData then
    oNF.LoadHosts(sHostsData)
    oKMD.DkPrint("AxisNet: Loaded /etc/hosts")
  end

  return oNF
end

local function fGetCallerInfo(pIrp)
  local nPid = pIrp.nSenderPid or 0
  local nRing = (nPid < 20) and 1 or 3
  local nUid = (nPid < 20) and 0 or 1000
  return nPid, nRing, nUid
end

local function fCheckAndAudit(pIrp, sProto, sHost, nPort)
  if not g_oNetfilter then return true end

  local nPid, nRing, nUid = fGetCallerInfo(pIrp)

  local bUnderLimit, nCurrent = g_oNetfilter.CheckConnectionLimit(nUid)
  if not bUnderLimit then
    g_oNetfilter.Audit("DENY_LIMIT", sProto, sHost, nPort, nPid, nUid,
                       "Connection limit (" .. nCurrent .. ")")
    return false, "Connection limit reached for UID " .. nUid
  end

  local sAction, tRule = g_oNetfilter.CheckPolicy(sProto, sHost, nPort, nRing, nUid)

  if sAction == "deny" then
    local sComment = tRule and tRule.comment or "Policy denied"
    g_oNetfilter.Audit("DENY", sProto, sHost, nPort, nPid, nUid, sComment)
    oKMD.DkPrint("AxisNet: BLOCKED " .. sProto .. " " ..
                 tostring(sHost) .. ":" .. tostring(nPort) ..
                 " PID " .. nPid .. " (" .. sComment .. ")")
    return false, "Blocked by network policy: " .. sComment
  end

  if sAction == "log" then
    g_oNetfilter.Audit("LOG_ALLOW", sProto, sHost, nPort, nPid, nUid,
                       tRule and tRule.comment or "")
  end

  g_oNetfilter.Audit("ALLOW", sProto, sHost, nPort, nPid, nUid, "")
  return true
end

-- =============================================
-- DEVICE_CONTROL METHODS
-- =============================================

local tMethods = {}

function tMethods.info(pDev, pIrp, tArgs)
  local bHttp, bTcp = false, false
  if g_oNetProxy then
    pcall(function() bHttp = g_oNetProxy.isHttpEnabled() end)
    pcall(function() bTcp = g_oNetProxy.isTcpEnabled() end)
  end
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {
    bHttpEnabled    = bHttp,
    bTcpEnabled     = bTcp,
    bOnline         = g_oNetProxy ~= nil,
    nMaxSessions    = MAX_SESSIONS,
    nActiveSessions = fCountSessions(),
    sDriverVersion  = "2.1.0",
  })
end

function tMethods.http_request(pDev, pIrp, tArgs)
  local sUrl     = tArgs[1]
  local sMethod  = (tArgs[2] or "GET"):upper()
  local sBody    = tArgs[3]
  local tHeaders = tArgs[4]
  local nTimeout = tArgs[5] or DEFAULT_TIMEOUT

  if not sUrl or #sUrl == 0 then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER, "Missing URL")
    return
  end
  -- HOST REWRITING
  if g_oNetfilter then
    local sRewritten, sBlockErr = g_oNetfilter.RewriteHost(sUrl)
    if not sRewritten then
      oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_ACCESS_DENIED, sBlockErr)
      return
    end
    if sRewritten ~= sUrl then
      oKMD.DkPrint("AxisNet: Rewrote " .. sUrl .. " -> " .. sRewritten)
      sUrl = sRewritten
    end
  end

  -- POLICY CHECK
  local sHost = sUrl:match("^https?://([^/:]+)") or sUrl:match("^([^/:]+)")
  local nPort = tonumber(sUrl:match("^https?://[^/:]+:(%d+)")) or
                (sUrl:sub(1, 5) == "https" and 443 or 80)
  local bAllowed, sDenyReason = fCheckAndAudit(pIrp, "http", sHost, nPort)
  if not bAllowed then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_ACCESS_DENIED, sDenyReason)
    return
  end

  if not g_oNetProxy then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_DEVICE_NOT_READY, "No internet card")
    return
  end
  if fCountSessions() >= MAX_SESSIONS then
    fCleanupStale()
    if fCountSessions() >= MAX_SESSIONS then
      oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_DEVICE_BUSY, "Too many sessions")
      return
    end
  end

  local nId, tSess = fAllocSession("http")
  tSess.sUrl = sUrl
  tSess.sMethod = sMethod

  local vPostData = nil
  if sMethod == "POST" or sMethod == "PUT" or sMethod == "PATCH" then
    vPostData = sBody or ""
  end

  local bOk, oHandle = pcall(g_oNetProxy.request, sUrl, vPostData, tHeaders)
  if not bOk or not oHandle then
    tSess.sStatus = "error"
    tSess.sError = tostring(oHandle or "Request creation failed")
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, tSess.sError)
    fDestroySession(nId)
    return
  end

  tSess.oHandle = oHandle
  tSess.sStatus = "connecting"

  local bConn, sErr = fWaitConnect(oHandle, nTimeout)
  if not bConn then
    tSess.sStatus = "error"
    tSess.sError = sErr
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, sErr)
    fDestroySession(nId)
    return
  end

  tSess.nConnectTime = fNow()
  tSess.sStatus = "connected"
  -- TRACK CONNECTION
  if g_oNetfilter then
    local nPid = pIrp.nSenderPid or 0
    local nUid = (nPid < 20) and 0 or 1000
    g_oNetfilter.TrackConnect(nPid, nUid, "http", sHost, nPort, nId)
  end

  -- fetch response metadata
  local bResOk, nCode, sMsg, tHdrs = pcall(oHandle.response)
  if bResOk then
    tSess.nHttpCode = nCode
    tSess.sHttpMsg = sMsg
    tSess.tHttpHeaders = tHdrs
  end

  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {
    nSessionId     = nId,
    nStatusCode    = tSess.nHttpCode or 0,
    sStatusMessage = tSess.sHttpMsg or "",
    tHeaders       = tSess.tHttpHeaders or {},
    nConnectMs     = math.floor((tSess.nConnectTime - tSess.nStartTime) * 1000),
  })
end

function tMethods.http_read(pDev, pIrp, tArgs)
  local nId    = tArgs[1]
  local nCount = tArgs[2] or math.huge
  local tSess  = g_tSessions[nId]

  if not tSess or tSess.sType ~= "http" then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER, "Invalid session")
    return
  end
  if not tSess.oHandle or tSess.sStatus == "closed" then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_END_OF_FILE)
    return
  end

  local bOk, sData = pcall(tSess.oHandle.read, nCount)
  if bOk and sData then
    tSess.nBytesRead = tSess.nBytesRead + #sData
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, sData)
  else
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_END_OF_FILE)
  end
  if g_oNetfilter and bOk and sData then
    g_oNetfilter.TrackBytes(pIrp.nSenderPid or 0, nId, #sData)
  end
  
end

function tMethods.http_close(pDev, pIrp, tArgs)
  local nId = tArgs[1]
  if fCloseSession(nId) then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
  else
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER, "Unknown session")
  end
  if g_oNetfilter then
    g_oNetfilter.TrackClose(pIrp.nSenderPid or 0, nId)
  end
end

function tMethods.tcp_connect(pDev, pIrp, tArgs)
  local sHost    = tArgs[1]
  local nPort    = tonumber(tArgs[2])
  local nTimeout = tArgs[3] or DEFAULT_TIMEOUT

  if not sHost or not nPort then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER, "Missing host or port")
    return
  end
  if not g_oNetProxy then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_DEVICE_NOT_READY, "No internet card")
    return
  end
  if fCountSessions() >= MAX_SESSIONS then fCleanupStale() end

  local nId, tSess = fAllocSession("tcp")

  local bOk, oHandle = pcall(g_oNetProxy.connect, sHost, nPort)
  if not bOk or not oHandle then
    tSess.sStatus = "error"
    tSess.sError = tostring(oHandle or "Connect call failed")
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, tSess.sError)
    fDestroySession(nId)
    return
  end
  

  tSess.oHandle = oHandle
  tSess.sStatus = "connecting"

  -- HOST REWRITING
  if g_oNetfilter then
    local sRewritten, sBlockErr = g_oNetfilter.RewriteTcpHost(sHost)
    if not sRewritten then
      oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_ACCESS_DENIED, sBlockErr)
      return
    end
    sHost = sRewritten
  end

  -- POLICY CHECK
  local bAllowed, sDenyReason = fCheckAndAudit(pIrp, "tcp", sHost, nPort)
  if not bAllowed then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_ACCESS_DENIED, sDenyReason)
    return
  end

  local bConn, sErr = fWaitConnect(oHandle, nTimeout)
  if not bConn then
    tSess.sStatus = "error"
    tSess.sError = sErr
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, sErr)
    fDestroySession(nId)
    return
  end

  tSess.nConnectTime = fNow()
  tSess.sStatus = "connected"

  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {
    nSessionId = nId,
    nConnectMs = math.floor((tSess.nConnectTime - tSess.nStartTime) * 1000),
  })
end

function tMethods.tcp_write(pDev, pIrp, tArgs)
  local nId   = tArgs[1]
  local sData = tArgs[2]
  local tSess = g_tSessions[nId]

  if not tSess or tSess.sType ~= "tcp" or not tSess.oHandle then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER, "Invalid session")
    return
  end

  local bOk, nWritten = pcall(tSess.oHandle.write, sData)
  if bOk then
    tSess.nBytesWritten = tSess.nBytesWritten + (nWritten or #sData)
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, nWritten or #sData)
  else
    tSess.sStatus = "error"
    tSess.sError = tostring(nWritten)
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, tSess.sError)
  end
end

function tMethods.tcp_read(pDev, pIrp, tArgs)
  local nId    = tArgs[1]
  local nCount = tArgs[2] or math.huge
  local tSess  = g_tSessions[nId]

  if not tSess or tSess.sType ~= "tcp" or not tSess.oHandle then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER, "Invalid session")
    return
  end

  local bOk, sData = pcall(tSess.oHandle.read, nCount)
  if bOk and sData then
    tSess.nBytesRead = tSess.nBytesRead + #sData
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, sData)
  else
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_END_OF_FILE)
  end
end

function tMethods.tcp_close(pDev, pIrp, tArgs)
  tMethods.http_close(pDev, pIrp, tArgs)
  if g_oNetfilter then
    g_oNetfilter.TrackClose(pIrp.nSenderPid or 0, nId)
  end
end

function tMethods.ping(pDev, pIrp, tArgs)
  local sHost    = tArgs[1]
  local nPort    = tonumber(tArgs[2]) or 80
  local nCount   = tonumber(tArgs[3]) or 4
  local nTimeout = tonumber(tArgs[4]) or 5

  if not sHost then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER, "Missing host")
    return
  end

  -- POLICY CHECK
  local bAllowed, sDenyReason = fCheckAndAudit(pIrp, "tcp", sHost, nPort)
  if not bAllowed then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_ACCESS_DENIED, sDenyReason)
    return
  end

  if not g_oNetProxy then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_DEVICE_NOT_READY, "No internet card")
    return
  end
  if nCount > 20 then nCount = 20 end

  -- check TCP capability first
  local bTcpOk = false
  pcall(function() bTcpOk = g_oNetProxy.isTcpEnabled() end)

  if not bTcpOk then
    -- fallback: HTTP-based ping
    oKMD.DkPrint("AxisNet: TCP not enabled, using HTTP ping")
    local tResults = {}
    local nSuccess = 0
    local nTotalMs = 0
    local nMinMs = 999999
    local nMaxMs = 0

    for i = 1, nCount do
      local nStart = fNow()
      local sTestUrl = "http://" .. sHost .. ":" .. nPort .. "/"
      local bReqOk, oHandle = pcall(g_oNetProxy.request, sTestUrl)

      if not bReqOk or not oHandle then
        table.insert(tResults, { nSeq = i, sStatus = "error",
                                 sError = tostring(oHandle or "request failed") })
      else
        local bConn, sErr = fWaitConnect(oHandle, nTimeout)
        local nElapsed = math.floor((fNow() - nStart) * 1000)
        pcall(oHandle.close)

        if bConn then
          table.insert(tResults, { nSeq = i, sStatus = "ok", nMs = nElapsed })
          nSuccess = nSuccess + 1
          nTotalMs = nTotalMs + nElapsed
          if nElapsed < nMinMs then nMinMs = nElapsed end
          if nElapsed > nMaxMs then nMaxMs = nElapsed end
        else
          table.insert(tResults, { nSeq = i, sStatus = "timeout",
                                   nMs = nElapsed, sError = sErr })
        end
      end
      if i < nCount then syscall("process_yield") end
    end

    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {
      sHost    = sHost,
      nPort    = nPort,
      sMethod  = "http",
      nSent    = nCount,
      nRecv    = nSuccess,
      nLoss    = math.floor(((nCount - nSuccess) / math.max(nCount, 1)) * 100),
      nMinMs   = nMinMs < 999999 and nMinMs or 0,
      nAvgMs   = nSuccess > 0 and math.floor(nTotalMs / nSuccess) or 0,
      nMaxMs   = nMaxMs,
      tResults = tResults,
    })
    return
  end

  -- TCP-based ping
  local tResults = {}
  local nSuccess = 0
  local nTotalMs = 0
  local nMinMs = 999999
  local nMaxMs = 0

  for i = 1, nCount do
    local nStart = fNow()
    local bOk, oHandle = pcall(g_oNetProxy.connect, sHost, nPort)

    if not bOk or not oHandle then
      table.insert(tResults, { nSeq = i, sStatus = "error",
                               sError = tostring(oHandle or "connect failed") })
    else
      local bConn, sErr = fWaitConnect(oHandle, nTimeout)
      local nElapsed = math.floor((fNow() - nStart) * 1000)

      if bConn then
        pcall(oHandle.close)
        table.insert(tResults, { nSeq = i, sStatus = "ok", nMs = nElapsed })
        nSuccess = nSuccess + 1
        nTotalMs = nTotalMs + nElapsed
        if nElapsed < nMinMs then nMinMs = nElapsed end
        if nElapsed > nMaxMs then nMaxMs = nElapsed end
      else
        pcall(oHandle.close)
        table.insert(tResults, { nSeq = i, sStatus = "timeout",
                                 nMs = nElapsed, sError = sErr })
      end
    end

    -- yield between probes
    if i < nCount then syscall("process_yield") end
  end

  local nAvgMs = nSuccess > 0 and math.floor(nTotalMs / nSuccess) or 0
  local nLoss = math.floor(((nCount - nSuccess) / math.max(nCount, 1)) * 100)

  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {
    sHost    = sHost,
    nPort    = nPort,
    sMethod  = "tcp",
    nSent    = nCount,
    nRecv    = nSuccess,
    nLoss    = nLoss,
    nMinMs   = nMinMs < 999999 and nMinMs or 0,
    nAvgMs   = nAvgMs,
    nMaxMs   = nMaxMs,
    tResults = tResults,
  })
end

function tMethods.session_list(pDev, pIrp, tArgs)
  local tList = {}
  for nId, s in pairs(g_tSessions) do
    table.insert(tList, {
      nId     = nId,
      sType   = s.sType,
      sStatus = s.sStatus,
      sUrl    = s.sUrl,
      nBytes  = s.nBytesRead + s.nBytesWritten,
      nAge    = math.floor((fNow() - s.nStartTime) * 1000),
    })
  end
  table.sort(tList, function(a, b) return a.nId < b.nId end)
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, tList)
end

function tMethods.session_cleanup(pDev, pIrp, tArgs)
  local n = fCleanupStale()
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, n)
end

function tMethods.nf_reload(pDev, pIrp, tArgs)
  if not g_oNetfilter then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_NOT_IMPLEMENTED, "No netfilter")
    return
  end
  local bRulesOk, sRules = syscall("vfs_read_file", "/etc/netpolicy.lua")
  if bRulesOk and sRules then g_oNetfilter.LoadRules(sRules) end
  local bHostsOk, sHosts = syscall("vfs_read_file", "/etc/hosts")
  if bHostsOk and sHosts then g_oNetfilter.LoadHosts(sHosts) end
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, "Reloaded")
end

function tMethods.nf_audit(pDev, pIrp, tArgs)
  if not g_oNetfilter then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {})
    return
  end
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, g_oNetfilter.GetAuditLog())
end

function tMethods.nf_audit_clear(pDev, pIrp, tArgs)
  if g_oNetfilter then g_oNetfilter.ClearAuditLog() end
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

function tMethods.nf_stats(pDev, pIrp, tArgs)
  if not g_oNetfilter then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {})
    return
  end
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, g_oNetfilter.GetAllStats())
end

function tMethods.nf_rules(pDev, pIrp, tArgs)
  if not g_oNetfilter then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {})
    return
  end
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, g_oNetfilter.DumpRules())
end

function tMethods.nf_hosts(pDev, pIrp, tArgs)
  if not g_oNetfilter then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, {})
    return
  end
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, g_oNetfilter.DumpHosts())
end

function tMethods.nf_enable(pDev, pIrp, tArgs)
  if not g_oNetfilter then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_NOT_IMPLEMENTED)
    return
  end
  g_oNetfilter.SetEnabled(tArgs[1] ~= false)
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, g_oNetfilter.IsEnabled())
end

function tMethods.nf_set_limit(pDev, pIrp, tArgs)
  if not g_oNetfilter then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_NOT_IMPLEMENTED)
    return
  end
  local n = tonumber(tArgs[1])
  if n and n > 0 then
    g_oNetfilter.SetConnectionLimit(n)
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, n)
  else
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER)
  end
end

-- =============================================
-- IRP HANDLERS
-- =============================================

local function fCreate(pDev, pIrp)
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

local function fClose(pDev, pIrp)
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

-- Legacy write: URL as data → GET request
local g_tLegacySessions = {}

local function fWrite(pDev, pIrp)
  local sUrl = pIrp.tParameters.sData
  if not sUrl or not g_oNetProxy then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER)
    return
  end
  sUrl = sUrl:gsub("\n", "")

  local nOldId = g_tLegacySessions[pIrp.nSenderPid]
  if nOldId then fDestroySession(nOldId) end

  local nId, tSess = fAllocSession("http")
  tSess.sUrl = sUrl
  tSess.sMethod = "GET"

  local bOk, oHandle = pcall(g_oNetProxy.request, sUrl)
  if not bOk or not oHandle then
    fDestroySession(nId)
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, "Request failed")
    return
  end

  tSess.oHandle = oHandle
  tSess.sStatus = "connecting"

  local bConn, sErr = fWaitConnect(oHandle, DEFAULT_TIMEOUT)
  if not bConn then
    fDestroySession(nId)
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, sErr)
    return
  end

  tSess.nConnectTime = fNow()
  tSess.sStatus = "connected"
  g_tLegacySessions[pIrp.nSenderPid] = nId

  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, #sUrl)
end

local function fRead(pDev, pIrp)
  local nId = g_tLegacySessions[pIrp.nSenderPid]
  local tSess = nId and g_tSessions[nId]
  if not tSess or not tSess.oHandle then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_END_OF_FILE)
    return
  end
  local bOk, sData = pcall(tSess.oHandle.read, math.huge)
  if bOk and sData then
    tSess.nBytesRead = tSess.nBytesRead + #sData
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, sData)
  else
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_END_OF_FILE)
  end
end

local function fDeviceControl(pDev, pIrp)
  local sMethod = pIrp.tParameters.sMethod
  local tArgs   = pIrp.tParameters.tArgs or {}
  local fMethod = tMethods[sMethod]

  if fMethod then
    local bOk, sErr = pcall(fMethod, pDev, pIrp, tArgs)
    if not bOk then
      oKMD.DkPrint("AxisNet: Method '" .. tostring(sMethod) .. "' crashed: " .. tostring(sErr))
      -- try to complete the IRP if it wasn't already
      pcall(oKMD.DkCompleteRequest, pIrp, tStatus.STATUS_UNSUCCESSFUL,
            "Internal error: " .. tostring(sErr))
    end
  else
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_NOT_IMPLEMENTED,
                           "Unknown method: " .. tostring(sMethod))
  end
end

-- =============================================
-- DRIVER ENTRY
-- =============================================

function DriverEntry(pDriverObject)
  oKMD.DkPrint("AxisNet v2.1: Initializing...")

  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CREATE]         = fCreate
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CLOSE]          = fClose
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_WRITE]          = fWrite
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_READ]           = fRead
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_DEVICE_CONTROL] = fDeviceControl

  local nSt, pDevObj = oKMD.DkCreateDevice(pDriverObject, "\\Device\\Net0")
  if nSt ~= tStatus.STATUS_SUCCESS then return nSt end
  g_pDeviceObject = pDevObj

  local bOk, tList = syscall("raw_component_list", "internet")
  if bOk and tList then
    for sAddr in pairs(tList) do
      local _, p = oKMD.DkGetHardwareProxy(sAddr)
      g_oNetProxy = p
      break
    end
  end

  if not g_oNetProxy then
    oKMD.DkPrint("AxisNet: No internet card found.")
  else
    local bHttp, bTcp = false, false
    pcall(function() bHttp = g_oNetProxy.isHttpEnabled() end)
    pcall(function() bTcp = g_oNetProxy.isTcpEnabled() end)
    oKMD.DkPrint("AxisNet: Card found. HTTP=" .. tostring(bHttp) .. " TCP=" .. tostring(bTcp))
    oKMD.DkPrint("AxisNet: Time source check: fNow()=" .. tostring(fNow()))
  end

  oKMD.DkCreateSymbolicLink("/dev/net", "\\Device\\Net0")

  pcall(function()
    syscall("reg_create_key", "@VT\\DRV\\AxisNet")
    syscall("reg_set_value", "@VT\\DRV\\AxisNet", "Version", "2.1.0", "STR")
    syscall("reg_set_value", "@VT\\DRV\\AxisNet", "Online", g_oNetProxy ~= nil, "BOOL")
  end)

  oKMD.DkPrint("AxisNet v2.1: Online at /dev/net")
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject)
  for nId in pairs(g_tSessions) do fDestroySession(nId) end
  oKMD.DkDeleteSymbolicLink("/dev/net")
  oKMD.DkDeleteDevice(g_pDeviceObject)
  return tStatus.STATUS_SUCCESS
end

-- =============================================
-- MAIN LOOP
-- =============================================

while true do
  local bOk, nSenderPid, sSignalName, p1, p2 = syscall("signal_pull")
  if bOk then
    if sSignalName == "driver_init" then
      local pDriverObject = p1
      pDriverObject.fDriverUnload = DriverUnload
      local nSt = DriverEntry(pDriverObject)
      syscall("signal_send", nSenderPid, "driver_init_complete", nSt, pDriverObject)
    elseif sSignalName == "irp_dispatch" then
      local pIrp = p1
      local fHandler = p2
      fHandler(g_pDeviceObject, pIrp)
    end
  end
end
```


axis-os\src\kernel\drivers\iter.sys.lua
```
--
-- /drivers/ntm_fusion.sys.lua
-- Driver for the HBM's Nuclear Tech Mod ITER Fusion Reactor.
-- Its job is to tame the artificial sun and prevent it from disassembling itself
-- and the surrounding landscape. No pressure.
--

local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = {
  sDriverName = "AxisITER",
  sDriverType = tDKStructs.DRIVER_TYPE_CMD,
  nLoadPriority = 300,
  sVersion = "1.0.0-rc1",
  
  sSupportedComponent = "ntm_fusion" 
}

local g_pDeviceObject = nil

-------------------------------------------------
-- IRP HANDLERS
-------------------------------------------------

local function fIterDispatchCreate(pDeviceObject, pIrp)
  -- oKMD.DkPrint("ITER: Connection established.")
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

local function fIterDispatchClose(pDeviceObject, pIrp)
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

local function fIterDispatchDeviceControl(pDeviceObject, pIrp)
  local tParams = pIrp.tParameters
  local sMethod = tParams.sMethod
  local tArgs = tParams.tArgs or {}
  
  if not sMethod then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER)
    return
  end
  
  local oProxy = pDeviceObject.pDeviceExtension.oIterProxy
  if not oProxy then
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_DEVICE_NOT_READY)
    return
  end
  
  local bIsOk, ... = pcall(oProxy[sMethod], table.unpack(tArgs))
  
  if bIsOk then
    local tReturnValues = {...}
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, tReturnValues)
  else
    local sErrorMsg = ...
    oKMD.DkPrint("ITER: Hardware invocation failed for '" .. sMethod .. "': " .. tostring(sErrorMsg))
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_UNSUCCESSFUL, sErrorMsg)
  end
end


-------------------------------------------------
-- DRIVER ENTRY
-------------------------------------------------

function DriverEntry(pDriverObject)
  oKMD.DkPrint("AxisITER: Initializing Component Mode Driver.")
  
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CREATE] = fIterDispatchCreate
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CLOSE] = fIterDispatchClose
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_DEVICE_CONTROL] = fIterDispatchDeviceControl
  
  local nStatus, pDeviceObj = oKMD.DkCreateDevice(pDriverObject, "\\Device\\FusionReactor0")
  if nStatus ~= tStatus.STATUS_SUCCESS then return nStatus end
  g_pDeviceObject = pDeviceObj
  
  local nStatus, pDeviceObj = oKMD.DkCreateComponentDevice(pDriverObject, "iter")

  if nStatus ~= tStatus.STATUS_SUCCESS then 
    oKMD.DkPrint("ITER: Failed to create auto-device.")
    return nStatus 
  end
  g_pDeviceObject = pDeviceObj
  
  -- The address is GUARANTEED by DKMS because we are a CMD.
  local sMyAddress = env.address
  local nProxyStatus, oProxy = oKMD.DkGetHardwareProxy(sMyAddress)
  
  if nProxyStatus ~= tStatus.STATUS_SUCCESS then
    return nProxyStatus
  end
  
  g_pDeviceObject.pDeviceExtension.oIterProxy = oProxy
  
  oKMD.DkPrint("AxisITER: Online.")
  raw_computer.pullSignal(3)
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject)
  -- Cleanup using the stored name
  if g_pDeviceObject and g_pDeviceObject.pDeviceExtension.sAutoSymlink then
     oKMD.DkDeleteSymbolicLink(g_pDeviceObject.pDeviceExtension.sAutoSymlink)
  end
  oKMD.DkDeleteDevice(g_pDeviceObject)
  return tStatus.STATUS_SUCCESS
end

-------------------------------------------------
-- MAIN LOOP
-------------------------------------------------
while true do
  local bOk, nSenderPid, sSignalName, p1, p2 = syscall("signal_pull")
  if bOk then
    if sSignalName == "driver_init" then
      local pDriverObject = p1
      pDriverObject.fDriverUnload = DriverUnload
      local nStatus = DriverEntry(pDriverObject)
      syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
    elseif sSignalName == "irp_dispatch" then
      local pIrp = p1
      local fHandler = p2
      fHandler(g_pDeviceObject, pIrp)
    end
  end
end
```


axis-os\src\kernel\drivers\keyboard.sys.lua
```
-- /drivers/keyboard.sys.lua - Stub Driver
-- note: in our current system, keyboard events are raw 'key_down' signals
-- handled directly by the TTY driver. a real keyboard driver would grab these
-- and translate them into a standard input stream.
local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = { sDriverName = "AxisKeyboardStub", sDriverType = tDKStructs.DRIVER_TYPE_KMD, nLoadPriority = 200 }

function DriverEntry(pDriverObject)
  oKMD.DkPrint("Keyboard Stub Driver loaded. TTY is still doing all the work.")
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject) return tStatus.STATUS_SUCCESS end

while true do
  local bOk, nSenderPid, sSignalName, p1 = syscall("signal_pull")
  if bOk and sSignalName == "driver_init" then
    local pDriverObject = p1
    pDriverObject.fDriverUnload = DriverUnload
    local nStatus = DriverEntry(pDriverObject)
    syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
  end
end
```


axis-os\src\kernel\drivers\ringfs.sys.lua
```
--
-- /drivers/ringfs.sys.lua
-- A circular buffer filesystem driver.
-- It eats text and keeps only the freshest bits.
--

local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = {
  sDriverName = "AxisRingFS",
  sDriverType = tDKStructs.DRIVER_TYPE_KMD, -- it's a generic utility driver
  nLoadPriority = 400,
  sVersion = "1.0.0",
}

local g_pDeviceObject = nil

-- default size if not specified. 4KB should be enough for anyone, right?
local DEFAULT_BUFFER_SIZE = 4096

-------------------------------------------------
-- IRP HANDLERS
-------------------------------------------------

local function fRingDispatchCreate(pDeviceObject, pIrp)
  -- oKMD.DkPrint("RingFS: Client connected.")
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

local function fRingDispatchClose(pDeviceObject, pIrp)
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
end

local function fRingDispatchWrite(pDeviceObject, pIrp)
  local sData = pIrp.tParameters.sData
  if not sData then 
    oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER)
    return 
  end
  
  local pExt = pDeviceObject.pDeviceExtension
  
  -- append new data to the buffer
  pExt.sBuffer = pExt.sBuffer .. tostring(sData)
  
  -- trim the fat if it gets too big
  if #pExt.sBuffer > pExt.nMaxSize then
    -- keep the end of the string
    pExt.sBuffer = string.sub(pExt.sBuffer, -pExt.nMaxSize)
  end
  
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, #sData)
end

local function fRingDispatchRead(pDeviceObject, pIrp)
  local pExt = pDeviceObject.pDeviceExtension
  -- return the whole buffer. simple.
  oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS, pExt.sBuffer)
end

local function fRingDispatchDeviceControl(pDeviceObject, pIrp)
  local sMethod = pIrp.tParameters.sMethod
  local pExt = pDeviceObject.pDeviceExtension
  
  if sMethod == "clear" then
     pExt.sBuffer = ""
     oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
  elseif sMethod == "resize" then
     local nNewSize = tonumber(pIrp.tParameters.tArgs[1])
     if nNewSize and nNewSize > 0 then
        pExt.nMaxSize = nNewSize
        -- trim immediately if needed
        if #pExt.sBuffer > pExt.nMaxSize then
           pExt.sBuffer = string.sub(pExt.sBuffer, -pExt.nMaxSize)
        end
        oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_SUCCESS)
     else
        oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_INVALID_PARAMETER)
     end
  else
     oKMD.DkCompleteRequest(pIrp, tStatus.STATUS_NOT_IMPLEMENTED)
  end
end

-------------------------------------------------
-- DRIVER ENTRY
-------------------------------------------------

function DriverEntry(pDriverObject)
  oKMD.DkPrint("RingFS: Spinning up the memory donut.")
  
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CREATE] = fRingDispatchCreate
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_CLOSE] = fRingDispatchClose
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_WRITE] = fRingDispatchWrite
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_READ] = fRingDispatchRead
  pDriverObject.tDispatch[tDKStructs.IRP_MJ_DEVICE_CONTROL] = fRingDispatchDeviceControl
  
  local nStatus, pDeviceObj = oKMD.DkCreateDevice(pDriverObject, "\\Device\\ringlog")
  if nStatus ~= tStatus.STATUS_SUCCESS then return nStatus end
  g_pDeviceObject = pDeviceObj
  
  -- init the buffer in the extension
  pDeviceObj.pDeviceExtension.sBuffer = ""
  pDeviceObj.pDeviceExtension.nMaxSize = DEFAULT_BUFFER_SIZE
  
  -- create the symlink so users can find us at /dev/ringlog
  oKMD.DkCreateSymbolicLink("/dev/ringlog", "\\Device\\ringlog")
  
  
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject)
  oKMD.DkDeleteSymbolicLink("/dev/ringlog")
  oKMD.DkDeleteDevice(g_pDeviceObject)
  return tStatus.STATUS_SUCCESS
end

-------------------------------------------------
-- MAIN LOOP
-------------------------------------------------
while true do
  local bOk, nSenderPid, sSignalName, p1, p2 = syscall("signal_pull")
  if bOk then
    if sSignalName == "driver_init" then
      local pDriverObject = p1
      pDriverObject.fDriverUnload = DriverUnload
      local nStatus = DriverEntry(pDriverObject)
      syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
    elseif sSignalName == "irp_dispatch" then
      local pIrp = p1
      local fHandler = p2
      fHandler(g_pDeviceObject, pIrp)
    end
  end
end
```


axis-os\src\kernel\drivers\screen.sys.lua
```
-- /drivers/screen.sys.lua - Stub Driver
-- note: the screen component is currently managed directly by the TTY and GPU drivers.
-- this stub just satisfies the loader for now.
local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = { sDriverName = "AxisScreenStub", sDriverType = tDKStructs.DRIVER_TYPE_KMD, nLoadPriority = 200 }

function DriverEntry(pDriverObject)
  oKMD.DkPrint("Screen Stub Driver loaded. GPU/TTY drivers are in control.")
  return tStatus.STATUS_SUCCESS
end

function DriverUnload(pDriverObject) return tStatus.STATUS_SUCCESS end

while true do
  local bOk, nSenderPid, sSignalName, p1 = syscall("signal_pull")
  if bOk and sSignalName == "driver_init" then
    local pDriverObject = p1
    pDriverObject.fDriverUnload = DriverUnload
    local nStatus = DriverEntry(pDriverObject)
    syscall("signal_send", nSenderPid, "driver_init_complete", nStatus, pDriverObject)
  end
end
```


axis-os\src\kernel\drivers\tty.sys.lua
```
--
-- /drivers/tty.sys.lua
-- v5.1: Color-Tracked Scrollback
-- PgUp/PgDn, Mouse Wheel, Home/End — with full color preservation.
--

local tStatus = require("errcheck")
local oKMD = require("kmd_api")
local tDKStructs = require("shared_structs")

g_tDriverInfo = {
  sDriverName = "AxisTTY",
  sDriverType = tDKStructs.DRIVER_TYPE_KMD,
  nLoadPriority = 100,
  sVersion = "5.1.0",
}

local g_pDeviceObject = nil
local g_oGpuProxy = nil
local g_tDispatchTable = nil

local SCROLLBACK_MAX    = 500
local SCROLL_WHEEL_STEP = 3
local DEFAULT_FG = 0xFFFFFF
local DEFAULT_BG = 0x000000

local tAnsiColors = {
  [30] = 0x000000, [31] = 0xFF0000, [32] = 0x00FF00, [33] = 0xFFFF00,
  [34] = 0x0000FF, [35] = 0xFF00FF, [36] = 0x00FFFF, [37] = 0xFFFFFF,
  [90] = 0x555555,
}

-- =============================================
-- 1. SHADOW BUFFER WITH PER-CELL COLOR
--
-- Live screen:
--   tScreenRows[y] = text string
--   tScreenFg[y]   = { [x]=fgColor, ... }  (sparse, nil=DEFAULT_FG)
--   tScreenBg[y]   = { [x]=bgColor, ... }  (sparse, nil=DEFAULT_BG)
--
-- Scrollback history:
--   tScrollback[n]   = text string
--   tScrollbackFg[n] = { [x]=fgColor, ... }
--   tScrollbackBg[n] = { [x]=bgColor, ... }
--
-- Current write colors:
--   nCurrentFg, nCurrentBg
-- =============================================

local function fInitBuffers(pExt)
  pExt.tScreenRows = {}
  pExt.tScreenFg   = {}
  pExt.tScreenBg   = {}
  for y = 1, pExt.nHeight do
    pExt.tScreenRows[y] = string.rep(" ", pExt.nWidth)
    pExt.tScreenFg[y]   = {}
    pExt.tScreenBg[y]   = {}
  end
  pExt.tScrollback   = {}
  pExt.tScrollbackFg = {}
  pExt.tScrollbackBg = {}
  pExt.nScrollOffset = 0
  pExt.nCurrentFg    = DEFAULT_FG
  pExt.nCurrentBg    = DEFAULT_BG
end

-- record the current fg/bg into the color maps for a range of cells
local function fRecordColors(pExt, nY, nStartX, nCount)
  if nY < 1 or nY > pExt.nHeight then return end
  local tFg = pExt.tScreenFg[nY]
  local tBg = pExt.tScreenBg[nY]
  if not tFg then tFg = {}; pExt.tScreenFg[nY] = tFg end
  if not tBg then tBg = {}; pExt.tScreenBg[nY] = tBg end
  local fg, bg = pExt.nCurrentFg, pExt.nCurrentBg
  local nEnd = math.min(nStartX + nCount - 1, pExt.nWidth)
  for x = nStartX, nEnd do
    tFg[x] = fg
    tBg[x] = bg
  end
end

-- update the text shadow for a range
local function fUpdateShadow(pExt, nX, nY, sText)
  if nY < 1 or nY > pExt.nHeight then return end
  local sRow = pExt.tScreenRows[nY]
  if not sRow then sRow = string.rep(" ", pExt.nWidth) end
  if #sRow < pExt.nWidth then
    sRow = sRow .. string.rep(" ", pExt.nWidth - #sRow)
  end
  local nEnd = math.min(nX + #sText - 1, pExt.nWidth)
  local nLen = nEnd - nX + 1
  if nLen <= 0 then return end
  local sBefore = (nX > 1) and sRow:sub(1, nX - 1) or ""
  local sAfter  = (nEnd < pExt.nWidth) and sRow:sub(nEnd + 1) or ""
  pExt.tScreenRows[nY] = sBefore .. sText:sub(1, nLen) .. sAfter
end

-- =============================================
-- 2. COLOR-AWARE RENDERING
-- Renders one row to the GPU using stored color info.
-- Groups consecutive same-color cells into single gpu.set calls.
-- =============================================

local function fRenderRow(nScreenY, sText, tFg, tBg, nWidth)
  if not g_oGpuProxy then return end
  if not sText then sText = "" end
  if #sText < nWidth then sText = sText .. string.rep(" ", nWidth - #sText) end

  local nLastSetFg, nLastSetBg = -1, -1
  local nX = 1

  while nX <= nWidth do
    local nFg = (tFg and tFg[nX]) or DEFAULT_FG
    local nBg = (tBg and tBg[nX]) or DEFAULT_BG

    -- find how far this color run extends
    local nRunEnd = nX
    while nRunEnd < nWidth do
      local nNFg = (tFg and tFg[nRunEnd + 1]) or DEFAULT_FG
      local nNBg = (tBg and tBg[nRunEnd + 1]) or DEFAULT_BG
      if nNFg ~= nFg or nNBg ~= nBg then break end
      nRunEnd = nRunEnd + 1
    end

    -- only call GPU color setters when the color actually changes
    if nFg ~= nLastSetFg then g_oGpuProxy.setForeground(nFg); nLastSetFg = nFg end
    if nBg ~= nLastSetBg then g_oGpuProxy.setBackground(nBg); nLastSetBg = nBg end
    g_oGpuProxy.set(nX, nScreenY, sText:sub(nX, nRunEnd))

    nX = nRunEnd + 1
  end
end

-- =============================================
-- 3. SCROLL ENGINE
-- =============================================

local function scroll(pExt)
  if not g_oGpuProxy then return end

  -- ONLY push to scrollback on main screen
  if not pExt.bAltScreen then
    table.insert(pExt.tScrollback,   pExt.tScreenRows[1] or "")
    table.insert(pExt.tScrollbackFg, pExt.tScreenFg[1]   or {})
    table.insert(pExt.tScrollbackBg, pExt.tScreenBg[1]   or {})

    if #pExt.tScrollback > SCROLLBACK_MAX then
      table.remove(pExt.tScrollback,   1)
      table.remove(pExt.tScrollbackFg, 1)
      table.remove(pExt.tScrollbackBg, 1)
      if pExt.nScrollOffset > #pExt.tScrollback then
        pExt.nScrollOffset = #pExt.tScrollback
      end
    end
  end

  -- shift live rows up (unchanged)
  for y = 1, pExt.nHeight - 1 do
    pExt.tScreenRows[y] = pExt.tScreenRows[y + 1]
    pExt.tScreenFg[y]   = pExt.tScreenFg[y + 1]
    pExt.tScreenBg[y]   = pExt.tScreenBg[y + 1]
  end
  pExt.tScreenRows[pExt.nHeight] = string.rep(" ", pExt.nWidth)
  pExt.tScreenFg[pExt.nHeight]   = {}
  pExt.tScreenBg[pExt.nHeight]   = {}

  if pExt.nScrollOffset == 0 then
    g_oGpuProxy.copy(1, 2, pExt.nWidth, pExt.nHeight - 1, 0, -1)
    g_oGpuProxy.fill(1, pExt.nHeight, pExt.nWidth, 1, " ")
  end
  pExt.nCursorY = pExt.nHeight
end

-- redraw the entire screen from scrollback + live at current offset
local function fRenderViewport(pExt)
  if not g_oGpuProxy then return end
  local nSbLen = #pExt.tScrollback
  local nTotal = nSbLen + pExt.nHeight
  local nStart = nTotal - pExt.nHeight - pExt.nScrollOffset + 1
  if nStart < 1 then nStart = 1 end

  for screenY = 1, pExt.nHeight do
    local nVirt = nStart + screenY - 1
    local sLine, tFg, tBg
    if nVirt <= nSbLen then
      sLine = pExt.tScrollback[nVirt]
      tFg   = pExt.tScrollbackFg[nVirt]
      tBg   = pExt.tScrollbackBg[nVirt]
    else
      local nLiveY = nVirt - nSbLen
      sLine = pExt.tScreenRows[nLiveY]
      tFg   = pExt.tScreenFg[nLiveY]
      tBg   = pExt.tScreenBg[nLiveY]
    end
    fRenderRow(screenY, sLine, tFg, tBg, pExt.nWidth)
  end

  -- scroll indicator
  if pExt.nScrollOffset > 0 then
    local sInd = string.format(" [-%d lines] PgUp/PgDn ", pExt.nScrollOffset)
    if #sInd > pExt.nWidth then sInd = sInd:sub(1, pExt.nWidth) end
    local nIndX = pExt.nWidth - #sInd + 1
    if nIndX < 1 then nIndX = 1 end
    g_oGpuProxy.setForeground(0x000000)
    g_oGpuProxy.setBackground(0xFFFF00)
    g_oGpuProxy.set(nIndX, pExt.nHeight, sInd)
  end
end

-- restore the live screen with colors
local function fRenderLive(pExt)
  if not g_oGpuProxy then return end
  for y = 1, pExt.nHeight do
    fRenderRow(y, pExt.tScreenRows[y], pExt.tScreenFg[y], pExt.tScreenBg[y], pExt.nWidth)
  end
  -- restore the current write colors so new output uses the right ones
  g_oGpuProxy.setForeground(pExt.nCurrentFg)
  g_oGpuProxy.setBackground(pExt.nCurrentBg)
end

local function fScrollUp(pExt, nLines)
  local nMax = #pExt.tScrollback
  if nMax == 0 then return end
  pExt.nScrollOffset = math.min(pExt.nScrollOffset + nLines, nMax)
  fRenderViewport(pExt)
end

local function fScrollDown(pExt, nLines)
  if pExt.nScrollOffset <= 0 then return end
  pExt.nScrollOffset = math.max(pExt.nScrollOffset - nLines, 0)
  if pExt.nScrollOffset == 0 then
    fRenderLive(pExt)
  else
    fRenderViewport(pExt)
  end
end

local function fSnapToBottom(pExt)
  if pExt.nScrollOffset > 0 then
    pExt.nScrollOffset = 0
    fRenderLive(pExt)
  end
end

-- =============================================
-- 4. WRITE ENGINE (color-tracked)
-- =============================================

local function rawWrite(pExt, sText)
  if #sText == 0 then return end
  local nLen   = #sText
  local nSpace = pExt.nWidth - pExt.nCursorX + 1

  if nLen <= nSpace then
    fRecordColors(pExt, pExt.nCursorY, pExt.nCursorX, nLen)
    fUpdateShadow(pExt, pExt.nCursorX, pExt.nCursorY, sText)
    if pExt.nScrollOffset == 0 and g_oGpuProxy then
      g_oGpuProxy.set(pExt.nCursorX, pExt.nCursorY, sText)
    end
    pExt.nCursorX = pExt.nCursorX + nLen
    if pExt.nCursorX > pExt.nWidth then
      pExt.nCursorX = 1
      if pExt.nCursorY < pExt.nHeight then
        pExt.nCursorY = pExt.nCursorY + 1
      else
        scroll(pExt)
      end
    end
  else
    local sPart = string.sub(sText, 1, nSpace)
    fRecordColors(pExt, pExt.nCursorY, pExt.nCursorX, nSpace)
    fUpdateShadow(pExt, pExt.nCursorX, pExt.nCursorY, sPart)
    if pExt.nScrollOffset == 0 and g_oGpuProxy then
      g_oGpuProxy.set(pExt.nCursorX, pExt.nCursorY, sPart)
    end
    pExt.nCursorX = 1
    if pExt.nCursorY < pExt.nHeight then
      pExt.nCursorY = pExt.nCursorY + 1
    else
      scroll(pExt)
    end
    rawWrite(pExt, string.sub(sText, nSpace + 1))
  end
end

local function writeToScreen(pDeviceObject, sData)
  if not g_oGpuProxy then return end
  local pExt = pDeviceObject.pDeviceExtension
  local sStr = tostring(sData)

  if not sStr:find("[%c\27]") then
    pcall(rawWrite, pExt, sStr)
    return
  end

  local nLen = #sStr
  local nIdx = 1

  while nIdx <= nLen do
    local nNext = string.find(sStr, "[%c\27]", nIdx)
    if not nNext then
      pcall(rawWrite, pExt, string.sub(sStr, nIdx))
      break
    end
    if nNext > nIdx then
      pcall(rawWrite, pExt, string.sub(sStr, nIdx, nNext - 1))
    end

    local nByte = string.byte(sStr, nNext)
    pcall(function()
      if nByte == 10 then -- \n
        pExt.nCursorX = 1
        if pExt.nCursorY < pExt.nHeight then
          pExt.nCursorY = pExt.nCursorY + 1
        else
          scroll(pExt)
        end
        nIdx = nNext + 1

      elseif nByte == 13 then -- \r
        pExt.nCursorX = 1
        nIdx = nNext + 1

      elseif nByte == 8 then -- \b
        if pExt.nCursorX > 1 then
          pExt.nCursorX = pExt.nCursorX - 1
          fUpdateShadow(pExt, pExt.nCursorX, pExt.nCursorY, " ")
          if pExt.tScreenFg[pExt.nCursorY] then
            pExt.tScreenFg[pExt.nCursorY][pExt.nCursorX] = nil
          end
          if pExt.tScreenBg[pExt.nCursorY] then
            pExt.tScreenBg[pExt.nCursorY][pExt.nCursorX] = nil
          end
          if pExt.nScrollOffset == 0 then
            g_oGpuProxy.set(pExt.nCursorX, pExt.nCursorY, " ")
          end
        end
        nIdx = nNext + 1

      elseif nByte == 12 then -- \f  (clear screen)
        for y = 1, pExt.nHeight do
          pExt.tScreenRows[y] = string.rep(" ", pExt.nWidth)
          pExt.tScreenFg[y]   = {}
          pExt.tScreenBg[y]   = {}
        end
        pExt.nScrollOffset = 0
        pExt.nCurrentFg = DEFAULT_FG
        pExt.nCurrentBg = DEFAULT_BG
        g_oGpuProxy.setForeground(DEFAULT_FG)
        g_oGpuProxy.setBackground(DEFAULT_BG)
        g_oGpuProxy.fill(1, 1, pExt.nWidth, pExt.nHeight, " ")
        pExt.nCursorX, pExt.nCursorY = 1, 1
        nIdx = nNext + 1

      elseif nByte == 27 then -- ESC
        if string.sub(sStr, nNext + 1, nNext + 1) == "[" then
          local nEnd = string.find(sStr, "[a-zA-Z]", nNext + 2)
          if nEnd and (nEnd - nNext) < 20 then
            local sCmd   = string.sub(sStr, nEnd, nEnd)
            local sParam = string.sub(sStr, nNext + 2, nEnd - 1)
            local tP = {}
            for sVal in string.gmatch(sParam, "%d+") do
              table.insert(tP, tonumber(sVal))
            end

            if sCmd == "m" then
              local bAny = false
              for _, n in ipairs(tP) do
                if tAnsiColors[n] then
                  pExt.nCurrentFg = tAnsiColors[n]
                  bAny = true
                elseif n >= 40 and n <= 47 then              -- ADD
                  pExt.nCurrentBg = tAnsiColors[n - 10] or DEFAULT_BG  -- ADD
                  bAny = true                                 -- ADD
                elseif n == 7 then                            -- ADD (reverse)
                  pExt.nCurrentFg, pExt.nCurrentBg =          -- ADD
                    pExt.nCurrentBg, pExt.nCurrentFg           -- ADD
                  bAny = true                                 -- ADD
                elseif n == 0 then
                  pExt.nCurrentFg = DEFAULT_FG
                  pExt.nCurrentBg = DEFAULT_BG
                  bAny = true
                end
              end
              if not bAny and #tP == 0 then
                pExt.nCurrentFg = DEFAULT_FG
                pExt.nCurrentBg = DEFAULT_BG
              end
              -- apply to GPU only when live
              if pExt.nScrollOffset == 0 then
                g_oGpuProxy.setForeground(pExt.nCurrentFg)
                g_oGpuProxy.setBackground(pExt.nCurrentBg)
              end

            elseif sCmd == "H" or sCmd == "f" then
              pExt.nCursorY = math.max(1, math.min(pExt.nHeight, tP[1] or 1))
              pExt.nCursorX = math.max(1, math.min(pExt.nWidth,  tP[2] or 1))

            elseif sCmd == "J" then
              if tP[1] == 2 then
                for y = 1, pExt.nHeight do
                  pExt.tScreenRows[y] = string.rep(" ", pExt.nWidth)
                  pExt.tScreenFg[y]   = {}
                  pExt.tScreenBg[y]   = {}
                end
                if pExt.nScrollOffset == 0 then
                  g_oGpuProxy.fill(1, 1, pExt.nWidth, pExt.nHeight, " ")
                end
                pExt.nCursorX, pExt.nCursorY = 1, 1
              end

            elseif sCmd == "A" then
              pExt.nCursorY = math.max(1, pExt.nCursorY - (tP[1] or 1))
            elseif sCmd == "B" then
              pExt.nCursorY = math.min(pExt.nHeight, pExt.nCursorY + (tP[1] or 1))
            elseif sCmd == "C" then
              pExt.nCursorX = math.min(pExt.nWidth, pExt.nCursorX + (tP[1] or 1))
            elseif sCmd == "D" then
              pExt.nCursorX = math.max(1, pExt.nCursorX - (tP[1] or 1))
            end

            nIdx = nEnd + 1
            nNext = nEnd
          else
            nIdx = nNext + 1
          end
        else
          nIdx = nNext + 1
        end
      else
        nIdx = nNext + 1
      end
    end)

    if nIdx <= nNext then nIdx = nNext + 1 end
  end
end


-- =============================================
-- 4b. VISIBLE CURSOR
-- GPU-only overlay — not baked into shadow buffer.
-- Inverted block at current input position.
-- =============================================

local function fShowCursor(ext)
  if not g_oGpuProxy then return end
  if not ext.pPendingReadIrp then return end
  if ext.nScrollOffset > 0 then return end
  if ext.bAltScreen then return end

  local nX, nY = ext.nCursorX, ext.nCursorY
  if nX < 1 or nX > ext.nWidth or nY < 1 or nY > ext.nHeight then return end

  -- Read char from shadow (cursor is GPU-only, never touches shadow)
  local sChar = " "
  local sRow = ext.tScreenRows[nY]
  if sRow and nX <= #sRow then
    local c = sRow:sub(nX, nX)
    if c ~= "" then sChar = c end
  end

  -- Draw inverted block
  g_oGpuProxy.setForeground(DEFAULT_BG)
  g_oGpuProxy.setBackground(DEFAULT_FG)
  g_oGpuProxy.set(nX, nY, sChar)

  -- Restore write colors so subsequent output is normal
  g_oGpuProxy.setForeground(ext.nCurrentFg)
  g_oGpuProxy.setBackground(ext.nCurrentBg)

  ext.bCursorShown  = true
  ext.nCursorShownX = nX
  ext.nCursorShownY = nY
end

local function fHideCursor(ext)
  if not g_oGpuProxy or not ext.bCursorShown then return end
  ext.bCursorShown = false

  local nX = ext.nCursorShownX
  local nY = ext.nCursorShownY
  if not nX or not nY then return end
  if nY < 1 or nY > ext.nHeight or nX < 1 or nX > ext.nWidth then return end

  -- Restore from shadow buffer with correct per-cell colors
  local sChar = " "
  local sRow = ext.tScreenRows[nY]
  if sRow and nX <= #sRow then
    local c = sRow:sub(nX, nX)
    if c ~= "" then sChar = c end
  end

  local nFg = (ext.tScreenFg[nY] and ext.tScreenFg[nY][nX]) or DEFAULT_FG
  local nBg = (ext.tScreenBg[nY] and ext.tScreenBg[nY][nX]) or DEFAULT_BG

  g_oGpuProxy.setForeground(nFg)
  g_oGpuProxy.setBackground(nBg)
  g_oGpuProxy.set(nX, nY, sChar)

  -- Restore write colors
  g_oGpuProxy.setForeground(ext.nCurrentFg)
  g_oGpuProxy.setBackground(ext.nCurrentBg)
end

-- =============================================
-- 4c. TEXT SELECTION
-- =============================================

local function fIsShiftHeld(ext)
  if not ext.oKbdProxy then return false end
  local bOk, bShift = pcall(ext.oKbdProxy.isShiftDown)
  return bOk and bShift
end

local function fIsCtrlHeld(ext)
  if not ext.oKbdProxy then return false end
  local bOk, bCtrl = pcall(ext.oKbdProxy.isControlDown)
  return bOk and bCtrl
end

local function fSelGetRange(ext)
  local tSel = ext.tSel
  if not tSel.bActive then return nil, nil end
  local nLo = math.min(tSel.nAnchor, tSel.nEnd)
  local nHi = math.max(tSel.nAnchor, tSel.nEnd)
  return nLo, nHi
end

local function fSelGetText(ext)
  local nLo, nHi = fSelGetRange(ext)
  if not nLo then return "" end
  local sBuf = ext.sLineBuffer or ""
  return sBuf:sub(nLo + 1, nHi)
end

local function fSelClear(ext)
  ext.tSel.bActive = false
  ext.tSel.nAnchor = 0
  ext.tSel.nEnd = 0
end

-- Render the input line with selection highlighting.
-- Called after any selection change.
-- nPromptLen = number of visible chars in the prompt (before the input buffer).
local function fSelRender(ext)
  if not g_oGpuProxy then return end
  if not ext.pPendingReadIrp then return end
  if ext.nScrollOffset > 0 then return end

  local sBuf = ext.sLineBuffer or ""
  local nLo, nHi = fSelGetRange(ext)

  -- We need to know where the input buffer starts on screen.
  -- The buffer occupies screen positions starting from the cursor row,
  -- at the column where input began. We approximate by using
  -- (nCursorX - nBufCursorPos) as the start column.
  -- This is the position of the first char of the buffer.
  local nBufScreenCol = ext.nCursorX - (ext.nBufCursorPos or 0)
  if nBufScreenCol < 1 then nBufScreenCol = 1 end
  local nBufScreenRow = ext.nCursorY

  -- Render each buffer character
  for i = 1, #sBuf do
    local nCol = nBufScreenCol + i - 1
    if nCol > ext.nWidth then break end

    local sChar = sBuf:sub(i, i)
    local bSelected = nLo and (i > nLo and i <= nHi)

    if bSelected then
      g_oGpuProxy.setForeground(DEFAULT_BG)
      g_oGpuProxy.setBackground(0x3399FF)  -- blue highlight
    else
      local nFg = (ext.tScreenFg[nBufScreenRow] and ext.tScreenFg[nBufScreenRow][nCol]) or DEFAULT_FG
      local nBg = (ext.tScreenBg[nBufScreenRow] and ext.tScreenBg[nBufScreenRow][nCol]) or DEFAULT_BG
      g_oGpuProxy.setForeground(nFg)
      g_oGpuProxy.setBackground(nBg)
    end
    g_oGpuProxy.set(nCol, nBufScreenRow, sChar)
  end

  -- Restore write colors
  g_oGpuProxy.setForeground(ext.nCurrentFg)
  g_oGpuProxy.setBackground(ext.nCurrentBg)
end

-- =============================================
-- 5. KEY PROCESSING
-- =============================================

local function processKeyCooked(ext, ch, code)
  if code == 201 then
    fScrollUp(ext, math.max(1, math.floor(ext.nHeight / 2))); return true
  elseif code == 209 then
    fScrollDown(ext, math.max(1, math.floor(ext.nHeight / 2))); return true
  end

  fSnapToBottom(ext)

  if not ext.pPendingReadIrp then
    if code == 199 then fScrollUp(ext, #ext.tScrollback); return true end
    if code == 207 then fSnapToBottom(ext); return true end
    return false
  end

  fHideCursor(ext)

  if ext.nBufCursorPos == nil then
    ext.nBufCursorPos = #(ext.sLineBuffer or "")
  end

  local sBuf = ext.sLineBuffer or ""
  local nCur = ext.nBufCursorPos
  local bHandled = false
  local bIrpDone = false
  local bShift = fIsShiftHeld(ext)
  local bCtrl  = fIsCtrlHeld(ext)
  local tSel   = ext.tSel

  local function reRender(sText, nBacktrack)
    if #sText > 0 then writeToScreen(g_pDeviceObject, sText) end
    if nBacktrack > 0 then
      writeToScreen(g_pDeviceObject, "\27[" .. nBacktrack .. "D")
    end
  end

  -- Helper: start or extend selection
  local function selExtend(nNewCursorPos)
    if not tSel.bActive then
      tSel.bActive = true
      tSel.nAnchor = nCur
    end
    tSel.nEnd = nNewCursorPos
  end

  -- Helper: clear selection on non-shift navigation or typing
  local function selClearIfNeeded()
    if tSel.bActive and not bShift then
      fSelClear(ext)
      fSelRender(ext)  -- un-highlight
    end
  end

  -- =============================================
  -- Ctrl+C: copy selection OR send interrupt
  -- =============================================
  if code == 46 and ch == 3 then
    if tSel.bActive then
      -- Copy selection to clipboard
      ext.sClipboard = fSelGetText(ext)
      fSelClear(ext)
      fSelRender(ext)
      bHandled = true
    else
      -- Normal Ctrl+C interrupt
      local pIrp = ext.pPendingReadIrp
      if pIrp then
        ext.pPendingReadIrp = nil
        ext.sLineBuffer = ""
        ext.nBufCursorPos = 0
        fSelClear(ext)
        oKMD.DkCompleteRequest(pIrp, 0, "\3")
        writeToScreen(g_pDeviceObject, "^C\n")
      end
      bHandled = true; bIrpDone = true
    end

  -- =============================================
  -- ENTER
  -- =============================================
  elseif code == 28 then
    fSelClear(ext)
    local pIrp = ext.pPendingReadIrp
    ext.pPendingReadIrp = nil
    ext.sLineBuffer = ""
    ext.nBufCursorPos = 0
    writeToScreen(g_pDeviceObject, "\n")
    oKMD.DkCompleteRequest(pIrp, 0, sBuf)
    bHandled = true; bIrpDone = true

  -- =============================================
  -- BACKSPACE
  -- =============================================
  elseif code == 14 then
    if tSel.bActive then
      -- Delete selected text
      local nLo, nHi = fSelGetRange(ext)
      ext.sLineBuffer = sBuf:sub(1, nLo) .. sBuf:sub(nHi + 1)
      ext.nBufCursorPos = nLo
      fSelClear(ext)
      -- Redraw from selection start
      local nBack = nCur - nLo
      if nBack > 0 then writeToScreen(g_pDeviceObject, "\27[" .. nBack .. "D") end
      local sTail = ext.sLineBuffer:sub(nLo + 1) .. string.rep(" ", nHi - nLo)
      reRender(sTail, #sTail)
    elseif nCur > 0 then
      ext.sLineBuffer = sBuf:sub(1, nCur - 1) .. sBuf:sub(nCur + 1)
      ext.nBufCursorPos = nCur - 1
      writeToScreen(g_pDeviceObject, "\27[D")
      local sTail = ext.sLineBuffer:sub(nCur) .. " "
      reRender(sTail, #sTail)
    end
    bHandled = true

  -- =============================================
  -- DELETE
  -- =============================================
  elseif code == 211 then
    if tSel.bActive then
      local nLo, nHi = fSelGetRange(ext)
      ext.sLineBuffer = sBuf:sub(1, nLo) .. sBuf:sub(nHi + 1)
      ext.nBufCursorPos = nLo
      fSelClear(ext)
      local nBack = nCur - nLo
      if nBack > 0 then writeToScreen(g_pDeviceObject, "\27[" .. nBack .. "D") end
      local sTail = ext.sLineBuffer:sub(nLo + 1) .. string.rep(" ", nHi - nLo)
      reRender(sTail, #sTail)
    elseif nCur < #sBuf then
      ext.sLineBuffer = sBuf:sub(1, nCur) .. sBuf:sub(nCur + 2)
      local sTail = ext.sLineBuffer:sub(nCur + 1) .. " "
      reRender(sTail, #sTail)
    end
    bHandled = true

  -- =============================================
  -- LEFT ARROW (+ Shift = select)
  -- =============================================
  elseif code == 203 then
    if nCur > 0 then
      if bShift then
        selExtend(nCur - 1)
      else
        selClearIfNeeded()
      end
      ext.nBufCursorPos = nCur - 1
      writeToScreen(g_pDeviceObject, "\27[D")
      if tSel.bActive then fSelRender(ext) end
    end
    bHandled = true

  -- =============================================
  -- RIGHT ARROW (+ Shift = select)
  -- =============================================
  elseif code == 205 then
    if nCur < #sBuf then
      if bShift then
        selExtend(nCur + 1)
      else
        selClearIfNeeded()
      end
      ext.nBufCursorPos = nCur + 1
      writeToScreen(g_pDeviceObject, "\27[C")
      if tSel.bActive then fSelRender(ext) end
    end
    bHandled = true

  -- =============================================
  -- HOME (+ Shift = select to start)
  -- =============================================
  elseif code == 199 then
    if bShift then
      selExtend(0)
    else
      selClearIfNeeded()
    end
    if nCur > 0 then
      writeToScreen(g_pDeviceObject, "\27[" .. nCur .. "D")
      ext.nBufCursorPos = 0
    end
    if tSel.bActive then fSelRender(ext) end
    bHandled = true

  -- =============================================
  -- END (+ Shift = select to end)
  -- =============================================
  elseif code == 207 then
    local nToEnd = #sBuf - nCur
    if bShift then
      selExtend(#sBuf)
    else
      selClearIfNeeded()
    end
    if nToEnd > 0 then
      writeToScreen(g_pDeviceObject, "\27[" .. nToEnd .. "C")
      ext.nBufCursorPos = #sBuf
    end
    if tSel.bActive then fSelRender(ext) end
    bHandled = true

  -- =============================================
  -- TAB
  -- =============================================
  elseif code == 15 then
    fSelClear(ext)
    local nToEnd = #sBuf - nCur
    if nToEnd > 0 then
      writeToScreen(g_pDeviceObject, "\27[" .. nToEnd .. "C")
    end
    local pIrp = ext.pPendingReadIrp
    ext.pPendingReadIrp = nil
    ext.sLineBuffer = ""
    ext.nBufCursorPos = 0
    oKMD.DkCompleteRequest(pIrp, 0, "\t" .. sBuf)
    bHandled = true; bIrpDone = true

  -- =============================================
  -- UP / DOWN (history)
  -- =============================================
  elseif code == 200 or code == 208 then
    fSelClear(ext)
    local nToEnd = #sBuf - nCur
    if nToEnd > 0 then
      writeToScreen(g_pDeviceObject, "\27[" .. nToEnd .. "C")
    end
    local sPrefix = (code == 200) and "\27[A" or "\27[B"
    local pIrp = ext.pPendingReadIrp
    ext.pPendingReadIrp = nil
    ext.sLineBuffer = ""
    ext.nBufCursorPos = 0
    oKMD.DkCompleteRequest(pIrp, 0, sPrefix .. sBuf)
    bHandled = true; bIrpDone = true

  -- =============================================
  -- PRINTABLE CHARACTER
  -- =============================================
  elseif code ~= 0 and ch > 0 and ch < 256 then
    -- If selection active, delete selected text first
    if tSel.bActive then
      local nLo, nHi = fSelGetRange(ext)
      sBuf = sBuf:sub(1, nLo) .. sBuf:sub(nHi + 1)
      nCur = nLo
      ext.nBufCursorPos = nLo
      fSelClear(ext)
      -- Move screen cursor to selection start
      local nBack = (ext.nBufCursorPos or 0) -- already at nLo
      -- We need to visually reposition. This is approximate:
      -- Move cursor left by (old nCur - nLo) positions
      local nMoveLeft = (ext.nBufCursorPos or 0)
      -- Actually, the cursor was at old nCur on screen. We need to go to nLo.
      -- We already set nCur = nLo above.
    end

    local s = string.char(ch)
    ext.sLineBuffer = sBuf:sub(1, nCur) .. s .. sBuf:sub(nCur + 1)
    ext.nBufCursorPos = nCur + 1

    if nCur >= #sBuf then
      writeToScreen(g_pDeviceObject, s)
    else
      local sTail = ext.sLineBuffer:sub(nCur + 1)
      writeToScreen(g_pDeviceObject, sTail)
      local nBack = #sTail - 1
      if nBack > 0 then
        writeToScreen(g_pDeviceObject, "\27[" .. nBack .. "D")
      end
    end
    bHandled = true
  end

  -- Single exit: redraw cursor if read still active
  if not bIrpDone then
    fShowCursor(ext)
  end

  return bHandled
end

local function processKeyRaw(ext, ch, code)
  if not ext.pPendingReadIrp then return false end
  local sResult = nil

  if code == 28 then      sResult = "\n"       -- Enter
  elseif code == 14 then  sResult = "\b"       -- Backspace
  elseif code == 15 then  sResult = "\t"       -- Tab
  elseif code == 1 then   sResult = "\27"      -- Escape
  elseif code == 200 then sResult = "\27[A"    -- Up
  elseif code == 208 then sResult = "\27[B"    -- Down
  elseif code == 203 then sResult = "\27[D"    -- Left
  elseif code == 205 then sResult = "\27[C"    -- Right
  elseif code == 201 then sResult = "\27[5~"   -- PgUp
  elseif code == 209 then sResult = "\27[6~"   -- PgDn
  elseif code == 199 then sResult = "\27[H"    -- Home
  elseif code == 207 then sResult = "\27[F"    -- End
  elseif code == 46 and ch == 3 then sResult = "\3" -- Ctrl+C
  elseif code == 59 then  sResult = "\27[11~"  -- F1
  elseif code == 60 then  sResult = "\27[12~"  -- F2
  elseif code == 61 then  sResult = "\27[13~"  -- F3
  elseif code == 62 then  sResult = "\27[14~"  -- F4
  elseif code == 63 then  sResult = "\27[15~"  -- F5
  elseif ch > 0 and ch < 256 then
    sResult = string.char(ch)
  end

  if sResult then
    local pIrp = ext.pPendingReadIrp
    ext.pPendingReadIrp = nil
    oKMD.DkCompleteRequest(pIrp, 0, sResult)
    return true
  end
  -- Redraw cursor at new position after key processing
  fShowCursor(ext)

  return false
end

-- =============================================
-- 6. IRP HANDLERS
-- =============================================

local function fCreate(d, i) oKMD.DkCompleteRequest(i, 0, 0) end
local function fClose(d, i)  oKMD.DkCompleteRequest(i, 0)    end

local function fWrite(d, i)
  local ext = d.pDeviceExtension
  fHideCursor(ext)
  writeToScreen(d, i.tParameters.sData)
  fShowCursor(ext)
  oKMD.DkCompleteRequest(i, 0, #i.tParameters.sData)
end

local function fRead(d, i)
  local p = d.pDeviceExtension
  if p.pPendingReadIrp then
    oKMD.DkCompleteRequest(i, tStatus.STATUS_DEVICE_BUSY)
  else
    p.pPendingReadIrp = i
    if p.sLineBuffer == nil then p.sLineBuffer = "" end
    p.nBufCursorPos = #p.sLineBuffer  -- reset cursor position
    local sMode = p.sMode or "cooked"
    while p.tKeyBuffer and #p.tKeyBuffer > 0 and p.pPendingReadIrp do
      local tKey = table.remove(p.tKeyBuffer, 1)
      if sMode == "raw" then
        processKeyRaw(p, tKey[1], tKey[2])
      else
        processKeyCooked(p, tKey[1], tKey[2])
      end
    end
    -- Show cursor if still waiting for input
    fShowCursor(p)
  end
end

local function fDeviceControl(d, i)
  local ext = d.pDeviceExtension
  local sMethod = i.tParameters.sMethod
  local tArgs = i.tParameters.tArgs or {}

  if sMethod == "set_buffer" then
    ext.sLineBuffer = tArgs[1] or ""
    ext.nBufCursorPos = #ext.sLineBuffer  -- cursor at end
    oKMD.DkCompleteRequest(i, 0)
  elseif sMethod == "get_buffer" then
    oKMD.DkCompleteRequest(i, 0, ext.sLineBuffer or "")
  elseif sMethod == "get_cursor" then
    oKMD.DkCompleteRequest(i, 0, {x = ext.nCursorX, y = ext.nCursorY})
  elseif sMethod == "scroll_up" then
    fScrollUp(ext, tArgs[1] or math.floor(ext.nHeight / 2))
    oKMD.DkCompleteRequest(i, 0)
  elseif sMethod == "get_clipboard" then
    oKMD.DkCompleteRequest(i, 0, ext.sClipboard or "")
  elseif sMethod == "get_selection" then
    if ext.tSel and ext.tSel.bActive then
      oKMD.DkCompleteRequest(i, 0, fSelGetText(ext))
    else
      oKMD.DkCompleteRequest(i, 0, "")
    end
  elseif sMethod == "scroll_down" then
    fScrollDown(ext, tArgs[1] or math.floor(ext.nHeight / 2))
    oKMD.DkCompleteRequest(i, 0)
  elseif sMethod == "scroll_end" then
    fSnapToBottom(ext)
    oKMD.DkCompleteRequest(i, 0)
    elseif sMethod == "set_mode" then
    local sNewMode = tArgs[1]
    if sNewMode == "raw" or sNewMode == "cooked" then
      ext.sMode = sNewMode
      ext.sLineBuffer = ""
      oKMD.DkCompleteRequest(i, 0)
    else
      oKMD.DkCompleteRequest(i, tStatus.STATUS_INVALID_PARAMETER)
    end
  elseif sMethod == "enter_alt_screen" then
    -- Save main screen state
    ext.tMainSave = {
      tRows = ext.tScreenRows,
      tFg   = ext.tScreenFg,
      tBg   = ext.tScreenBg,
      cx    = ext.nCursorX,
      cy    = ext.nCursorY,
      fg    = ext.nCurrentFg,
      bg    = ext.nCurrentBg,
      sb    = ext.tScrollback,
      sbFg  = ext.tScrollbackFg,
      sbBg  = ext.tScrollbackBg,
      so    = ext.nScrollOffset,
    }
    ext.bAltScreen = true
    ext.tScreenRows = {}
    ext.tScreenFg   = {}
    ext.tScreenBg   = {}
    for y = 1, ext.nHeight do
      ext.tScreenRows[y] = string.rep(" ", ext.nWidth)
      ext.tScreenFg[y] = {}
      ext.tScreenBg[y] = {}
    end
    ext.nScrollOffset = 0
    if g_oGpuProxy then
      g_oGpuProxy.setBackground(DEFAULT_BG)
      g_oGpuProxy.setForeground(DEFAULT_FG)
      g_oGpuProxy.fill(1, 1, ext.nWidth, ext.nHeight, " ")
    end
    oKMD.DkCompleteRequest(i, 0)

  elseif sMethod == "leave_alt_screen" then
    if ext.tMainSave then
      ext.tScreenRows  = ext.tMainSave.tRows
      ext.tScreenFg    = ext.tMainSave.tFg
      ext.tScreenBg    = ext.tMainSave.tBg
      ext.nCursorX     = ext.tMainSave.cx
      ext.nCursorY     = ext.tMainSave.cy
      ext.nCurrentFg   = ext.tMainSave.fg
      ext.nCurrentBg   = ext.tMainSave.bg
      ext.tScrollback  = ext.tMainSave.sb
      ext.tScrollbackFg= ext.tMainSave.sbFg
      ext.tScrollbackBg= ext.tMainSave.sbBg
      ext.nScrollOffset= ext.tMainSave.so
      ext.tMainSave = nil
    end
    ext.bAltScreen = false
    fRenderLive(ext)
    oKMD.DkCompleteRequest(i, 0)

  elseif sMethod == "render_batch" then
    -- tArgs = array of {x, y, text, fg, bg}
    -- ONE round-trip, all GPU ops atomic, no ANSI parsing
    if g_oGpuProxy then
      local nLF, nLB = -1, -1
      for _, t in ipairs(tArgs) do
        local nX, nY, sT = t[1], t[2], t[3]
        local nF = t[4] or DEFAULT_FG
        local nB = t[5] or DEFAULT_BG
        if nF ~= nLF then g_oGpuProxy.setForeground(nF); nLF = nF end
        if nB ~= nLB then g_oGpuProxy.setBackground(nB); nLB = nB end
        g_oGpuProxy.set(nX, nY, sT)
        if nY >= 1 and nY <= ext.nHeight then
          fUpdateShadow(ext, nX, nY, sT)
        end
      end
      g_oGpuProxy.setForeground(ext.nCurrentFg)
      g_oGpuProxy.setBackground(ext.nCurrentBg)
    end
    oKMD.DkCompleteRequest(i, 0)

  elseif sMethod == "gpu_fill" then
    -- {x, y, w, h, char, fg, bg}
    if g_oGpuProxy then
      if tArgs[6] then g_oGpuProxy.setForeground(tArgs[6]) end
      if tArgs[7] then g_oGpuProxy.setBackground(tArgs[7]) end
      g_oGpuProxy.fill(tArgs[1] or 1, tArgs[2] or 1,
                        tArgs[3] or 1, tArgs[4] or 1, tArgs[5] or " ")
      g_oGpuProxy.setForeground(ext.nCurrentFg)
      g_oGpuProxy.setBackground(ext.nCurrentBg)
    end
    oKMD.DkCompleteRequest(i, 0)
    
  elseif sMethod == "get_mode" then
    oKMD.DkCompleteRequest(i, 0, ext.sMode or "cooked")
  elseif sMethod == "get_size" then
    oKMD.DkCompleteRequest(i, 0, {w = ext.nWidth, h = ext.nHeight})
  elseif sMethod == "get_scroll_info" then
    oKMD.DkCompleteRequest(i, 0, {
      offset = ext.nScrollOffset,
      max    = #ext.tScrollback,
      height = ext.nHeight,
    })
  else
    oKMD.DkCompleteRequest(i, tStatus.STATUS_NOT_IMPLEMENTED)
  end
end

-- =============================================
-- 7. DRIVER ENTRY
-- =============================================

function DriverEntry(pObj)
  oKMD.DkPrint("AxisTTY v5.1 Color Scrollback Loaded.")
  pObj.tDispatch[tDKStructs.IRP_MJ_CREATE]         = fCreate
  pObj.tDispatch[tDKStructs.IRP_MJ_CLOSE]          = fClose
  pObj.tDispatch[tDKStructs.IRP_MJ_WRITE]          = fWrite
  pObj.tDispatch[tDKStructs.IRP_MJ_READ]           = fRead
  pObj.tDispatch[tDKStructs.IRP_MJ_DEVICE_CONTROL] = fDeviceControl
  g_tDispatchTable = pObj.tDispatch

  local st, dev = oKMD.DkCreateDevice(pObj, "\\Device\\TTY0")
  if st ~= 0 then return st end
  g_pDeviceObject = dev
  oKMD.DkCreateSymbolicLink("/dev/tty", "\\Device\\TTY0")

  local gpu, scr
  local b, l
  b, l = syscall("raw_component_list", "gpu")
  if b and l then for k in pairs(l) do gpu = k; break end end
  b, l = syscall("raw_component_list", "screen")
  if b and l then for k in pairs(l) do scr = k; break end end

  dev.pDeviceExtension.nWidth      = 80
  dev.pDeviceExtension.nHeight     = 25
  dev.pDeviceExtension.nCursorX    = 1
  dev.pDeviceExtension.nCursorY    = 25
  dev.pDeviceExtension.tKeyBuffer  = {}
  dev.pDeviceExtension.sLineBuffer = ""
  dev.pDeviceExtension.sMode = "cooked"

  if gpu then
    local _, p = oKMD.DkGetHardwareProxy(gpu)
    g_oGpuProxy = p
    if scr and p then
      p.bind(scr)
      local w, h = p.getResolution()
      p.setBackground(DEFAULT_BG)
      p.setForeground(DEFAULT_FG)
      if w and h then
        dev.pDeviceExtension.nWidth   = w
        dev.pDeviceExtension.nHeight  = h
        dev.pDeviceExtension.nCursorY = h
      end
    end
  end

  fInitBuffers(dev.pDeviceExtension)
  dev.pDeviceExtension.bAltScreen = false

  -- Keyboard proxy for modifier detection (shift, ctrl)
  local kbd
  b, l = syscall("raw_component_list", "keyboard")
  if b and l then for k in pairs(l) do kbd = k; break end end
  if kbd then
    local _, kp = oKMD.DkGetHardwareProxy(kbd)
    dev.pDeviceExtension.oKbdProxy = kp
  end

  -- Selection state
  dev.pDeviceExtension.tSel = {
    bActive = false,
    nAnchor = 0,     -- buffer index where selection started
    nEnd    = 0,     -- buffer index where selection ends
  }
  dev.pDeviceExtension.sClipboard = ""

  oKMD.DkRegisterInterrupt("key_down")
  oKMD.DkRegisterInterrupt("scroll")
  oKMD.DkRegisterInterrupt("clipboard")
  return 0
end

function DriverUnload() return 0 end

-- =============================================
-- 8. MAIN LOOP
-- =============================================

while true do
  local b, pid, sig, p1, p2, p3, p4, p5 = syscall("signal_pull")
  if b then

    if sig == "driver_init" then
      local s = DriverEntry(p1)
      syscall("signal_send", pid, "driver_init_complete", s, p1)

    elseif sig == "irp_dispatch" then
      local pIrp    = p1
      local fHandler = p2
      if not fHandler and g_tDispatchTable and pIrp and pIrp.nMajorFunction then
        fHandler = g_tDispatchTable[pIrp.nMajorFunction]
      end
      if fHandler then fHandler(g_pDeviceObject, pIrp) end

    elseif sig == "hardware_interrupt" and p1 == "key_down" then
      local ext = g_pDeviceObject and g_pDeviceObject.pDeviceExtension
      if ext then
        local ch, code = p3, p4
        local sMode = ext.sMode or "cooked"

        if sMode == "raw" then
          -- RAW MODE: all keys go to app, mouse scroll still works for scrollback
          if ext.pPendingReadIrp then
            processKeyRaw(ext, ch, code)
          else
            if not ext.tKeyBuffer then ext.tKeyBuffer = {} end
            table.insert(ext.tKeyBuffer, {ch, code})
          end
        else
          -- COOKED MODE: scroll keys work, line editing
          if ext.pPendingReadIrp then
            processKeyCooked(ext, ch, code)
          else
            if code == 201 then
              fScrollUp(ext, math.max(1, math.floor(ext.nHeight / 2)))
            elseif code == 209 then
              fScrollDown(ext, math.max(1, math.floor(ext.nHeight / 2)))
            elseif code == 199 then
              fScrollUp(ext, #ext.tScrollback)
            elseif code == 207 then
              fSnapToBottom(ext)
            else
              fSnapToBottom(ext)
              if not ext.tKeyBuffer then ext.tKeyBuffer = {} end
              table.insert(ext.tKeyBuffer, {ch, code})
            end
          end
        end
      end
  elseif sig == "hardware_interrupt" and p1 == "clipboard" then
      local ext = g_pDeviceObject and g_pDeviceObject.pDeviceExtension
      if ext and ext.pPendingReadIrp and p2 and type(p2) == "string" then
        local sText = p2:gsub("[%c]", "")
        if #sText > 0 then
          fHideCursor(ext)
          local sBuf = ext.sLineBuffer or ""
          local nCur = ext.nBufCursorPos or #sBuf
          ext.sLineBuffer = sBuf:sub(1, nCur) .. sText .. sBuf:sub(nCur + 1)
          ext.nBufCursorPos = nCur + #sText
          local sAfter = sText .. ext.sLineBuffer:sub(ext.nBufCursorPos + 1)
          writeToScreen(g_pDeviceObject, sAfter)
          local nBack = #ext.sLineBuffer - ext.nBufCursorPos
          if nBack > 0 then
            writeToScreen(g_pDeviceObject, "\27[" .. nBack .. "D")
          end
          fShowCursor(ext)
        end
      end
    elseif sig == "hardware_interrupt" and p1 == "scroll" then
      local ext = g_pDeviceObject and g_pDeviceObject.pDeviceExtension
      if ext and type(p2) == "number" then
        if p2 > 0 then
          fScrollUp(ext, SCROLL_WHEEL_STEP)
        else
          fScrollDown(ext, SCROLL_WHEEL_STEP)
        end
      end

    end
  end
end
```


axis-os\src\kernel\etc\signing\private.key
```

```


axis-os\src\kernel\etc\autoload.lua
```
--
-- /etc/autoload.lua
-- list of drivers to load automatically at boot.
-- paths must be absolute.
--
return {
  "/drivers/internet.sys.lua",
  -- "/drivers/sound.sys.lua", -- example
}
```


axis-os\src\kernel\etc\fstab.lua
```
-- AxisOS File System Table
return {
  { uuid = "8d390d50-4bc9-4d6d-8f63-c9057f8d20ff", path = "/", mount = "/", type = "rootfs", options = "rw", },
  { uuid = "8d390d50-4bc9-4d6d-8f63-c9057f8d20ff", path = "/home", mount = "/home", type = "homefs", options = "rw,size=3000", },
  { uuid = "8d390d50-4bc9-4d6d-8f63-c9057f8d20ff", path = "/swapfile", mount = "none", type = "swap", options = "size=3000", },
  { uuid = "8d390d50-4bc9-4d6d-8f63-c9057f8d20ff", path = "/log", mount = "/var/log", type = "ringfs", options = "rw,size=3000", },
  { uuid = "virtual", path = "/dev/ringlog", mount = "/var/log/syslog", type = "ringfs", options = "rw,size=8192" },
}

```


axis-os\src\kernel\etc\netpolicy.cfg
```
-- /etc/netpolicy.lua
-- Network security policy. Processed top-to-bottom, first match wins.
-- Actions: "allow", "deny", "log" (allow + log)
--
-- Fields:
--   action   = "allow" | "deny" | "log"
--   proto    = "http" | "tcp" | "any"
--   host     = pattern string (Lua pattern) or "*"
--   port     = number or "*"
--   uid      = number or "*" (user ID)
--   ring     = number or "*"
--   comment  = string
--
return {
  -- Default policies per ring
  { action = "allow", proto = "any", host = "*", port = "*",
    ring = 0, comment = "Ring 0: unrestricted" },
  { action = "allow", proto = "any", host = "*", port = "*",
    ring = 1, comment = "Ring 1: unrestricted" },
  { action = "allow", proto = "any", host = "*", port = "*",
    ring = 2, comment = "Ring 2: unrestricted" },

  -- Block known bad domains
  { action = "deny", proto = "http", host = ".*malware%.example%.com",
    port = "*", ring = "*", comment = "Block malware domain" },

  -- Rate-limit: max 5 concurrent sessions per UID (enforced in driver)
  -- (This is a hint, enforcement is in the policy engine)

  -- Allow HTTP/HTTPS for user-mode
  { action = "allow", proto = "http", host = "*", port = "*",
    ring = 3, comment = "Allow HTTP for Ring 3" },

  -- Block raw TCP for unprivileged users (except port 80/443)
  { action = "allow", proto = "tcp", host = "*", port = 80,
    ring = 3, comment = "TCP 80 allowed" },
  { action = "allow", proto = "tcp", host = "*", port = 443,
    ring = 3, comment = "TCP 443 allowed" },
  { action = "deny", proto = "tcp", host = "*", port = "*",
    ring = 3, comment = "Block other TCP for Ring 3" },

  -- Default: allow everything else
  { action = "allow", proto = "any", host = "*", port = "*",
    ring = "*", comment = "Default allow" },
}
```


axis-os\src\kernel\etc\passwd.lua
```
-- AxisOS Password File
return {
  root = {
    uid = 0,
    home = "/root",
    shell = "/bin/sh.lua",
    hash = "toorAURA_SALT",
    ring = 3 -- root is still user-mode usually
  },
  guest = {
    uid = 1000,
    home = "/home/guest",
    shell = "/bin/sh.lua",
    hash = "tseugAURA_SALT",
    ring = 3
  },
  dev = {
    uid = 0, -- effectively root
    home = "/",
    shell = "/bin/sh.lua",
    hash = "vedAURA_SALT", -- pass: dev
    ring = 0 -- UNLIMITED POWER
  }
}
```


axis-os\src\kernel\etc\perms.lua
```
return {
  ["/boot/kernel.lua"] = { uid = 0, gid = 0, mode = 400 },
  ["/all_code.txt"] = { uid = 1000, gid = 0, mode = 777 },
  ["/etc/perms.lua"] = { uid = 0, gid = 0, mode = 600 },
  ["/dev/tty"]     = { uid=0, gid=0, mode=666 }, -- rw-rw-rw- (everyone needs tty)
  ["/dev/ringlog"] = { uid=0, gid=0, mode=644 }, -- r--r--r-- (read only for users)
  ["/dev/gpu0"]    = { uid=0, gid=0, mode=660 }, -- rw-rw---- (system only)
  ["/etc/passwd.lua"] = { uid = 0, gid = 0, mode = 600 },
  
}
```


axis-os\src\kernel\etc\pki.cfg
```
-- /etc/pki.cfg
-- PKI Cloud Configuration
return {
    api_token = "YOUR_API_TOKEN_HERE",  -- from auth.axis-os.ru
    pki_url = "https://pki.axis-os.ru/api",
    
    security_level = 1,  -- 0=disabled, 1=warn, 2=enforce
    
    -- Cache settings
    cache_ttl = 3600,        -- seconds before re-checking cloud
    sync_on_boot = true,     -- sync approved keys at boot
    
    -- Secure boot
    verify_kernel = true,
    kernel_path = "/kernel.lua",
}
```


axis-os\src\kernel\etc\secureboot.cfg
```
-- /etc/secureboot.cfg
-- Platform Keys for Secure Boot
return {
    -- Platform Key: verifies the kernel
    -- This is the BASE64-encoded ECDSA public key of the kernel signer
    platform_key = "BASE64_ENCODED_PLATFORM_KEY",
    
    -- Expected kernel hash (fallback if no signature)
    kernel_hash = "BASE64_SHA256_OF_KERNEL",
    
    -- Policy
    enforce = true,       -- false = warn only
    allow_offline = true, -- boot with cached verification if cloud down
}
```


axis-os\src\kernel\etc\sys.cfg
```
-- /etc/sys.cfg
return {
  hostname = "AxisBox",
  
  logging = {
    enable_screen_log = true,
    ring_buffer_size = 8192,
    log_device = "/dev/ringlog",
    
    -- Persistent log rotation
    enable_log_rotation_saver = true,
    max_log_files = 5,         -- keep last N sessions
    log_dir = "/log",          -- .log files (INFO+ only)
    vbl_dir = "/vbl",          -- .vbl files (ALL including DEBUG/DEV)
  },
  
  security = {
    allow_guest = true,
    root_login_allowed = true,
  }
}
```


axis-os\src\kernel\home\donut.lua
```
--
-- donut.c but lua
-- slow as hell but it works
--
fs = require("filesystem") tt = fs.open("/dev/tty","w") io = {} io.write = function(...) fs.write(tt, ...) end
            A=0 B=0 z={}b=
         {}E={32,46,44,45,126,
       58,59,61,33,42,35,36,64}S
     =math.sin C=math.cos F=math.
  floor I=io.write T=string.char W=60
  P=print H=25 P("\27[2J")for w=1,240
 do for o=0,W*H do b[o]=1 z[o]=0 end e=
 S(A)g=C(A)m=C(B)n=S(B)for j=0,6.28,.09
 do d=C(j)f=S(j)       for i=0,6.28,.04
do c=S(i)h=d+2 D        =1/(c*h*e+f*g+5)
l=C(i)t=c*h*g-            f*e x=F(W/2+W*
.3*D*(l*h*m-t*n          ))y=F(H/2+H*.6*
 D*(l*h*n+t*m))o        =x+W*y  N=math.
 max(0,F(8*((f*e-c*d*g)*m-c*d*e-f*g -l*
 d *n)))+2 if H> y and y>0 and x>0 and
  W>x and D> z[o] then  z[o]=D b[o]=N
   end end  end P( "\27[H")for k=0
     ,W* H do if k%W~=0 then I(T(
       E[b[k]]))else I( T( 10))
         end end A = A + .04
             B=B+.02 end
```


axis-os\src\kernel\home\ex_nothread.lua
```
--
-- /home/ex_thread.lua
-- The glorious multithreaded future.
-- v2: demonstrates thread.kill, thread.parallel, and thread.alive
--

local thread = require("thread")
local sys = require("syscall")
local computer = require("computer")

local function heavy_task(sName, nTime)
  print(string.format("\27[32m[%s]\27[37m Starting task (%ds)...", sName, nTime))
  
  local nDead = computer.uptime() + nTime
  while computer.uptime() < nDead do
     thread.yield() -- cooperatively yield to other threads
  end
  
  print(string.format("\27[32m[%s]\27[37m Done!", sName))
end

print("--- Multi Threaded Demo (v2) ---")

-- Show our synapse token (sMLTR)
local sToken = sys.getSynapseToken()
if sToken then
  print("\27[90mSynapse Token: " .. sToken:sub(1, 20) .. "...\27[37m")
end

local nStart = computer.uptime()

-- Method 1: Manual thread management
print("\n\27[36m[Test 1] Manual thread create/join\27[37m")
local t1 = thread.create(function() heavy_task("Downloader", 2) end)
local t2 = thread.create(function() heavy_task("Renderer", 2) end)

if t1 and t2 then
  print("Threads spawned. PIDs: " .. t1.pid .. ", " .. t2.pid)
  
  -- Check alive status
  print("t1 alive: " .. tostring(t1:alive()))
  print("t2 alive: " .. tostring(t2:alive()))
  
  t1:join()
  t2:join()
  
  print("t1 alive after join: " .. tostring(t1:alive()))
end

-- Method 2: Parallel helper
print("\n\27[36m[Test 2] thread.parallel()\27[37m")
local nParallelStart = computer.uptime()

thread.parallel({
  function() heavy_task("TaskA", 1) end,
  function() heavy_task("TaskB", 1) end,
  function() heavy_task("TaskC", 1) end,
})

print(string.format("Parallel block took: %.2fs", computer.uptime() - nParallelStart))

-- Method 3: List active threads
print("\n\27[36m[Test 3] Active thread list\27[37m")
local tActive = thread.list()
print("Active threads from parent: " .. #tActive)

local nTotal = computer.uptime() - nStart
print(string.format("\n\27[33mTotal time: %.2f seconds\27[37m", nTotal))
```


axis-os\src\kernel\home\ex_thread.lua
```
--
-- /home/ex_thread.lua
-- The glorious multithreaded future.
--

local thread = require("thread")
local sys = require("syscall")
local computer = require("computer")

local function heavy_task(sName, nTime)
  print(string.format("\27[32m[%s]\27[37m Starting task...", sName))
  
  local nDead = computer.uptime() + nTime
  while computer.uptime() < nDead do
     sys.wait(0) -- yield to let other threads run
  end
  
  print(string.format("\27[32m[%s]\27[37m Done!", sName))
end

print("--- Multi Threaded Demo ---")
local nStart = computer.uptime()

-- Create threads
-- Note: We wrap arguments in a closure because thread.create takes 1 func
local t1 = thread.create(function() heavy_task("Downloader", 2) end)
local t2 = thread.create(function() heavy_task("Renderer", 2) end)

if t1 and t2 then
  print("Threads spawned. Waiting for completion...")
  
  -- Wait for both to finish
  t1:join()
  t2:join()
else
  print("Failed to spawn threads!")
end

local nTotal = computer.uptime() - nStart
print(string.format("Total time: %.2f seconds", nTotal))
```


axis-os\src\kernel\home\iter.lua
```
--
-- /lib/iter.lua
-- User-space library for controlling the ITER Fusion Reactor.
-- This is the safe, friendly remote control. The driver is the guy in the
-- blast suit flipping the actual switches.
--

local oFs = require("filesystem")
if not oFs then error("Filesystem library not available!") end

local oIterApi = {}

-- The reactor device path in the VFS.
local sDevicePath = "/dev/fusion0"

--[[
  Connects to the ITER driver.
  @return table A handle to the reactor, or nil and an error message.
]]
function oIterApi.open()
  local hDevice, sErr = oFs.open(sDevicePath, "r") -- mode doesn't matter much here
  if not hDevice then
    return nil, "Failed to open ITER device: " .. tostring(sErr)
  end
  
  local tReactorHandle = {
    _handle = hDevice,
  }
  
  -- This is the magic function that sends a command to the driver.
  -- It uses a hypothetical fs.deviceControl, which would map to IRP_MJ_DEVICE_CONTROL.
  -- Your VFS would need to implement this.
  function tReactorHandle:invoke(sMethod, ...)
    if not self._handle then return nil, "Handle is closed" end
    -- The fs.deviceControl function is the user-space bridge to the driver's
    -- fDispatchDeviceControl handler.
    local bOk, tResult, sError = oFs.deviceControl(self._handle, sMethod, {...})
    if bOk then
      return table.unpack(tResult or {})
    else
      return nil, sError
    end
  end
  
  -- Close the connection to the driver.
  function tReactorHandle:close()
    if self._handle then
      oFs.close(self._handle)
      self._handle = nil
    end
  end
  
  -- Helper methods that map directly to the component's API.
  function tReactorHandle:getEnergy() return self:invoke("getEnergyInfo") end
  function tReactorHandle:isActive() return self:invoke("isActive") end
  function tReactorHandle:setActive(bState) return self:invoke("setActive", bState) end
  function tReactorHandle:getFluids() return self:invoke("getFluid") end
  function tReactorHandle:getPlasmaTemp() return self:invoke("getPlasmaTemp") end
  function tReactorHandle:getMaxTemp() return self:invoke("getMaxTemp") end
  function tReactorHandle:getBlanketDamage() return self:invoke("getBlanketDamage") end
  
  setmetatable(tReactorHandle, { __gc = function(self) self:close() end })
  
  return tReactorHandle
end

return oIterApi
```


axis-os\src\kernel\lib\vi\highlight.lua
```
--
-- /lib/vi/highlight.lua
-- xvi Syntax Highlight Engine
--
-- Language files: /lib/vi/lang_<ext>.lua
-- Format:
--   return {
--     name         = "Lua",
--     lineComment  = "--",
--     blockComment = {"--[[", "]]"},    -- or nil
--     operators    = "+-*/%=<>~#.;,",
--     keywords     = { ["if"]=1, ["end"]=1, ... },
--     builtins     = { ["print"]=2, ["nil"]=2, ... },
--   }
-- Category 1 = keyword (blue), 2 = builtin (cyan)
--

local H = {}

-- Palette
H.C_DEFAULT  = 0xFFFFFF
H.C_KEYWORD  = 0x5599FF
H.C_BUILTIN  = 0x55DDDD
H.C_STRING   = 0xDD9955
H.C_NUMBER   = 0x99DD77
H.C_COMMENT  = 0x777777
H.C_OPERATOR = 0xAAAAAA

local tCatColor = {
  [1] = H.C_KEYWORD,
  [2] = H.C_BUILTIN,
}

-- Universal (no lang file needed)
H.UNIVERSAL = {
  name = "Text",
  lineComment  = nil,
  blockComment = nil,
  operators    = "+-*/%=<>!&|^~?:;,.{}()[]#@",
  keywords     = {},
  builtins     = {},
}

local tLangCache = {}

function H.detect(sPath)
  if not sPath then return H.UNIVERSAL end
  local sExt = sPath:match("%.([^%.]+)$")
  if not sExt then return H.UNIVERSAL end
  sExt = sExt:lower()
  -- cfg files are usually Lua tables
  if sExt == "cfg" then sExt = "lua" end
  if tLangCache[sExt] then return tLangCache[sExt] end
  local bOk, tLang = pcall(require, "vi/lang_" .. sExt)
  if bOk and type(tLang) == "table" then
    tLangCache[sExt] = tLang
    return tLang
  end
  tLangCache[sExt] = H.UNIVERSAL
  return H.UNIVERSAL
end

-- =============================================
-- BLOCK COMMENT STATE
-- Returns tState[n] = true if line n starts
-- inside a block comment.
-- =============================================

function H.computeState(tLines, tLang)
  local tState = {}
  if not tLang or not tLang.blockComment then
    for i = 1, #tLines do tState[i] = false end
    return tState
  end

  local sBS = tLang.blockComment[1]
  local sBE = tLang.blockComment[2]
  local sLC = tLang.lineComment
  local bIn = false

  for i = 1, #tLines do
    tState[i] = bIn
    local s = tLines[i]
    local p = 1
    while p <= #s do
      if bIn then
        local e = s:find(sBE, p, true)
        if e then bIn = false; p = e + #sBE
        else break end
      else
        if sBS and p + #sBS - 1 <= #s and s:sub(p, p + #sBS - 1) == sBS then
          bIn = true; p = p + #sBS
        elseif sLC and p + #sLC - 1 <= #s and s:sub(p, p + #sLC - 1) == sLC then
          break
        elseif s:sub(p, p) == '"' or s:sub(p, p) == "'" then
          local q = s:sub(p, p); p = p + 1
          while p <= #s do
            if s:sub(p, p) == '\\' then p = p + 2
            elseif s:sub(p, p) == q then p = p + 1; break
            else p = p + 1 end
          end
        else
          p = p + 1
        end
      end
    end
  end
  return tState
end

-- =============================================
-- HELPERS
-- =============================================

local function isId(b)
  return (b >= 65 and b <= 90) or (b >= 97 and b <= 122)
      or (b >= 48 and b <= 57) or b == 95
end

local function isDig(b) return b >= 48 and b <= 57 end

local function isHex(b)
  return isDig(b) or (b >= 65 and b <= 70) or (b >= 97 and b <= 102)
end

-- =============================================
-- PER-CHARACTER COLORIZE
-- Returns array: tColors[charIndex] = fg_color
-- =============================================

function H.colorize(sLine, tLang, bInBlock)
  local nLen = #sLine
  if nLen == 0 then return {} end

  local tC = {}
  for i = 1, nLen do tC[i] = H.C_DEFAULT end

  local sBS = tLang.blockComment and tLang.blockComment[1]
  local sBE = tLang.blockComment and tLang.blockComment[2]
  local sLC = tLang.lineComment
  local tKW = tLang.keywords or {}
  local tBI = tLang.builtins or {}
  local sOp = tLang.operators or ""
  local p = 1

  local function paint(nFrom, nTo, nColor)
    for i = nFrom, math.min(nTo, nLen) do tC[i] = nColor end
  end

  -- Start inside block comment?
  if bInBlock then
    if sBE then
      local e = sLine:find(sBE, 1, true)
      if e then
        paint(1, e + #sBE - 1, H.C_COMMENT)
        p = e + #sBE
      else
        paint(1, nLen, H.C_COMMENT)
        return tC
      end
    else
      paint(1, nLen, H.C_COMMENT)
      return tC
    end
  end

  while p <= nLen do
    local c = sLine:sub(p, p)
    local b = c:byte()

    -- Block comment start
    if sBS and p + #sBS - 1 <= nLen and sLine:sub(p, p + #sBS - 1) == sBS then
      local nStart = p
      if sBE then
        local e = sLine:find(sBE, p + #sBS, true)
        if e then
          paint(nStart, e + #sBE - 1, H.C_COMMENT)
          p = e + #sBE
        else
          paint(nStart, nLen, H.C_COMMENT)
          p = nLen + 1
        end
      else
        paint(nStart, nLen, H.C_COMMENT)
        p = nLen + 1
      end

    -- Line comment
    elseif sLC and p + #sLC - 1 <= nLen and sLine:sub(p, p + #sLC - 1) == sLC then
      paint(p, nLen, H.C_COMMENT)
      p = nLen + 1

    -- Strings
    elseif c == '"' or c == "'" then
      local nStart = p
      local q = c; p = p + 1
      while p <= nLen do
        if sLine:sub(p, p) == '\\' then p = p + 2
        elseif sLine:sub(p, p) == q then p = p + 1; break
        else p = p + 1 end
      end
      paint(nStart, p - 1, H.C_STRING)

    -- Long strings [[ ]], [=[ ]=]
    elseif c == '[' and p < nLen then
      local nEq = 0
      local nProbe = p + 1
      while nProbe <= nLen and sLine:sub(nProbe, nProbe) == '=' do
        nEq = nEq + 1; nProbe = nProbe + 1
      end
      if nProbe <= nLen and sLine:sub(nProbe, nProbe) == '[' then
        local nStart = p
        local sClose = ']' .. string.rep('=', nEq) .. ']'
        local e = sLine:find(sClose, nProbe + 1, true)
        if e then
          paint(nStart, e + #sClose - 1, H.C_STRING)
          p = e + #sClose
        else
          paint(nStart, nLen, H.C_STRING)
          p = nLen + 1
        end
      else
        tC[p] = H.C_OPERATOR; p = p + 1
      end

    -- Numbers
    elseif isDig(b) or (c == '.' and p < nLen and isDig(sLine:byte(p + 1))) then
      local nStart = p
      if c == '0' and p < nLen and (sLine:sub(p+1,p+1) == 'x' or sLine:sub(p+1,p+1) == 'X') then
        p = p + 2
        while p <= nLen and isHex(sLine:byte(p)) do p = p + 1 end
      else
        while p <= nLen and (isDig(sLine:byte(p)) or sLine:sub(p,p) == '.') do p = p + 1 end
        if p <= nLen and (sLine:sub(p,p) == 'e' or sLine:sub(p,p) == 'E') then
          p = p + 1
          if p <= nLen and (sLine:sub(p,p) == '+' or sLine:sub(p,p) == '-') then p = p + 1 end
          while p <= nLen and isDig(sLine:byte(p)) do p = p + 1 end
        end
      end
      paint(nStart, p - 1, H.C_NUMBER)

    -- Identifiers
    elseif isId(b) and not isDig(b) then
      local nStart = p
      while p <= nLen and isId(sLine:byte(p)) do p = p + 1 end
      local sWord = sLine:sub(nStart, p - 1)
      local nCat = tKW[sWord] or tBI[sWord]
      if nCat then paint(nStart, p - 1, tCatColor[nCat] or H.C_KEYWORD) end

    -- Operators
    elseif sOp:find(c, 1, true) then
      tC[p] = H.C_OPERATOR; p = p + 1

    else
      p = p + 1
    end
  end

  return tC
end

-- =============================================
-- VISIBLE SEGMENTS
-- Takes a full line, returns {text, fg, bg}
-- segments for the visible [nLeft..nLeft+nW-1] range.
-- Groups same-color runs.
-- =============================================

function H.segments(sLine, nLeft, nW, tLang, bInBlock)
  local tColors = H.colorize(sLine, tLang, bInBlock)
  local tOut = {}
  local nEnd = math.min(nLeft + nW - 1, #sLine)

  if nLeft > #sLine then
    return {{string.rep(" ", nW), H.C_DEFAULT, 0x000000}}
  end

  local nRun = nLeft
  while nRun <= nEnd do
    local nC = tColors[nRun] or H.C_DEFAULT
    local nRunEnd = nRun
    while nRunEnd < nEnd and (tColors[nRunEnd + 1] or H.C_DEFAULT) == nC do
      nRunEnd = nRunEnd + 1
    end
    tOut[#tOut + 1] = {sLine:sub(nRun, nRunEnd), nC, 0x000000}
    nRun = nRunEnd + 1
  end

  local nUsed = nEnd - nLeft + 1
  if nUsed < nW then
    tOut[#tOut + 1] = {string.rep(" ", nW - nUsed), H.C_DEFAULT, 0x000000}
  end

  return tOut
end

return H
```


axis-os\src\kernel\lib\vi\lang_c.lua
```
-- /lib/vi/lang_c.lua
-- C/C++ syntax definition for xvi
return {
  name = "C",
  lineComment  = "//",
  blockComment = {"/*", "*/"},
  operators    = "+-*/%=<>!&|^~?:;,.{}()[]",
  keywords = {
    ["if"]=1, ["else"]=1, ["while"]=1, ["for"]=1, ["do"]=1,
    ["switch"]=1, ["case"]=1, ["default"]=1, ["break"]=1,
    ["continue"]=1, ["return"]=1, ["goto"]=1, ["typedef"]=1,
    ["struct"]=1, ["union"]=1, ["enum"]=1, ["sizeof"]=1,
    ["static"]=1, ["extern"]=1, ["const"]=1, ["volatile"]=1,
    ["register"]=1, ["inline"]=1, ["class"]=1, ["public"]=1,
    ["private"]=1, ["protected"]=1, ["virtual"]=1, ["namespace"]=1,
    ["using"]=1, ["template"]=1, ["new"]=1, ["delete"]=1,
    ["try"]=1, ["catch"]=1, ["throw"]=1, ["auto"]=1,
  },
  builtins = {
    ["int"]=2, ["char"]=2, ["float"]=2, ["double"]=2, ["void"]=2,
    ["long"]=2, ["short"]=2, ["unsigned"]=2, ["signed"]=2,
    ["bool"]=2, ["true"]=2, ["false"]=2, ["NULL"]=2, ["nullptr"]=2,
    ["size_t"]=2, ["uint8_t"]=2, ["uint16_t"]=2, ["uint32_t"]=2,
    ["int8_t"]=2, ["int16_t"]=2, ["int32_t"]=2, ["int64_t"]=2,
    ["printf"]=2, ["scanf"]=2, ["malloc"]=2, ["free"]=2,
    ["memcpy"]=2, ["strlen"]=2, ["strcmp"]=2, ["strcpy"]=2,
    ["stdout"]=2, ["stderr"]=2, ["stdin"]=2,
    ["include"]=2, ["define"]=2, ["ifdef"]=2, ["ifndef"]=2,
    ["endif"]=2, ["elif"]=2, ["pragma"]=2, ["undef"]=2,
    ["string"]=2, ["vector"]=2, ["map"]=2, ["cout"]=2, ["cin"]=2,
  },
}
```


axis-os\src\kernel\lib\vi\lang_lua.lua
```
-- /lib/vi/lang_lua.lua
-- Lua syntax definition for xvi
return {
  name = "Lua",
  lineComment  = "--",
  blockComment = {"--[[", "]]"},
  operators    = "+-*/%^=<>~#.;,:{}()[]",
  keywords = {
    ["if"]=1, ["then"]=1, ["else"]=1, ["elseif"]=1, ["end"]=1,
    ["do"]=1, ["while"]=1, ["for"]=1, ["repeat"]=1, ["until"]=1,
    ["break"]=1, ["return"]=1, ["function"]=1, ["local"]=1,
    ["in"]=1, ["goto"]=1, ["and"]=1, ["or"]=1, ["not"]=1,
  },
  builtins = {
    ["true"]=2, ["false"]=2, ["nil"]=2, ["self"]=2,
    ["print"]=2, ["require"]=2, ["pcall"]=2, ["xpcall"]=2,
    ["type"]=2, ["tostring"]=2, ["tonumber"]=2, ["error"]=2,
    ["pairs"]=2, ["ipairs"]=2, ["next"]=2, ["select"]=2,
    ["assert"]=2, ["unpack"]=2, ["rawset"]=2, ["rawget"]=2,
    ["setmetatable"]=2, ["getmetatable"]=2,
    ["table"]=2, ["string"]=2, ["math"]=2, ["io"]=2, ["os"]=2,
    ["coroutine"]=2, ["debug"]=2, ["load"]=2, ["loadfile"]=2,
    ["syscall"]=2, ["computer"]=2, ["component"]=2,
    ["env"]=2, ["raw_computer"]=2, ["raw_component"]=2,
  },
}
```


axis-os\src\kernel\lib\vi\lang_sh.lua
```
-- /lib/vi/lang_sh.lua
-- Shell script syntax for xvi
return {
  name = "Shell",
  lineComment  = "#",
  blockComment = nil,
  operators    = "=|&;><(){}[]!$",
  keywords = {
    ["if"]=1, ["then"]=1, ["else"]=1, ["elif"]=1, ["fi"]=1,
    ["for"]=1, ["while"]=1, ["do"]=1, ["done"]=1,
    ["case"]=1, ["esac"]=1, ["in"]=1, ["function"]=1,
    ["return"]=1, ["break"]=1, ["continue"]=1, ["exit"]=1,
    ["local"]=1, ["export"]=1, ["readonly"]=1,
  },
  builtins = {
    ["echo"]=2, ["cd"]=2, ["ls"]=2, ["cat"]=2, ["rm"]=2,
    ["cp"]=2, ["mv"]=2, ["mkdir"]=2, ["chmod"]=2, ["chown"]=2,
    ["grep"]=2, ["sed"]=2, ["awk"]=2, ["find"]=2, ["xargs"]=2,
    ["true"]=2, ["false"]=2, ["test"]=2, ["source"]=2, ["exec"]=2,
    ["read"]=2, ["shift"]=2, ["set"]=2, ["unset"]=2, ["eval"]=2,
  },
}
```


axis-os\src\kernel\lib\attestation.lua
```
-- /lib/attestation.lua
-- Machine Remote Attestation for AxisOS
-- Proves to the cloud that THIS specific machine is running
-- unmodified software on genuine hardware.

local crypto = require("crypto")
local http = require("http")

local oAttest = {}

local ATTEST_URL = "https://pki.axis-os.ru/api/attest.php"

--[[
  ATTESTATION FLOW:
  
  1. Machine → Cloud:  "I am machine X, give me a challenge"
  2. Cloud → Machine:  nonce (random 32 bytes, valid for 30 seconds)
  3. Machine:
     a) Collects: machine_binding, kernel_hash, component_list
     b) Signs: SHA256(nonce .. binding .. kernel_hash .. components)
     c) Signs with data card's ECDSA private key
  4. Machine → Cloud:  {signed_attestation, public_key, component_data}
  5. Cloud:
     a) Verify nonce is fresh
     b) Verify ECDSA signature with registered public key
     c) Compare kernel_hash with expected (from PKI database)
     d) Compare binding with registered machine
  6. Cloud → Machine:  {status: "attested", token: "session_token"}
  
  The session_token can then be used for:
  - Driver downloads
  - CRL updates
  - Telemetry submission
  - Certificate renewal
]]

function oAttest.CollectEvidence()
    -- Gather all measurable system state
    local bOk, nTier = crypto.Init()
    if not bOk then return nil, "No data card" end
    
    local evidence = {
        timestamp = os.clock(),
    }
    
    -- Machine binding (from boot_security if available)
    if _G.boot_security then
        evidence.machine_binding = _G.boot_security.machine_binding
        evidence.kernel_hash = _G.boot_security.kernel_hash
        evidence.data_card_addr = _G.boot_security.data_card_addr
        evidence.sealed = _G.boot_security.sealed
        evidence.verified = _G.boot_security.verified
    end
    
    -- Component inventory
    local tComponents = {}
    local bListOk, tList = pcall(function()
        local t = {}
        for addr, ctype in component.list() do
            t[addr] = ctype
        end
        return t
    end)
    if bListOk and tList then
        for addr, ctype in pairs(tList) do
            tComponents[#tComponents+1] = ctype .. ":" .. addr:sub(1,8)
        end
        table.sort(tComponents)
    end
    evidence.components = table.concat(tComponents, ",")
    
    -- Compute evidence hash
    local sEvidenceString = (evidence.machine_binding or "UNKNOWN") ..
                            (evidence.kernel_hash or "UNKNOWN") ..
                            evidence.components
    evidence.evidence_hash = crypto.Encode64(crypto.SHA256(sEvidenceString))
    
    return evidence
end

function oAttest.RequestChallenge(sMachineId)
    local resp = http.post(ATTEST_URL,
        '{"action":"challenge","machine_id":"' .. (sMachineId or "unknown") .. '"}',
        {["Content-Type"] = "application/json"})
    
    if resp.code == 200 and resp.body then
        local nonce = resp.body:match('"nonce"%s*:%s*"([^"]+)"')
        local challenge_id = resp.body:match('"challenge_id"%s*:%s*"([^"]+)"')
        return nonce, challenge_id
    end
    return nil, "Challenge request failed"
end

function oAttest.Attest(sApiToken)
    if not sApiToken then
        -- Try loading from config
        local pki = require("pki_client")
        pki.LoadConfig()
    end
    
    -- Step 1: Collect evidence
    local evidence, sErr = oAttest.CollectEvidence()
    if not evidence then return nil, sErr end
    
    -- Step 2: Get challenge from cloud
    local sNonce, sChallengeId = oAttest.RequestChallenge(
        evidence.machine_binding or "new")
    if not sNonce then return nil, "No challenge: " .. tostring(sChallengeId) end
    
    -- Step 3: Sign the evidence + nonce
    local sPayload = sNonce ..
                     (evidence.machine_binding or "") ..
                     (evidence.kernel_hash or "") ..
                     evidence.components
    
    local nTier = crypto.GetTier()
    local sSigB64 = "UNSIGNED"
    local sPubKeyB64 = ""
    
    if nTier >= 3 then
        -- Load machine signing key
        local fs = require("filesystem")
        local hPriv = fs.open("/etc/signing/private.key", "r")
        local hPub = fs.open("/etc/signing/public.key", "r")
        
        if hPriv and hPub then
            local sPriv = fs.read(hPriv, math.huge)
            sPubKeyB64 = fs.read(hPub, math.huge)
            fs.close(hPriv)
            fs.close(hPub)
            
            local oPrivKey = crypto.DeserializeKey(sPriv, "ec-private")
            if oPrivKey then
                local sSig = crypto.Sign(sPayload, oPrivKey)
                sSigB64 = crypto.Encode64(sSig)
            end
        end
    end
    
    -- Step 4: Submit attestation
    local sBody = string.format(
        '{"action":"attest","challenge_id":"%s","nonce":"%s",' ..
        '"signature":"%s","public_key":"%s",' ..
        '"machine_binding":"%s","kernel_hash":"%s",' ..
        '"components":"%s","sealed":%s,"verified":%s}',
        sChallengeId, sNonce, sSigB64, sPubKeyB64,
        evidence.machine_binding or "UNKNOWN",
        evidence.kernel_hash or "UNKNOWN",
        evidence.components,
        evidence.sealed and "true" or "false",
        evidence.verified and "true" or "false"
    )
    
    local resp = http.post(ATTEST_URL, sBody,
        {["Content-Type"] = "application/json",
         ["X-API-Token"] = sApiToken or ""})
    
    if resp.code == 200 and resp.body then
        local status = resp.body:match('"status"%s*:%s*"([^"]+)"')
        local token = resp.body:match('"session_token"%s*:%s*"([^"]+)"')
        
        if status == "attested" then
            return {
                status = "attested",
                session_token = token,
                evidence = evidence
            }
        end
        return nil, "Attestation rejected: " .. (status or "unknown")
    end
    
    return nil, "Attestation HTTP failed: " .. resp.code
end

-- Runtime integrity check — can be called periodically
function oAttest.VerifyRuntime()
    local fs = require("filesystem")
    local bOk = crypto.Init()
    if not bOk then return false, "No crypto" end
    
    local tResults = {}
    
    -- Re-hash kernel
    local sKernHash = crypto.HashFile("/kernel.lua", nil)
    if _G.boot_security and _G.boot_security.kernel_hash then
        if crypto.Encode64(sKernHash) ~= _G.boot_security.kernel_hash then
            tResults.kernel_modified = true
        end
    end
    
    -- Check manifest
    local hMan = fs.open("/boot/manifest.sig", "r")
    if hMan then
        local sManifest = fs.read(hMan, math.huge)
        fs.close(hMan)
        local sData = sManifest:match("^(.-)%-%-@MANIFEST_SIG") or sManifest
        local fParse = load(sData:gsub("%s+$", ""), "manifest", "t", {})
        if fParse then
            local tManifest = fParse()
            local nModified = 0
            for _, entry in ipairs(tManifest) do
                local h = fs.open(entry.path, "r")
                if h then
                    local d = fs.read(h, math.huge)
                    fs.close(h)
                    local sHash = crypto.Encode64(crypto.SHA256(d))
                    if sHash ~= entry.hash then
                        nModified = nModified + 1
                        tResults[entry.path] = "modified"
                    end
                end
            end
            tResults.files_modified = nModified
        end
    end
    
    local bClean = not tResults.kernel_modified and
                   (tResults.files_modified or 0) == 0
    
    return bClean, tResults
end

return oAttest
```


axis-os\src\kernel\lib\axfs_core.lua
```
--
-- /lib/axfs_core.lua
-- AXFS: AxisOS Inode Filesystem
--
local B = require("bpack")
local AX = {}

AX.MAGIC = "AXFS"
AX.VERSION = 1
AX.MAX_INODES = 256
AX.INODE_SZ = 64
AX.DIRENT_SZ = 32
AX.NAME_MAX = 27
AX.NDIR = 10       -- direct block pointers
AX.ROOT = 1        -- root inode number

AX.FREE = 0; AX.FILE = 1; AX.DIR = 2; AX.LINK = 3

-- Layout: sect 0=super, 1=ibmp, 2=bbmp, 3..3+N-1=itable, 3+N..end=data
local function layout(nSS)
  local ips = math.floor(nSS / AX.INODE_SZ)
  local its = math.ceil(AX.MAX_INODES / ips)
  return { ips=ips, its=its, ds=3+its, dpb=math.floor(nSS/AX.DIRENT_SZ), ppb=math.floor(nSS/2) }
end

-- =============================================
-- DISK WRAPPERS
-- =============================================

function AX.wrapDrive(oProxy, nOff, nCnt)
  local ss = oProxy.getSectorSize()
  nOff = nOff or 0
  nCnt = nCnt or math.floor(oProxy.getCapacity() / ss)
  return {
    sectorSize = ss, sectorCount = nCnt,
    readSector  = function(n) return oProxy.readSector(nOff+n+1) end,
    writeSector = function(n,d)
      d = B.pad(d,ss); return oProxy.writeSector(nOff+n+1, d:sub(1,ss))
    end,
  }
end

function AX.wrapDevice(hDev, oFs, nOff, nCnt)
  local bI, tI = oFs.deviceControl(hDev, "info", {})
  if not bI then return nil, "No device info" end
  local ss = tI.sectorSize
  nOff = nOff or 0; nCnt = nCnt or tI.sectorCount
  return {
    sectorSize = ss, sectorCount = nCnt,
    readSector = function(n)
      local b, d = oFs.deviceControl(hDev, "read_sector", {nOff+n+1})
      return b and d or nil
    end,
    writeSector = function(n, d)
      d = B.pad(d, ss)
      return oFs.deviceControl(hDev, "write_sector", {nOff+n+1, d:sub(1,ss)})
    end,
  }
end

-- =============================================
-- BITMAP OPS
-- =============================================

local function bget(s,n)
  local by=math.floor(n/8)+1; local bi=n%8
  if by>#s then return false end
  return math.floor(s:byte(by)/(2^bi))%2==1
end

local function bset(s,n,v)
  local by=math.floor(n/8)+1; local bi=n%8
  while by>#s do s=s.."\0" end
  local o=s:byte(by); local m=2^bi
  local nw; if v then nw=o+m*(1-math.floor(o/m)%2) else nw=o-m*(math.floor(o/m)%2) end
  return s:sub(1,by-1)..string.char(nw)..s:sub(by+1)
end

local function bfree(s,mx)
  for i=0,mx-1 do if not bget(s,i) then return i end end
end

-- =============================================
-- INODE PACK/UNPACK
-- =============================================

local function pinode(t)
  local s = B.u16(t.iType or 0)..B.u16(t.mode or 0x1FF)
    ..B.u16(t.uid or 0)..B.u16(t.gid or 0)
    ..B.u32(t.size or 0)..B.u32(t.ctime or 0)..B.u32(t.mtime or 0)
    ..B.u16(t.links or 1)..B.u16(t.nBlk or 0)
  for i=1,AX.NDIR do s=s..B.u16(t.dir and t.dir[i] or 0) end
  s=s..B.u16(t.ind or 0)
  return B.pad(s, AX.INODE_SZ)
end

local function rinode(s,o)
  o=o or 1; if #s<o+AX.INODE_SZ-1 then return nil end
  local t={iType=B.r16(s,o), mode=B.r16(s,o+2), uid=B.r16(s,o+4), gid=B.r16(s,o+6),
    size=B.r32(s,o+8), ctime=B.r32(s,o+12), mtime=B.r32(s,o+16),
    links=B.r16(s,o+20), nBlk=B.r16(s,o+22), dir={}, ind=0}
  for i=1,AX.NDIR do t.dir[i]=B.r16(s,o+24+(i-1)*2) end
  t.ind=B.r16(s,o+44); return t
end

-- =============================================
-- DIRECTORY ENTRY
-- =============================================

local function pde(ino,tp,nm)
  nm=nm:sub(1,AX.NAME_MAX)
  return B.u16(ino)..string.char(tp,#nm)..B.str(nm,28)
end

local function rde(s,o)
  o=o or 1; if #s<o+AX.DIRENT_SZ-1 then return nil end
  return {inode=B.r16(s,o), iType=s:byte(o+2), name=s:sub(o+4, o+3+s:byte(o+3))}
end

-- =============================================
-- SUPERBLOCK
-- =============================================

local function psuper(t,ss)
  local s=AX.MAGIC..string.char(AX.VERSION)..B.u16(t.ss)..B.u32(t.ts)
    ..B.u16(t.mi)..B.u16(t.mb)..B.u16(t.fi)..B.u16(t.fb)..B.u16(t.ds)
    ..B.str(t.label,16)..B.u32(t.ct)..B.u32(t.mt)
  return B.pad(s,ss)
end

local function rsuper(s)
  if not s or #s<46 or s:sub(1,4)~=AX.MAGIC then return nil,"Not AXFS" end
  return {ver=s:byte(5), ss=B.r16(s,6), ts=B.r32(s,8), mi=B.r16(s,12), mb=B.r16(s,14),
    fi=B.r16(s,16), fb=B.r16(s,18), ds=B.r16(s,20), label=B.rstr(s,22,16),
    ct=B.r32(s,38), mt=B.r32(s,42)}
end

-- =============================================
-- FORMAT
-- =============================================

function AX.format(tD, sLabel)
  local ss=tD.sectorSize; local L=layout(ss)
  local mb=math.min(tD.sectorCount-L.ds, ss*8)
  if mb<1 then return nil,"Too small" end
  local now=os.time and os.time() or 0
  local su={ss=ss,ts=tD.sectorCount,mi=AX.MAX_INODES,mb=mb,fi=AX.MAX_INODES-2,
    fb=mb-1,ds=L.ds,label=sLabel or "AxisFS",ct=now,mt=now}
  tD.writeSector(0,psuper(su,ss))
  -- ibmp: mark 0,1 used
  local ib=B.pad("",ss); ib=bset(ib,0,true); ib=bset(ib,1,true)
  tD.writeSector(1,ib)
  -- bbmp: mark 0 used
  local bb=B.pad("",ss); bb=bset(bb,0,true)
  tD.writeSector(2,bb)
  -- clear itable
  local ez=B.pad("",ss)
  for i=0,L.its-1 do tD.writeSector(3+i,ez) end
  -- root inode (1)
  local ri={iType=AX.DIR,mode=0x1FF,uid=0,gid=0,size=AX.DIRENT_SZ*2,
    ctime=now,mtime=now,links=2,nBlk=1,dir={0},ind=0}
  local is=3+math.floor(1/L.ips); local io2=(1%L.ips)*AX.INODE_SZ
  local sd=tD.readSector(is) or ez
  sd=sd:sub(1,io2)..pinode(ri)..sd:sub(io2+AX.INODE_SZ+1)
  tD.writeSector(is,B.pad(sd,ss))
  -- root dir data (block 0)
  local dd=pde(1,AX.DIR,".")..pde(1,AX.DIR,"..")
  tD.writeSector(L.ds,B.pad(dd,ss))
  return true
end

-- =============================================
-- MOUNT → Volume object
-- =============================================

function AX.mount(tD)
  local su,e=rsuper(tD.readSector(0))
  if not su then return nil,e end
  local L=layout(tD.sectorSize)
  local v={d=tD,su=su,L=L,ib=tD.readSector(1),bb=tD.readSector(2),dirty=false}
  setmetatable(v,{__index=AX._V})
  return v
end

AX._V={}

function AX._V:flush()
  if not self.dirty then return end
  self.d.writeSector(1,self.ib); self.d.writeSector(2,self.bb)
  self.su.mt=os.time and os.time() or 0
  self.d.writeSector(0,psuper(self.su,self.d.sectorSize))
  self.dirty=false
end

function AX._V:unmount() self:flush() end

function AX._V:ri(n)
  local s=3+math.floor(n/self.L.ips); local o=(n%self.L.ips)*AX.INODE_SZ
  local sd=self.d.readSector(s); if not sd then return nil end
  return rinode(sd,o+1)
end

function AX._V:wi(n,t)
  local ss=self.d.sectorSize; local s=3+math.floor(n/self.L.ips)
  local o=(n%self.L.ips)*AX.INODE_SZ
  local sd=self.d.readSector(s) or B.pad("",ss)
  sd=sd:sub(1,o)..pinode(t)..sd:sub(o+AX.INODE_SZ+1)
  self.d.writeSector(s,B.pad(sd,ss))
end

function AX._V:ai()
  local n=bfree(self.ib,self.su.mi); if not n then return nil end
  self.ib=bset(self.ib,n,true); self.su.fi=self.su.fi-1; self.dirty=true; return n
end

function AX._V:fi2(n)
  self.ib=bset(self.ib,n,false); self.su.fi=self.su.fi+1; self.dirty=true
end

function AX._V:ab()
  local n=bfree(self.bb,self.su.mb); if not n then return nil end
  self.bb=bset(self.bb,n,true); self.su.fb=self.su.fb-1; self.dirty=true; return n
end

function AX._V:fb(n)
  if not n or n==0 then return end
  self.bb=bset(self.bb,n,false); self.su.fb=self.su.fb+1; self.dirty=true
end

function AX._V:b2s(n) return self.su.ds+n end
function AX._V:rb(n) return self.d.readSector(self:b2s(n)) end
function AX._V:wb(n,d) self.d.writeSector(self:b2s(n),B.pad(d,self.d.sectorSize)) end

function AX._V:blks(t)
  local r={}
  for i=1,math.min(AX.NDIR,t.nBlk) do
    if t.dir[i] and t.dir[i]>0 then r[#r+1]=t.dir[i] end
  end
  if t.nBlk>AX.NDIR and t.ind>0 then
    local si=self:rb(t.ind)
    if si then for i=1,self.L.ppb do
      local p=B.r16(si,(i-1)*2+1); if p>0 then r[#r+1]=p end
    end end
  end
  return r
end

function AX._V:setblk(t,idx,bn)
  if idx<AX.NDIR then t.dir[idx+1]=bn
  else
    if t.ind==0 then
      local ib=self:ab(); if not ib then return false end
      t.ind=ib; self:wb(ib,B.pad("",self.d.sectorSize))
    end
    local sl=idx-AX.NDIR; local si=self:rb(t.ind)
    si=si:sub(1,sl*2)..B.u16(bn)..si:sub(sl*2+3)
    self:wb(t.ind,si)
  end
  t.nBlk=math.max(t.nBlk,idx+1); return true
end

function AX._V:freeblks(t)
  for _,b in ipairs(self:blks(t)) do self:fb(b) end
  if t.ind>0 then self:fb(t.ind) end
end

-- =============================================
-- PATH
-- =============================================

function AX._V:split(p)
  local r={}; for s in p:gmatch("[^/]+") do
    if s==".." then if #r>0 then table.remove(r) end
    elseif s~="." and s~="" then r[#r+1]=s end
  end; return r
end

function AX._V:dlookup(di,nm)
  local tb=self:blks(di)
  for _,bn in ipairs(tb) do
    local sd=self:rb(bn); if sd then
      for i=0,self.L.dpb-1 do
        local e=rde(sd,i*AX.DIRENT_SZ+1)
        if e and e.inode>0 and e.name==nm then return e.inode,e end
      end
    end
  end
end

function AX._V:resolve(p)
  local parts=self:split(p); local c=AX.ROOT
  for _,nm in ipairs(parts) do
    local t=self:ri(c)
    if not t or t.iType~=AX.DIR then return nil,"Not a dir" end
    local ch=self:dlookup(t,nm)
    if not ch then return nil,"Not found: "..nm end; c=ch
  end; return c
end

function AX._V:rpar(p)
  local parts=self:split(p)
  if #parts==0 then return AX.ROOT,"" end
  local base=table.remove(parts); local c=AX.ROOT
  for _,nm in ipairs(parts) do
    local t=self:ri(c)
    if not t or t.iType~=AX.DIR then return nil,nil,"Bad path" end
    local ch=self:dlookup(t,nm)
    if not ch then return nil,nil,"Not found: "..nm end; c=ch
  end; return c,base
end

-- =============================================
-- DIRECTORY OPS
-- =============================================

function AX._V:dadd(di,ci,ct,nm)
  local dt=self:ri(di); if not dt then return false end
  local ent=pde(ci,ct,nm); local dpb=self.L.dpb
  for _,bn in ipairs(self:blks(dt)) do
    local sd=self:rb(bn); if sd then
      for i=0,dpb-1 do local o=i*AX.DIRENT_SZ
        local e=rde(sd,o+1)
        if not e or e.inode==0 then
          sd=sd:sub(1,o)..ent..sd:sub(o+AX.DIRENT_SZ+1)
          self:wb(bn,sd)
          dt.mtime=os.time and os.time() or 0; self:wi(di,dt); return true
        end
      end
    end
  end
  local nb=self:ab(); if not nb then return false,"Full" end
  self:wb(nb,B.pad(ent,self.d.sectorSize))
  self:setblk(dt,dt.nBlk,nb)
  dt.mtime=os.time and os.time() or 0; self:wi(di,dt); return true
end

function AX._V:drem(di,nm)
  local dt=self:ri(di); if not dt then return false end
  for _,bn in ipairs(self:blks(dt)) do
    local sd=self:rb(bn); if sd then
      for i=0,self.L.dpb-1 do local o=i*AX.DIRENT_SZ
        local e=rde(sd,o+1)
        if e and e.inode>0 and e.name==nm then
          sd=sd:sub(1,o)..B.pad("",AX.DIRENT_SZ)..sd:sub(o+AX.DIRENT_SZ+1)
          self:wb(bn,sd); dt.mtime=os.time and os.time() or 0
          self:wi(di,dt); return true
        end
      end
    end
  end; return false
end

-- =============================================
-- PUBLIC API
-- =============================================

function AX._V:listDir(p)
  local n=self:resolve(p or "/"); if not n then return nil,"Not found" end
  local t=self:ri(n); if not t or t.iType~=AX.DIR then return nil,"Not dir" end
  local r={}
  for _,bn in ipairs(self:blks(t)) do
    local sd=self:rb(bn); if sd then
      for i=0,self.L.dpb-1 do
        local e=rde(sd,i*AX.DIRENT_SZ+1)
        if e and e.inode>0 and e.name~="." and e.name~=".." then
          local ci=self:ri(e.inode)
          r[#r+1]={name=e.name,inode=e.inode,iType=e.iType,
            size=ci and ci.size or 0, mode=ci and ci.mode or 0}
        end
      end
    end
  end; return r
end

function AX._V:readFile(p)
  local n=self:resolve(p); if not n then return nil,"Not found" end
  local t=self:ri(n); if not t or t.iType~=AX.FILE then return nil,"Not file" end
  local ch={}; local rem=t.size
  for _,bn in ipairs(self:blks(t)) do
    local sd=self:rb(bn); if sd then
      ch[#ch+1]=sd:sub(1,math.min(rem,self.d.sectorSize)); rem=rem-self.d.sectorSize
    end; if rem<=0 then break end
  end; return table.concat(ch)
end

function AX._V:writeFile(p,data)
  data=data or ""; local di,base,e=self:rpar(p)
  if not di then return false,e end
  if #base==0 or #base>AX.NAME_MAX then return false,"Bad name" end
  local now=os.time and os.time() or 0; local ss=self.d.sectorSize
  local need=math.max(1,math.ceil(#data/ss))
  local pt=self:ri(di); local ex=self:dlookup(pt,base); local ino
  if ex then ino=ex; local old=self:ri(ino); if old then self:freeblks(old) end
  else ino=self:ai(); if not ino then return false,"No inodes" end end
  local t={iType=AX.FILE,mode=0x1B6,uid=0,gid=0,size=#data,
    ctime=now,mtime=now,links=1,nBlk=0,dir={},ind=0}
  local off=1
  for i=0,need-1 do
    local bn=self:ab(); if not bn then self:flush(); return false,"Full" end
    self:setblk(t,i,bn); self:wb(bn,data:sub(off,off+ss-1)); off=off+ss
  end
  self:wi(ino,t)
  if not ex then self:dadd(di,ino,AX.FILE,base) end
  self:flush(); return true
end

function AX._V:removeFile(p)
  local di,base=self:rpar(p); if not di or #base==0 then return false end
  local pt=self:ri(di); local n=self:dlookup(pt,base); if not n then return false,"Not found" end
  local t=self:ri(n); if not t then return false end
  if t.iType==AX.DIR then return false,"Is dir" end
  self:freeblks(t); t.iType=AX.FREE; self:wi(n,t)
  self:fi2(n); self:drem(di,base); self:flush(); return true
end

function AX._V:mkdir(p)
  local di,base,e=self:rpar(p); if not di then return false,e end
  if #base==0 or #base>AX.NAME_MAX then return false,"Bad name" end
  local pt=self:ri(di); if self:dlookup(pt,base) then return false,"Exists" end
  local ino=self:ai(); if not ino then return false,"No inodes" end
  local bn=self:ab(); if not bn then self:fi2(ino); return false,"Full" end
  local now=os.time and os.time() or 0
  local t={iType=AX.DIR,mode=0x1FF,uid=0,gid=0,size=AX.DIRENT_SZ*2,
    ctime=now,mtime=now,links=2,nBlk=1,dir={bn},ind=0}
  self:wi(ino,t)
  self:wb(bn,B.pad(pde(ino,AX.DIR,"..")..pde(di,AX.DIR,".."),self.d.sectorSize))
  -- Fix: . should point to self, .. to parent
  self:wb(bn,B.pad(pde(ino,AX.DIR,".")..pde(di,AX.DIR,".."),self.d.sectorSize))
  self:dadd(di,ino,AX.DIR,base)
  pt.links=pt.links+1; self:wi(di,pt); self:flush(); return true
end

function AX._V:rmdir(p)
  local di,base=self:rpar(p); if not di or #base==0 then return false end
  local pt=self:ri(di); local n=self:dlookup(pt,base); if not n then return false,"Not found" end
  local t=self:ri(n); if not t or t.iType~=AX.DIR then return false,"Not dir" end
  local ents=self:listDir(p); if ents and #ents>0 then return false,"Not empty" end
  self:freeblks(t); t.iType=AX.FREE; self:wi(n,t)
  self:fi2(n); self:drem(di,base)
  pt.links=math.max(1,pt.links-1); self:wi(di,pt); self:flush(); return true
end

function AX._V:stat(p)
  local n=self:resolve(p); if not n then return nil,"Not found" end
  local t=self:ri(n); if not t then return nil,"Read error" end
  t.inode=n; return t
end

function AX._V:rename(op,np)
  local od,ob=self:rpar(op); local nd,nb=self:rpar(np)
  if not od or not nd then return false end
  local ot=self:ri(od); local n=self:dlookup(ot,ob); if not n then return false end
  local t=self:ri(n); self:drem(od,ob); self:dadd(nd,n,t.iType,nb)
  self:flush(); return true
end

function AX._V:info()
  local s=self.su
  return {label=s.label,version=s.ver,sectorSize=s.ss,totalSectors=s.ts,
    maxInodes=s.mi,maxBlocks=s.mb,freeInodes=s.fi,freeBlocks=s.fb,
    dataStart=s.ds,usedKB=math.floor((s.mb-s.fb)*s.ss/1024),
    totalKB=math.floor(s.mb*s.ss/1024)}
end

return AX
```


axis-os\src\kernel\lib\axfs_proxy.lua
```
--
-- /lib/axfs_proxy.lua
-- Makes an AXFS volume look like an OC managed filesystem component.
-- PM, kernel primitive_load, and all file operations work transparently.
--

local AX = require("axfs_core")
local B  = require("bpack")

local P = {}

function P.createProxy(vol, sLabel)
  local tHandles = {}
  local nNextH = 1

  local proxy = {
    address = "axfs-" .. (sLabel or vol.su.label or "root"),
    type = "filesystem",
    _vol = vol,
    _label = sLabel or vol.su.label or "AXFS",
  }

  -- =============================================
  -- open(path, mode) → handle
  -- =============================================
  function proxy.open(sPath, sMode)
    sMode = sMode or "r"
    local sClean = sPath:gsub("//", "/")
    if sClean == "" then sClean = "/" end

    if sMode == "r" then
      local data, err = vol:readFile(sClean)
      if not data then return nil, err end
      local h = nNextH; nNextH = nNextH + 1
      tHandles[h] = {
        path = sClean, mode = "r",
        data = data, pos = 1,
      }
      return h

    elseif sMode == "w" then
      local h = nNextH; nNextH = nNextH + 1
      tHandles[h] = {
        path = sClean, mode = "w",
        chunks = {}, pos = 1,
      }
      return h

    elseif sMode == "a" then
      -- Read existing content first
      local existing = vol:readFile(sClean) or ""
      local h = nNextH; nNextH = nNextH + 1
      tHandles[h] = {
        path = sClean, mode = "w",
        chunks = {existing}, pos = #existing + 1,
      }
      return h

    else
      return nil, "Unsupported mode: " .. tostring(sMode)
    end
  end

  -- =============================================
  -- read(handle, count) → data or nil
  -- =============================================
  function proxy.read(h, nCount)
    local t = tHandles[h]
    if not t then return nil, "Bad handle" end
    if t.mode ~= "r" then return nil, "Not readable" end
    nCount = nCount or math.huge
    if t.pos > #t.data then return nil end
    local nEnd = math.min(t.pos + nCount - 1, #t.data)
    local s = t.data:sub(t.pos, nEnd)
    t.pos = nEnd + 1
    if #s == 0 then return nil end
    return s
  end

  -- =============================================
  -- write(handle, data) → true
  -- =============================================
  function proxy.write(h, sData)
    local t = tHandles[h]
    if not t then return nil, "Bad handle" end
    if t.mode ~= "w" then return nil, "Not writable" end
    t.chunks[#t.chunks + 1] = tostring(sData)
    return true
  end

  -- =============================================
  -- close(handle)
  -- =============================================
  function proxy.close(h)
    local t = tHandles[h]
    if not t then return end
    if t.mode == "w" and #t.chunks > 0 then
      local sAll = table.concat(t.chunks)
      -- Ensure parent directories exist
      local sParts = {}
      for seg in t.path:gmatch("[^/]+") do sParts[#sParts+1] = seg end
      if #sParts > 1 then
        local sDir = ""
        for i = 1, #sParts - 1 do
          sDir = sDir .. "/" .. sParts[i]
          local st = vol:stat(sDir)
          if not st then vol:mkdir(sDir) end
        end
      end
      vol:writeFile(t.path, sAll)
    end
    tHandles[h] = nil
  end

  -- =============================================
  -- list(path) → table of names
  -- =============================================
  function proxy.list(sPath)
    sPath = sPath or "/"
    sPath = sPath:gsub("//", "/")
    if sPath == "" then sPath = "/" end
    local ents, err = vol:listDir(sPath)
    if not ents then return nil, err end
    local r = {}
    for _, e in ipairs(ents) do
      if e.iType == 2 then -- DIR
        r[#r + 1] = e.name .. "/"
      else
        r[#r + 1] = e.name
      end
    end
    table.sort(r)
    return r
  end

  -- =============================================
  -- isDirectory(path)
  -- =============================================
  function proxy.isDirectory(sPath)
    local t = vol:stat(sPath)
    return t and t.iType == 2
  end

  -- =============================================
  -- exists(path)
  -- =============================================
  function proxy.exists(sPath)
    local n = vol:resolve(sPath)
    return n ~= nil
  end

  -- =============================================
  -- makeDirectory(path)
  -- =============================================
  function proxy.makeDirectory(sPath)
    return vol:mkdir(sPath)
  end

  -- =============================================
  -- remove(path)
  -- =============================================
  function proxy.remove(sPath)
    local bOk = vol:removeFile(sPath)
    if not bOk then bOk = vol:rmdir(sPath) end
    return bOk
  end

  -- =============================================
  -- size(path)
  -- =============================================
  function proxy.size(sPath)
    local t = vol:stat(sPath)
    return t and t.size or 0
  end

  -- =============================================
  -- lastModified(path)
  -- =============================================
  function proxy.lastModified(sPath)
    local t = vol:stat(sPath)
    return t and t.mtime or 0
  end

  -- =============================================
  -- rename(from, to)
  -- =============================================
  function proxy.rename(sFrom, sTo)
    return vol:rename(sFrom, sTo)
  end

  -- =============================================
  -- spaceUsed / spaceTotal
  -- =============================================
  function proxy.spaceUsed()
    local t = vol:info()
    return (t.maxBlocks - t.freeBlocks) * t.sectorSize
  end

  function proxy.spaceTotal()
    local t = vol:info()
    return t.maxBlocks * t.sectorSize
  end

  -- =============================================
  -- getLabel / setLabel
  -- =============================================
  function proxy.getLabel()
    return proxy._label
  end

  function proxy.setLabel(s)
    proxy._label = s
    return s
  end

  -- Flush on demand
  function proxy.flush()
    vol:flush()
  end

  return proxy
end

return P
```


axis-os\src\kernel\lib\bpack.lua
```
--
-- /lib/bpack.lua
-- Binary pack/unpack for AXFS and RDB
--
local B = {}

function B.u16(n)
  return string.char(math.floor(n/256)%256, n%256)
end

function B.u32(n)
  return string.char(math.floor(n/16777216)%256, math.floor(n/65536)%256,
                     math.floor(n/256)%256, n%256)
end

function B.r16(s,o)
  o=o or 1; return s:byte(o)*256 + s:byte(o+1)
end

function B.r32(s,o)
  o=o or 1; return s:byte(o)*16777216 + s:byte(o+1)*65536 + s:byte(o+2)*256 + s:byte(o+3)
end

function B.str(s,n)
  if #s>=n then return s:sub(1,n) end
  return s..string.rep("\0",n-#s)
end

function B.rstr(s,o,n)
  local r=s:sub(o,o+n-1); local z=r:find("\0",1,true)
  return z and r:sub(1,z-1) or r
end

function B.pad(s,n)
  if #s>=n then return s:sub(1,n) end
  return s..string.rep("\0",n-#s)
end

return B
```


axis-os\src\kernel\lib\computer.lua
```
--
-- /lib/computer.lua
-- Bridge so that require("computer") returns the OC computer API.
--
return computer
```


axis-os\src\kernel\lib\crypto.lua
```
-- /lib/crypto.lua
-- AxisOS Cryptographic Abstraction Layer
-- Requires: Data Card (Tier 2+ for hashing, Tier 3 for ECDSA)

local oCrypto = {}

local g_oDataCard = nil
local g_nTier = 0

function oCrypto.Init()
    local bOk, tList = pcall(function()
        local t = {}
        for addr, ctype in component.list("data") do t[addr] = ctype end
        return t
    end)
    -- fallback for kernel context where component is raw_component
    if not bOk then
        bOk, tList = pcall(function()
            local t = {}
            for addr in raw_component.list("data") do t[addr] = "data" end
            return t
        end)
    end
    if not bOk or not tList then return false, "No data card" end
    
    for addr in pairs(tList) do
        local proxy
        pcall(function() proxy = component.proxy(addr) end)
        if not proxy then pcall(function() proxy = raw_component.proxy(addr) end) end
        if proxy then
            g_oDataCard = proxy
            -- Detect tier by available methods
            if proxy.ecdsa then g_nTier = 3
            elseif proxy.encrypt then g_nTier = 2
            else g_nTier = 1 end
            return true, g_nTier
        end
    end
    return false, "Data card proxy failed"
end

function oCrypto.GetTier() return g_nTier end

-- SHA-256 hash (Tier 1+)
function oCrypto.SHA256(sData)
    if not g_oDataCard or g_nTier < 1 then return nil, "No data card" end
    return g_oDataCard.sha256(sData)
end

-- SHA-256 hash of a file via raw filesystem
function oCrypto.HashFile(sPath, oFs)
    if not oFs then return nil, "No filesystem" end
    local h = oFs.open(sPath, "r")
    if not h then return nil, "File not found: " .. sPath end
    local tChunks = {}
    while true do
        local chunk = oFs.read(h, 8192)
        if not chunk then break end
        tChunks[#tChunks + 1] = chunk
    end
    oFs.close(h)
    local sData = table.concat(tChunks)
    return oCrypto.SHA256(sData), sData
end

-- Base64 encode/decode (Tier 1+)
function oCrypto.Encode64(sData)
    if not g_oDataCard then return nil end
    return g_oDataCard.encode64(sData)
end

function oCrypto.Decode64(sData)
    if not g_oDataCard then return nil end
    return g_oDataCard.decode64(sData)
end

-- Random bytes (Tier 2+)
function oCrypto.Random(nBytes)
    if g_nTier >= 2 then return g_oDataCard.random(nBytes) end
    -- Fallback: weak random (NOT cryptographically secure)
    local t = {}
    for i = 1, nBytes do t[i] = string.char(math.random(0, 255)) end
    return table.concat(t)
end

-- ECDSA Key Generation (Tier 3 only)
function oCrypto.GenerateKeyPair(nBits)
    if g_nTier < 3 then return nil, nil, "Tier 3 data card required" end
    local pub, priv = g_oDataCard.generateKeyPair(nBits or 384)
    return pub, priv
end

-- ECDSA Sign (Tier 3)
function oCrypto.Sign(sData, oPrivateKey)
    if not g_oDataCard or g_nTier < 3 then return nil, "Tier 3 required" end
    return g_oDataCard.ecdsa(sData, oPrivateKey)
end

-- ECDSA Verify (Tier 3)
function oCrypto.Verify(sData, sSignature, oPublicKey)
    if not g_oDataCard or g_nTier < 3 then return false end
    return g_oDataCard.ecdsa(sData, oPublicKey, sSignature)
end

-- Key serialization (data card encode/decode)
function oCrypto.SerializeKey(oKey)
    if not g_oDataCard then return nil end
    return g_oDataCard.encode64(g_oDataCard.serialize(oKey))
end

function oCrypto.DeserializeKey(sB64, sType)
    if not g_oDataCard then return nil end
    return g_oDataCard.deserialize(g_oDataCard.decode64(sB64), sType)
end

return oCrypto   -- ← THIS WAS MISSING
```


axis-os\src\kernel\lib\errcheck.lua
```
--
-- /lib/errcheck.lua
-- the big book of everything that can go wrong.
-- v2: added sMLTR and Object Handle error codes.
--

local g_tErrorCodes = {
  -- Success Codes
  STATUS_SUCCESS = 0,
  STATUS_PENDING = 1,

  -- Error Codes (300+)
  STATUS_UNSUCCESSFUL = 300,
  STATUS_NOT_IMPLEMENTED = 301,
  
  -- Driver-specific errors
  STATUS_INVALID_DRIVER_OBJECT = 400,
  STATUS_INVALID_DRIVER_ENTRY = 401,
  STATUS_INVALID_DRIVER_INFO = 402,
  STATUS_DRIVER_VALIDATION_FAILED = 403,
  STATUS_DRIVER_INIT_FAILED = 404,
  STATUS_NO_SUCH_DEVICE = 405,
  STATUS_DEVICE_ALREADY_EXISTS = 406,
  STATUS_INVALID_DRIVER_TYPE = 407,
  STATUS_DRIVER_UNLOAD_FAILED = 408,
  
  -- Access and Security errors
  STATUS_ACCESS_DENIED = 500,
  STATUS_PRIVILEGE_NOT_HELD = 501,
  STATUS_SYNAPSE_TOKEN_MISMATCH = 502,
  STATUS_SYNAPSE_TOKEN_EXPIRED = 503,

  -- VFS/IO errors
  STATUS_INVALID_HANDLE = 600,
  STATUS_INVALID_PARAMETER = 601,
  STATUS_END_OF_FILE = 602,
  STATUS_NO_SUCH_FILE = 603,
  STATUS_DEVICE_BUSY = 604,

  -- Object Manager errors
  STATUS_HANDLE_NOT_FOUND = 700,
  STATUS_HANDLE_TABLE_FULL = 701,
  STATUS_HANDLE_ALIAS_INVALID = 702,
}

local g_tErrorStrings = {
  [0] = "STATUS_SUCCESS: The operation completed successfully.",
  [1] = "STATUS_PENDING: The operation is in progress and will complete later.",
  [300] = "STATUS_UNSUCCESSFUL: The operation failed.",
  [301] = "STATUS_NOT_IMPLEMENTED: The requested feature is not implemented.",
  [400] = "STATUS_INVALID_DRIVER_OBJECT: The driver object structure is malformed.",
  [401] = "STATUS_INVALID_DRIVER_ENTRY: The driver does not export a valid DriverEntry or UMDriverEntry function.",
  [402] = "STATUS_INVALID_DRIVER_INFO: The driver's g_tDriverInfo table is missing or malformed.",
  [403] = "STATUS_DRIVER_VALIDATION_FAILED: The driver file failed static validation.",
  [404] = "STATUS_DRIVER_INIT_FAILED: The driver's Entry function returned an error status.",
  [405] = "STATUS_NO_SUCH_DEVICE: The specified device does not exist.",
  [406] = "STATUS_DEVICE_ALREADY_EXISTS: An attempt was made to create a device that already exists.",
  [407] = "STATUS_INVALID_DRIVER_TYPE: The driver type specified in g_tDriverInfo is not valid.",
  [408] = "STATUS_DRIVER_UNLOAD_FAILED: The driver's Unload function returned an error.",
  [500] = "STATUS_ACCESS_DENIED: You do not have permission to perform this action.",
  [501] = "STATUS_PRIVILEGE_NOT_HELD: The operation requires a higher ring level.",
  [502] = "STATUS_SYNAPSE_TOKEN_MISMATCH: The sMLTR synapse token does not match the expected value.",
  [503] = "STATUS_SYNAPSE_TOKEN_EXPIRED: The synapse token has been rotated and is no longer valid.",
  [600] = "STATUS_INVALID_HANDLE: The provided file handle is not valid.",
  [601] = "STATUS_INVALID_PARAMETER: A parameter provided to a function was not valid.",
  [602] = "STATUS_END_OF_FILE: Reached the end of the file.",
  [603] = "STATUS_NO_SUCH_FILE: The file or directory does not exist.",
  [604] = "STATUS_DEVICE_BUSY: The device is currently busy with another request.",
  [700] = "STATUS_HANDLE_NOT_FOUND: The object handle could not be resolved in the process handle table.",
  [701] = "STATUS_HANDLE_TABLE_FULL: The process handle table is at capacity.",
  [702] = "STATUS_HANDLE_ALIAS_INVALID: The numeric alias does not map to a valid handle token.",
}

local oErrCheck = {}
for sName, nCode in pairs(g_tErrorCodes) do
  oErrCheck[sName] = nCode
end

function oErrCheck.fGetErrorString(nStatusCode)
  return g_tErrorStrings[nStatusCode] or "Unknown or unspecified error code: " .. tostring(nStatusCode)
end

return oErrCheck
```


axis-os\src\kernel\lib\filesystem.lua
```
--
-- /lib/filesystem.lua
-- User-mode VFS wrapper — WDM Handle Model
-- v4: Per-coroutine write buffers. Flush on \f.
--

local oFsLib = {}

oFsLib.STDIN  = -10
oFsLib.STDOUT = -11
oFsLib.STDERR = -12

-- =============================================
-- PER-PROCESS BUFFER ISOLATION
-- Each coroutine (== process) gets its own buffer table.
-- Weak keys so dead coroutines are GC'd automatically.
-- =============================================

local tPerProcessBuffers = setmetatable({}, { __mode = "k" })

local function fGetBuffers()
    local co = coroutine.running()
    if not tPerProcessBuffers[co] then
        tPerProcessBuffers[co] = {}
    end
    return tPerProcessBuffers[co]
end

-- =============================================
-- HANDLE RESOLUTION
-- =============================================

local function fResolve(handle)
    if handle == nil then return nil end
    if type(handle) == "string" then return handle end
    if type(handle) == "number" then
        if handle <= -10 and handle >= -12 then return handle end
        if handle == 0 then return -10 end
        if handle == 1 then return -11 end
        if handle == 2 then return -12 end
        return handle
    end
    if type(handle) == "table" then
        if handle._token then return handle._token end
        if handle.fd ~= nil then return fResolve(handle.fd) end
    end
    return nil
end

-- =============================================
-- BUFFERED WRITE / FLUSH
-- =============================================

local function fFlush(tok)
    if tok == nil then return true end
    local tBuf = fGetBuffers()
    local sData = tBuf[tok]
    if sData and #sData > 0 then
        tBuf[tok] = ""
        local b1, b2 = syscall("vfs_write", tok, sData)
        return b1 and b2
    end
    return true
end

local function fFlushAll()
    local tBuf = fGetBuffers()
    for k in pairs(tBuf) do fFlush(k) end
end

-- =============================================
-- PUBLIC API
-- =============================================

oFsLib.open = function(sPath, sMode)
    local b1, b2, sToken = syscall("vfs_open", sPath, sMode or "r")
    if b1 and b2 and sToken then
        return { _token = sToken }
    end
    return nil, sToken
end

oFsLib.read = function(handle, nCount)
    local tok = fResolve(handle)
    if not tok then return nil, "Invalid handle" end
    -- only flush THIS process's buffers (safe now)
    fFlushAll()
    local b1, b2, val = syscall("vfs_read", tok, nCount or math.huge)
    return (b1 and b2) and val or nil, val
end

oFsLib.write = function(handle, sData)
    local tok = fResolve(handle)
    if not tok then return nil, "Invalid handle" end
    local tBuf = fGetBuffers()
    local sBuf = (tBuf[tok] or "") .. tostring(sData)
    tBuf[tok] = sBuf
    -- flush on newline, carriage return, form feed, or size limit
    if sBuf:find("[\n\r\f]") or #sBuf > 2048 then
        return fFlush(tok)
    end
    return true
end

oFsLib.flush = function(handle)
    local tok = fResolve(handle)
    if tok then return fFlush(tok) end
end

oFsLib.close = function(handle)
    local tok = fResolve(handle)
    if not tok then return nil end
    fFlush(tok)
    local tBuf = fGetBuffers()
    tBuf[tok] = nil
    local b1, b2 = syscall("vfs_close", tok)
    return b1 and b2
end

oFsLib.list = function(sPath)
    local b1, b2, val = syscall("vfs_list", sPath)
    return (b1 and b2 and type(val) == "table") and val or nil, val
end

oFsLib.chmod = function(sPath, nMode)
    local b1, b2, val = syscall("vfs_chmod", sPath, nMode)
    return b1 and b2, val
end

oFsLib.deviceControl = function(handle, sMethod, tArgs)
    local tok = fResolve(handle)
    if not tok then return nil, "Invalid handle" end
    local b1, b2, val = syscall("vfs_device_control", tok, sMethod, tArgs or {})
    return b1 and b2, val
end

oFsLib.remove = function(sPath)
    local b1, b2 = syscall("vfs_delete", sPath)
    return b1 and b2
end

oFsLib.mkdir = function(sPath)
    local b1, b2 = syscall("vfs_mkdir", sPath)
    return b1 and b2
end

return oFsLib
```


axis-os\src\kernel\lib\http.lua
```
--
-- /lib/http.lua
-- AxisOS HTTP client library
--
-- local http = require("http")
-- local resp = http.get("https://example.com")
-- print(resp.code, resp.body)
--

local fs = require("filesystem")
local oHttp = {}

local function fOpenNet()
  local h = fs.open("/dev/net", "r")
  if not h then return nil, "Network device not available (/dev/net)" end
  return h
end

-- =============================================
-- STREAMING API
-- =============================================

-- Open an HTTP stream (for large responses)
-- Returns a stream object or nil + error
function oHttp.open(sUrl, sMethod, sBody, tHeaders, nTimeout)
  local hNet, sErr = fOpenNet()
  if not hNet then return nil, sErr end

  local bOk, tResult = fs.deviceControl(hNet, "http_request", {
    sUrl, sMethod or "GET", sBody, tHeaders, nTimeout or 10
  })

  if not bOk then
    fs.close(hNet)
    return nil, tostring(tResult or "Request failed")
  end

  if type(tResult) ~= "table" then
    fs.close(hNet)
    return nil, "Unexpected response from driver"
  end

  local tStream = {
    _hNet      = hNet,
    _nSession  = tResult.nSessionId,
    _bClosed   = false,
    code       = tResult.nStatusCode or 0,
    message    = tResult.sStatusMessage or "",
    headers    = tResult.tHeaders or {},
    connectMs  = tResult.nConnectMs or 0,
  }

  function tStream:read(nCount)
    if self._bClosed then return nil end
    local bReadOk, sData = fs.deviceControl(self._hNet, "http_read", {
      self._nSession, nCount or math.huge
    })
    if bReadOk and sData and type(sData) == "string" and #sData > 0 then
      return sData
    end
    return nil
  end

  function tStream:close()
    if self._bClosed then return end
    self._bClosed = true
    fs.deviceControl(self._hNet, "http_close", {self._nSession})
    fs.close(self._hNet)
  end

  return tStream
end

-- =============================================
-- SIMPLE API (reads entire response)
-- =============================================

local function fFullRequest(sUrl, sMethod, sBody, tHeaders, nTimeout)
  local stream, sErr = oHttp.open(sUrl, sMethod, sBody, tHeaders, nTimeout)
  if not stream then
    return { code = 0, body = "", headers = {}, error = sErr }
  end

  local tChunks = {}
  while true do
    local sChunk = stream:read(4096)
    if not sChunk then break end
    table.insert(tChunks, sChunk)
  end

  local tResp = {
    code      = stream.code,
    message   = stream.message,
    headers   = stream.headers,
    body      = table.concat(tChunks),
    connectMs = stream.connectMs,
    error     = nil,
  }

  stream:close()
  return tResp
end

function oHttp.get(sUrl, tHeaders, nTimeout)
  return fFullRequest(sUrl, "GET", nil, tHeaders, nTimeout)
end

function oHttp.post(sUrl, sBody, tHeaders, nTimeout)
  return fFullRequest(sUrl, "POST", sBody, tHeaders, nTimeout)
end

function oHttp.put(sUrl, sBody, tHeaders, nTimeout)
  return fFullRequest(sUrl, "PUT", sBody, tHeaders, nTimeout)
end

function oHttp.head(sUrl, tHeaders, nTimeout)
  return fFullRequest(sUrl, "HEAD", nil, tHeaders, nTimeout)
end

function oHttp.request(sMethod, sUrl, sBody, tHeaders, nTimeout)
  return fFullRequest(sUrl, sMethod, sBody, tHeaders, nTimeout)
end

-- =============================================
-- UTILITY
-- =============================================

function oHttp.info()
  local hNet = fOpenNet()
  if not hNet then return nil, "No network" end
  local bOk, tInfo = fs.deviceControl(hNet, "info", {})
  fs.close(hNet)
  return bOk and tInfo or nil
end

function oHttp.download(sUrl, sDestPath, fProgress)
  local stream, sErr = oHttp.open(sUrl)
  if not stream then return nil, sErr end

  local hFile = fs.open(sDestPath, "w")
  if not hFile then
    stream:close()
    return nil, "Cannot open " .. sDestPath .. " for writing"
  end

  local nTotal = 0
  while true do
    local sChunk = stream:read(2048)
    if not sChunk then break end
    fs.write(hFile, sChunk)
    nTotal = nTotal + #sChunk
    if fProgress then fProgress(nTotal) end
  end

  fs.close(hFile)
  local tInfo = { code = stream.code, nBytes = nTotal, connectMs = stream.connectMs }
  stream:close()
  return tInfo
end

return oHttp
```


axis-os\src\kernel\lib\ipc.lua
```
--
-- /lib/ipc.lua — User-space shared memory & message queues
--

local oIpc = {}

-- ===== Shared Memory =====

function oIpc.createSection(sName, nSize)
    return syscall("ke_create_section", sName, nSize or 4096)
end

function oIpc.openSection(sName)
    return syscall("ke_open_section", sName)
end

function oIpc.mapSection(hSection)
    return syscall("ke_map_section", hSection)
end

-- ===== Message Queues =====

function oIpc.createMqueue(sName, nMaxMsgs, nMaxSize)
    return syscall("ke_create_mqueue", sName, nMaxMsgs, nMaxSize)
end

function oIpc.openMqueue(sName)
    return syscall("ke_open_mqueue", sName)
end

function oIpc.mqSend(hQueue, sMessage, nPriority)
    return syscall("ke_mq_send", hQueue, sMessage, nPriority or 0)
end

function oIpc.mqReceive(hQueue, nTimeoutMs)
    return syscall("ke_mq_receive", hQueue, nTimeoutMs)
end

-- ===== IRQL =====

function oIpc.raiseIrql(nLevel)
    return syscall("ke_raise_irql", nLevel)
end

function oIpc.lowerIrql(nLevel)
    return syscall("ke_lower_irql", nLevel)
end

function oIpc.getIrql()
    return syscall("ke_get_irql")
end

function oIpc.ipcStats()
    return syscall("ke_ipc_stats")
end

return oIpc
```


axis-os\src\kernel\lib\ke_ipc.lua
```
--
-- /lib/ke_ipc.lua
-- AxisOS Kernel Executive IPC Subsystem
-- NT/POSIX Hybrid: IRQL, DPC, Timers, Waitable Objects, Events,
-- Mutexes, Semaphores, Pipes, Shared Memory, Message Queues,
-- Signals, Process Groups, WaitForMultipleObjects
--

local oIpc = {}

-- =============================================
-- 1. CONSTANTS
-- =============================================

oIpc.PASSIVE_LEVEL  = 0
oIpc.APC_LEVEL      = 1
oIpc.DISPATCH_LEVEL = 2
oIpc.DEVICE_LEVEL   = 3

oIpc.STATUS_WAIT_0        = 0
oIpc.STATUS_TIMEOUT       = 258
oIpc.STATUS_ABANDONED     = 0x80
oIpc.STATUS_IO_COMPLETION = 0xC0
oIpc.STATUS_FAILED        = -1

oIpc.WAIT_TYPE_EVENT     = 1
oIpc.WAIT_TYPE_MUTEX     = 2
oIpc.WAIT_TYPE_SEMAPHORE = 3
oIpc.WAIT_TYPE_TIMER     = 4
oIpc.WAIT_TYPE_PIPE      = 5
oIpc.WAIT_TYPE_MQUEUE    = 6

oIpc.SIGHUP=1  oIpc.SIGINT=2  oIpc.SIGQUIT=3  oIpc.SIGILL=4
oIpc.SIGABRT=6 oIpc.SIGKILL=9 oIpc.SIGPIPE=13 oIpc.SIGALRM=14
oIpc.SIGTERM=15 oIpc.SIGCHLD=17 oIpc.SIGCONT=18 oIpc.SIGSTOP=19
oIpc.SIGTSTP=20 oIpc.SIGUSR1=30 oIpc.SIGUSR2=31

local DFL_TERM="terminate" local DFL_IGN="ignore"
local DFL_STOP="stop"      local DFL_CONT="continue"
local g_tDefAct = {
    [1]=DFL_TERM,[2]=DFL_TERM,[3]=DFL_TERM,[4]=DFL_TERM,
    [6]=DFL_TERM,[9]=DFL_TERM,[13]=DFL_TERM,[14]=DFL_TERM,
    [15]=DFL_TERM,[17]=DFL_IGN,[18]=DFL_CONT,[19]=DFL_STOP,
    [20]=DFL_STOP,[30]=DFL_TERM,[31]=DFL_TERM,
}

oIpc.DEFAULT_PIPE_SIZE = 4096
oIpc.MAX_PIPE_SIZE     = 65536
oIpc.DEFAULT_MQ_MAX    = 64
oIpc.DEFAULT_MQ_SIZE   = 1024

-- =============================================
-- 2. INTERNAL STATE
-- =============================================

local g_tPT       = nil
local g_fUp       = nil
local g_fLog      = nil
local g_oOb       = nil
local g_fYield    = nil

local g_tDpcQueue = {}
local g_nDpcNext  = 1
local g_tTimers   = {}
local g_nTimerNext= 1
local g_tNamedPipes = {}
local g_tSections  = {}
local g_tMQueues   = {}
local g_tProcGroups= {}

-- Timeout registry: [nPid] = { nDeadline, tDH (optional), tDHList (optional) }
-- Checked each Tick(). When deadline passes, sleeping process is woken
-- with _nWaitResult = STATUS_TIMEOUT.
local g_tWaitTimeouts = {}

local g_tStats = {
    nDpcsProcessed = 0,
    nTimersFired   = 0,
    nSignalsSent   = 0,
    nSignalsDelivered = 0,
    nPipeCreated   = 0,
    nPipeBytes     = 0,
    nWaitsIssued   = 0,
    nWaitsSatisfied= 0,
    nWaitsTimedOut = 0,
    nMutexCreated  = 0,
    nEventCreated  = 0,
    nSemCreated    = 0,
    nSectionCreated= 0,
    nMqCreated     = 0,
}

-- =============================================
-- 3. INITIALIZE
-- =============================================

function oIpc.Initialize(tK)
    g_tPT    = tK.tProcessTable
    g_fUp    = tK.fUptime
    g_fLog   = tK.fLog
    g_oOb    = tK.oObManager
    g_fYield = tK.fYield
    g_fLog("[IPC] Kernel IPC subsystem initialized")
    g_fLog("[IPC]   IRQL, DPC, Timers, Events, Mutexes, Semaphores")
    g_fLog("[IPC]   Pipes, Shared Memory, Message Queues, Signals")
    g_fLog("[IPC]   WaitForMultipleObjects, Process Groups")
end

-- =============================================
-- 4. IRQL MANAGEMENT
-- =============================================

function oIpc.KeGetCurrentIrql(nPid)
    local p = g_tPT[nPid]
    return p and (p.nIrql or oIpc.PASSIVE_LEVEL) or oIpc.PASSIVE_LEVEL
end

function oIpc.KeRaiseIrql(nPid, nNewIrql)
    local p = g_tPT[nPid]
    if not p then return oIpc.PASSIVE_LEVEL end
    local nOld = p.nIrql or oIpc.PASSIVE_LEVEL
    if nNewIrql < nOld then
        g_fLog("[IPC] WARNING: KeRaiseIrql called to LOWER (pid="..nPid..")")
    end
    p.nIrql = nNewIrql
    return nOld
end

function oIpc.KeLowerIrql(nPid, nNewIrql)
    local p = g_tPT[nPid]
    if not p then return end
    p.nIrql = nNewIrql
end

local function fCanBlock(nPid)
    local p = g_tPT[nPid]
    if not p then return false end
    return (p.nIrql or 0) < oIpc.DISPATCH_LEVEL
end

-- =============================================
-- 5. WAITABLE OBJECT CORE
-- =============================================

local function fNewDispatchHeader(nType, bManualReset, bInitSignaled)
    return {
        nType        = nType,
        bSignaled    = bInitSignaled or false,
        bManualReset = bManualReset or false,
        tWaitList    = {},   -- {nPid, nWaitKey}
    }
end

-- Wake processes waiting on an object. Returns count woken.
local function fSignalObject(tDH)
    if not tDH then return 0 end
    tDH.bSignaled = true
    local nWoken = 0

    for _, tEntry in ipairs(tDH.tWaitList) do
        local tWaiter = g_tPT[tEntry.nPid]
        if tWaiter and tWaiter.status == "sleeping" then
            if tWaiter._tWaitCtx then
                local ctx = tWaiter._tWaitCtx
                if ctx.bWaitAll then
                    local bAllReady = true
                    for _, tWO in ipairs(ctx.tWaitObjs) do
                        if not tWO.tDH.bSignaled then bAllReady = false; break end
                    end
                    if bAllReady then
                        for _, tWO in ipairs(ctx.tWaitObjs) do
                            if not tWO.tDH.bManualReset then tWO.tDH.bSignaled = false end
                        end
                        tWaiter._nWaitResult = oIpc.STATUS_WAIT_0
                        tWaiter.status = "ready"
                        tWaiter._tWaitCtx = nil
                        g_tWaitTimeouts[tEntry.nPid] = nil
                        nWoken = nWoken + 1
                    end
                else
                    if not tDH.bManualReset then tDH.bSignaled = false end
                    tWaiter._nWaitResult = oIpc.STATUS_WAIT_0 + (tEntry.nWaitKey or 0)
                    tWaiter.status = "ready"
                    tWaiter._tWaitCtx = nil
                    g_tWaitTimeouts[tEntry.nPid] = nil
                    nWoken = nWoken + 1
                end
            else
                if not tDH.bManualReset then tDH.bSignaled = false end
                tWaiter._nWaitResult = oIpc.STATUS_WAIT_0
                tWaiter.status = "ready"
                g_tWaitTimeouts[tEntry.nPid] = nil
                nWoken = nWoken + 1
            end

            if not tDH.bManualReset and nWoken > 0 then break end
        end
    end

    if nWoken > 0 then
        local tNew = {}
        for _, tEntry in ipairs(tDH.tWaitList) do
            local tW = g_tPT[tEntry.nPid]
            if tW and tW.status == "sleeping" then
                table.insert(tNew, tEntry)
            end
        end
        tDH.tWaitList = tNew
    end

    return nWoken
end

local function fUnsignalObject(tDH)
    if tDH then tDH.bSignaled = false end
end

local function fAddWaiter(tDH, nPid, nWaitKey)
    table.insert(tDH.tWaitList, {nPid = nPid, nWaitKey = nWaitKey or 0})
end

local function fRemoveWaiter(tDH, nPid)
    local tNew = {}
    for _, e in ipairs(tDH.tWaitList) do
        if e.nPid ~= nPid then table.insert(tNew, e) end
    end
    tDH.tWaitList = tNew
end

-- =============================================
-- 6. DPC QUEUE
-- =============================================

function oIpc.KeQueueDpc(fCallback, vArg1, vArg2)
    local nId = g_nDpcNext; g_nDpcNext = g_nDpcNext + 1
    table.insert(g_tDpcQueue, {
        nId = nId, fCb = fCallback, a1 = vArg1, a2 = vArg2
    })
    return nId
end

function oIpc.KeCancelDpc(nId)
    for i = #g_tDpcQueue, 1, -1 do
        if g_tDpcQueue[i].nId == nId then
            table.remove(g_tDpcQueue, i)
            return true
        end
    end
    return false
end

function oIpc.ProcessDpcQueue()
    local nProcessed = 0
    while #g_tDpcQueue > 0 do
        local tDpc = table.remove(g_tDpcQueue, 1)
        local bOk, sErr = pcall(tDpc.fCb, tDpc.a1, tDpc.a2)
        if not bOk then
            g_fLog("[IPC] DPC " .. tDpc.nId .. " crashed: " .. tostring(sErr))
        end
        nProcessed = nProcessed + 1
        g_tStats.nDpcsProcessed = g_tStats.nDpcsProcessed + 1
        if nProcessed > 64 then break end  -- prevent DPC storms
    end
    return nProcessed
end

-- =============================================
-- 7. TIMER SYSTEM
-- =============================================

function oIpc.KeCreateTimer(nPid)
    local tBody = {
        tDH = fNewDispatchHeader(oIpc.WAIT_TYPE_TIMER, true, false),
        nDeadline  = 0,
        nPeriodMs  = 0,
        fDpc       = nil,
        vDpcArg    = nil,
        bActive    = false,
    }
    local pH = g_oOb.ObCreateObject("KeTimer", tBody)
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sH = g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
    local nId = g_nTimerNext; g_nTimerNext = g_nTimerNext + 1
    tBody.nTimerId = nId
    g_tTimers[nId] = tBody
    return sH, nId
end

function oIpc.KeSetTimer(nPid, sHandle, nDelayMs, nPeriodMs, fDpc, vArg)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH then return false, "Invalid handle" end
    local b = pH.pBody
    b.nDeadline = g_fUp() + (nDelayMs / 1000)
    b.nPeriodMs = nPeriodMs or 0
    b.fDpc = fDpc
    b.vDpcArg = vArg
    b.bActive = true
    fUnsignalObject(b.tDH)
    g_tTimers[b.nTimerId] = b
    return true
end

function oIpc.KeCancelTimer(nPid, sHandle)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH then return false end
    pH.pBody.bActive = false
    return true
end

function oIpc.ProcessTimers()
    local nNow = g_fUp()
    local nFired = 0
    for nId, b in pairs(g_tTimers) do
        if b.bActive and nNow >= b.nDeadline then
            fSignalObject(b.tDH)
            g_tStats.nTimersFired = g_tStats.nTimersFired + 1
            nFired = nFired + 1
            if b.fDpc then
                oIpc.KeQueueDpc(b.fDpc, b.vDpcArg, nId)
            end
            if b.nPeriodMs > 0 then
                b.nDeadline = nNow + (b.nPeriodMs / 1000)
                fUnsignalObject(b.tDH)
            else
                b.bActive = false
            end
        end
    end
    return nFired
end

-- =============================================
-- 8. EVENTS (NT KeEvent — manual/auto reset)
-- =============================================

function oIpc.KeCreateEvent(nPid, bManualReset, bInitial)
    local tBody = {
        tDH = fNewDispatchHeader(oIpc.WAIT_TYPE_EVENT, bManualReset, bInitial),
    }
    local pH = g_oOb.ObCreateObject("KeEvent", tBody)
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sH = g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
    g_tStats.nEventCreated = g_tStats.nEventCreated + 1
    g_fLog("[IPC] Event created (manual=" .. tostring(bManualReset) ..
           " initial=" .. tostring(bInitial) .. ") for PID " .. nPid)
    return sH
end

function oIpc.KeSetEvent(nPid, sHandle)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody or not pH.pBody.tDH then return 0 end
    return fSignalObject(pH.pBody.tDH)
end

function oIpc.KeResetEvent(nPid, sHandle)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return false end
    fUnsignalObject(pH.pBody.tDH)
    return true
end

function oIpc.KePulseEvent(nPid, sHandle)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return 0 end
    local n = fSignalObject(pH.pBody.tDH)
    fUnsignalObject(pH.pBody.tDH)
    return n
end

-- =============================================
-- 9. MUTEXES (NT KeMutex — owned, recursive)
-- =============================================

function oIpc.KeCreateMutex(nPid, bInitialOwner)
    local tBody = {
        tDH = fNewDispatchHeader(oIpc.WAIT_TYPE_MUTEX, false, not bInitialOwner),
        nOwnerPid  = bInitialOwner and nPid or nil,
        nRecurse   = bInitialOwner and 1 or 0,
    }
    local pH = g_oOb.ObCreateObject("KeMutex", tBody)
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sH = g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
    g_tStats.nMutexCreated = g_tStats.nMutexCreated + 1
    g_fLog("[IPC] Mutex created for PID " .. nPid)
    return sH
end

function oIpc.KeReleaseMutex(nPid, sHandle)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return nil, "Invalid handle" end
    local b = pH.pBody
    if b.nOwnerPid ~= nPid then return nil, "Not owner" end
    b.nRecurse = b.nRecurse - 1
    if b.nRecurse <= 0 then
        b.nOwnerPid = nil
        b.nRecurse = 0
        fSignalObject(b.tDH)
    end
    return true
end

-- Called by wait system when mutex is acquired
local function fMutexAcquire(b, nPid)
    if b.nOwnerPid == nPid then
        b.nRecurse = b.nRecurse + 1
        return true
    end
    if b.nOwnerPid == nil then
        b.nOwnerPid = nPid
        b.nRecurse = 1
        fUnsignalObject(b.tDH)
        return true
    end
    return false
end

-- =============================================
-- 10. SEMAPHORES
-- =============================================

function oIpc.KeCreateSemaphore(nPid, nInitial, nMax)
    nMax = nMax or 0x7FFFFFFF
    local tBody = {
        tDH = fNewDispatchHeader(oIpc.WAIT_TYPE_SEMAPHORE, false, nInitial > 0),
        nCount = nInitial or 0,
        nMax   = nMax,
    }
    local pH = g_oOb.ObCreateObject("KeSemaphore", tBody)
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sH = g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
    g_tStats.nSemCreated = g_tStats.nSemCreated + 1
    return sH
end

function oIpc.KeReleaseSemaphore(nPid, sHandle, nCount)
    nCount = nCount or 1
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return nil, "Invalid handle" end
    local b = pH.pBody
    local nPrev = b.nCount
    b.nCount = b.nCount + nCount
    if b.nCount > b.nMax then b.nCount = b.nMax end
    if b.nCount > 0 then
        fSignalObject(b.tDH)
    end
    return nPrev
end

local function fSemaphoreAcquire(b)
    if b.nCount > 0 then
        b.nCount = b.nCount - 1
        if b.nCount == 0 then fUnsignalObject(b.tDH) end
        return true
    end
    return false
end

-- =============================================
-- 11. PIPES
-- =============================================

function oIpc.KeCreatePipe(nPid, nBufSize)
    nBufSize = nBufSize or oIpc.DEFAULT_PIPE_SIZE
    if nBufSize > oIpc.MAX_PIPE_SIZE then nBufSize = oIpc.MAX_PIPE_SIZE end

    local tBody = {
        sCategory      = "pipe",
        tDH            = fNewDispatchHeader(oIpc.WAIT_TYPE_PIPE, true, false),
        sBuffer        = "",
        nMaxSize       = nBufSize,
        bReadClosed    = false,
        bWriteClosed   = false,
        nBytesRead     = 0,
        nBytesWritten  = 0,
        tReadWaitList  = {},
        tWriteWaitList = {},
    }

    local pH = g_oOb.ObCreateObject("IoPipeObject", tBody)
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sHRead  = g_oOb.ObCreateHandle(nPid, pH, 0x0001, sSyn) -- READ
    local sHWrite = g_oOb.ObCreateHandle(nPid, pH, 0x0002, sSyn) -- WRITE
    g_tStats.nPipeCreated = g_tStats.nPipeCreated + 1
    g_fLog("[IPC] Pipe created (buf=" .. nBufSize .. ") for PID " .. nPid)
    return sHRead, sHWrite
end

function oIpc.KeCreateNamedPipe(nPid, sName, nBufSize)
    if g_tNamedPipes[sName] then return nil, "Pipe exists" end
    local sR, sW = oIpc.KeCreatePipe(nPid, nBufSize)
    if not sR then return nil, sW end
    -- Resolve to get the object header for namespace registration
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sR, 0, g_tPT[nPid].synapseToken)
    if pH then
        g_tNamedPipes[sName] = pH
        pH.pBody.sName = sName
        g_oOb.ObInsertObject(pH, "\\Pipe\\" .. sName)
    end
    return sR, sW
end

function oIpc.KeConnectNamedPipe(nPid, sName)
    local pH = g_tNamedPipes[sName]
    if not pH then return nil, "No such pipe" end
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sH = g_oOb.ObCreateHandle(nPid, pH, 0x0003, sSyn) -- READ|WRITE
    return sH
end

local function fWakePipeReaders(b)
    for _, nWPid in ipairs(b.tReadWaitList) do
        local tW = g_tPT[nWPid]
        if tW and tW.status == "sleeping" and tW.wait_reason == "pipe_read" then
            tW.status = "ready"
        end
    end
    b.tReadWaitList = {}
    if #b.sBuffer > 0 then fSignalObject(b.tDH) end
end

local function fWakePipeWriters(b)
    for _, nWPid in ipairs(b.tWriteWaitList) do
        local tW = g_tPT[nWPid]
        if tW and tW.status == "sleeping" and tW.wait_reason == "pipe_write" then
            tW.status = "ready"
        end
    end
    b.tWriteWaitList = {}
end

function oIpc.PipeWrite(nPid, b, sData)
    if not sData then return nil, "No data" end
    if b.bReadClosed then
        -- Broken pipe → SIGPIPE
        oIpc.SignalSend(nPid, oIpc.SIGPIPE)
        return nil, "Broken pipe"
    end
    local nWritten = 0
    while #sData > 0 do
        local nSpace = b.nMaxSize - #b.sBuffer
        if nSpace > 0 then
            local nChunk = math.min(nSpace, #sData)
            b.sBuffer = b.sBuffer .. sData:sub(1, nChunk)
            sData = sData:sub(nChunk + 1)
            nWritten = nWritten + nChunk
            b.nBytesWritten = b.nBytesWritten + nChunk
            g_tStats.nPipeBytes = g_tStats.nPipeBytes + nChunk
            fWakePipeReaders(b)
        end
        if #sData == 0 then break end
        -- Buffer full — block
        if not fCanBlock(nPid) then return nil, "Would block (DISPATCH_LEVEL)" end
        table.insert(b.tWriteWaitList, nPid)
        g_tPT[nPid].status = "sleeping"
        g_tPT[nPid].wait_reason = "pipe_write"
        g_fYield()
        if b.bReadClosed then
            oIpc.SignalSend(nPid, oIpc.SIGPIPE)
            return nil, "Broken pipe"
        end
    end
    return true, nWritten
end

function oIpc.PipeRead(nPid, b, nCount)
    nCount = nCount or math.huge
    while #b.sBuffer == 0 do
        if b.bWriteClosed then return true, nil end  -- EOF
        if not fCanBlock(nPid) then return nil, "Would block" end
        table.insert(b.tReadWaitList, nPid)
        g_tPT[nPid].status = "sleeping"
        g_tPT[nPid].wait_reason = "pipe_read"
        g_fYield()
        if b.bWriteClosed and #b.sBuffer == 0 then return true, nil end
    end
    local nTake = math.min(nCount, #b.sBuffer)
    local sResult = b.sBuffer:sub(1, nTake)
    b.sBuffer = b.sBuffer:sub(nTake + 1)
    b.nBytesRead = b.nBytesRead + nTake
    fWakePipeWriters(b)
    if #b.sBuffer == 0 then fUnsignalObject(b.tDH) end
    return true, sResult
end

function oIpc.PipeClose(nPid, sHandle, bIsWrite)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return false end
    local b = pH.pBody
    if bIsWrite then
        b.bWriteClosed = true
        fWakePipeReaders(b)
    else
        b.bReadClosed = true
        fWakePipeWriters(b)
    end
    g_oOb.ObCloseHandle(nPid, sHandle)
    return true
end

-- VFS fast-path: intercept vfs_read/vfs_write on pipe handles
function oIpc.TryPipeIo(nPid, sName, vHandle, vArg)
    if not g_oOb then return false end
    local p = g_tPT[nPid]
    if not p then return false end
    local pH, nSt = g_oOb.ObReferenceObjectByHandle(
        nPid, vHandle, 0, p.synapseToken or "")
    if not pH then return false end
    if pH.sType ~= "IoPipeObject" then return false end
    local b = pH.pBody
    if not b or b.sCategory ~= "pipe" then return false end
    if sName == "vfs_write" then
        return true, oIpc.PipeWrite(nPid, b, vArg)
    elseif sName == "vfs_read" then
        return true, oIpc.PipeRead(nPid, b, vArg)
    end
    return false
end

-- =============================================
-- 12. SHARED MEMORY SECTIONS
-- =============================================

function oIpc.KeCreateSection(nPid, sName, nSize)
    nSize = nSize or 4096
    if sName and g_tSections[sName] then return nil, "Section exists" end
    local tBody = {
        sName  = sName,
        nSize  = nSize,
        tData  = {},     -- the shared memory region (Lua table)
        nRefs  = 1,
    }
    local pH = g_oOb.ObCreateObject("MmSectionObject", tBody)
    if sName then
        g_tSections[sName] = pH
        g_oOb.ObInsertObject(pH, "\\Section\\" .. sName)
    end
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sH = g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
    g_tStats.nSectionCreated = g_tStats.nSectionCreated + 1
    g_fLog("[IPC] Section '" .. (sName or "anon") .. "' created (" .. nSize .. "B)")
    return sH
end

function oIpc.KeOpenSection(nPid, sName)
    local pH = g_tSections[sName]
    if not pH then return nil, "No such section" end
    pH.pBody.nRefs = pH.pBody.nRefs + 1
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    return g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
end

function oIpc.KeMapSection(nPid, sHandle)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return nil, "Invalid handle" end
    return pH.pBody.tData  -- direct reference to shared table
end

-- =============================================
-- 13. MESSAGE QUEUES
-- =============================================

function oIpc.KeCreateMqueue(nPid, sName, nMaxMsgs, nMaxSize)
    nMaxMsgs = nMaxMsgs or oIpc.DEFAULT_MQ_MAX
    nMaxSize = nMaxSize or oIpc.DEFAULT_MQ_SIZE
    if sName and g_tMQueues[sName] then return nil, "Queue exists" end
    local tBody = {
        tDH       = fNewDispatchHeader(oIpc.WAIT_TYPE_MQUEUE, true, false),
        sName     = sName,
        nMaxMsgs  = nMaxMsgs,
        nMaxSize  = nMaxSize,
        tMessages = {},      -- {sData, nPriority}
        tRecvWait = {},      -- PIDs waiting to receive
        tSendWait = {},      -- PIDs waiting to send
    }
    local pH = g_oOb.ObCreateObject("IpcMessageQueue", tBody)
    if sName then
        g_tMQueues[sName] = pH
        g_oOb.ObInsertObject(pH, "\\MQueue\\" .. sName)
    end
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    local sH = g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
    g_tStats.nMqCreated = g_tStats.nMqCreated + 1
    g_fLog("[IPC] MQueue '" .. (sName or "anon") .. "' created")
    return sH
end

function oIpc.KeOpenMqueue(nPid, sName)
    local pH = g_tMQueues[sName]
    if not pH then return nil, "No such queue" end
    local sSyn = g_tPT[nPid] and g_tPT[nPid].synapseToken or ""
    return g_oOb.ObCreateHandle(nPid, pH, 0x007F, sSyn)
end

function oIpc.KeMqSend(nPid, sHandle, sMessage, nPriority)
    nPriority = nPriority or 0
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return nil, "Invalid handle" end
    local b = pH.pBody
    if #sMessage > b.nMaxSize then return nil, "Message too large" end

    while #b.tMessages >= b.nMaxMsgs do
        if not fCanBlock(nPid) then return nil, "Would block" end
        table.insert(b.tSendWait, nPid)
        g_tPT[nPid].status = "sleeping"
        g_tPT[nPid].wait_reason = "mq_send"
        g_fYield()
    end

    local bInserted = false
    for i, tMsg in ipairs(b.tMessages) do
        if nPriority > tMsg.nPri then
            table.insert(b.tMessages, i, {sData = sMessage, nPri = nPriority})
            bInserted = true; break
        end
    end
    if not bInserted then
        table.insert(b.tMessages, {sData = sMessage, nPri = nPriority})
    end

    -- Wake receivers (no resume_args needed — they re-check the queue)
    for _, nWPid in ipairs(b.tRecvWait) do
        local tW = g_tPT[nWPid]
        if tW and tW.status == "sleeping" and tW.wait_reason == "mq_recv" then
            tW.status = "ready"
            g_tWaitTimeouts[nWPid] = nil  -- cancel any pending timeout
        end
    end
    b.tRecvWait = {}
    fSignalObject(b.tDH)
    return true
end

function oIpc.KeMqReceive(nPid, sHandle, nTimeoutMs)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return nil, "Invalid handle" end
    local b = pH.pBody

    local nDeadline = nTimeoutMs and (g_fUp() + nTimeoutMs / 1000) or nil

    while #b.tMessages == 0 do
        -- Check deadline before blocking
        if nDeadline and g_fUp() >= nDeadline then return nil, "timeout" end
        if not fCanBlock(nPid) then return nil, "Would block" end

        table.insert(b.tRecvWait, nPid)

        -- Register timeout in the central registry
        if nDeadline then
            g_tWaitTimeouts[nPid] = { nDeadline = nDeadline }
        end

        g_tPT[nPid]._nWaitResult = nil
        g_tPT[nPid].status = "sleeping"
        g_tPT[nPid].wait_reason = "mq_recv"
        g_fYield()

        -- Cleanup and check if we timed out
        g_tWaitTimeouts[nPid] = nil
        if g_tPT[nPid]._nWaitResult == oIpc.STATUS_TIMEOUT then
            g_tPT[nPid]._nWaitResult = nil
            return nil, "timeout"
        end
        g_tPT[nPid]._nWaitResult = nil
    end

    local tMsg = table.remove(b.tMessages, 1)
    if #b.tMessages == 0 then fUnsignalObject(b.tDH) end

    -- Wake senders
    for _, nWPid in ipairs(b.tSendWait) do
        local tW = g_tPT[nWPid]
        if tW and tW.status == "sleeping" and tW.wait_reason == "mq_send" then
            tW.status = "ready"
        end
    end
    b.tSendWait = {}
    return tMsg.sData, tMsg.nPri
end

-- =============================================
-- 14. SIGNALS & PROCESS GROUPS
-- =============================================

function oIpc.InitProcessSignals(nPid)
    local p = g_tPT[nPid]
    if not p then return end
    p.tPendingSignals = {}
    p.tSignalHandlers = {}
    p.tSignalMask     = {}    -- [signum] = true → blocked
    p.nPgid           = nPid  -- own process group by default
    p.bDeliveringSignals = false
    p.nIrql           = oIpc.PASSIVE_LEVEL
    -- Register in default process group
    if not g_tProcGroups[nPid] then g_tProcGroups[nPid] = {} end
    table.insert(g_tProcGroups[nPid], nPid)
end

function oIpc.SignalSend(nTargetPid, nSignal)
    local p = g_tPT[nTargetPid]
    if not p then return nil, "No such process" end
    if not p.tPendingSignals then oIpc.InitProcessSignals(nTargetPid) end
    g_tStats.nSignalsSent = g_tStats.nSignalsSent + 1

    -- SIGKILL: immediate, uncatchable
    if nSignal == oIpc.SIGKILL then
        g_fLog("[IPC] SIGKILL → PID " .. nTargetPid)
        p.status = "dead"
        for _, nTid in ipairs(p.threads or {}) do
            if g_tPT[nTid] then g_tPT[nTid].status = "dead" end
        end
        return true
    end

    -- SIGSTOP: immediate, uncatchable
    if nSignal == oIpc.SIGSTOP then
        g_fLog("[IPC] SIGSTOP → PID " .. nTargetPid)
        p.status = "stopped"
        return true
    end

    -- SIGCONT: wake stopped process
    if nSignal == oIpc.SIGCONT then
        if p.status == "stopped" then
            p.status = "ready"
            g_fLog("[IPC] SIGCONT → PID " .. nTargetPid .. " resumed")
        end
        -- Also deliver to handler if registered
    end

    -- Queue the signal
    table.insert(p.tPendingSignals, nSignal)

    -- Wake sleeping processes so they can receive the signal
    if p.status == "sleeping" then
        p.status = "ready"
        p.resume_args = {true, oIpc.STATUS_IO_COMPLETION}
    end
    return true
end

function oIpc.SignalSendGroup(nPgid, nSignal)
    local tGroup = g_tProcGroups[nPgid]
    if not tGroup then return nil, "No such group" end
    local nSent = 0
    for _, nPid in ipairs(tGroup) do
        if g_tPT[nPid] and g_tPT[nPid].status ~= "dead" then
            oIpc.SignalSend(nPid, nSignal)
            nSent = nSent + 1
        end
    end
    return nSent
end

function oIpc.SignalSetHandler(nPid, nSignal, fHandler)
    local p = g_tPT[nPid]
    if not p then return nil, "No such process" end
    if not p.tSignalHandlers then oIpc.InitProcessSignals(nPid) end
    if nSignal == oIpc.SIGKILL or nSignal == oIpc.SIGSTOP then
        return nil, "Cannot catch SIGKILL/SIGSTOP"
    end
    local fOld = p.tSignalHandlers[nSignal]
    p.tSignalHandlers[nSignal] = fHandler  -- nil to reset to default
    return fOld
end

function oIpc.SignalSetMask(nPid, tMask)
    local p = g_tPT[nPid]
    if not p then return nil end
    if not p.tSignalMask then oIpc.InitProcessSignals(nPid) end
    local tOld = p.tSignalMask
    p.tSignalMask = tMask or {}
    return tOld
end

function oIpc.SetProcessGroup(nPid, nPgid)
    local p = g_tPT[nPid]
    if not p then return false end
    -- Remove from old group
    local nOldPgid = p.nPgid or nPid
    local tOld = g_tProcGroups[nOldPgid]
    if tOld then
        local tNew = {}
        for _, id in ipairs(tOld) do
            if id ~= nPid then table.insert(tNew, id) end
        end
        g_tProcGroups[nOldPgid] = tNew
    end
    -- Add to new group
    p.nPgid = nPgid
    if not g_tProcGroups[nPgid] then g_tProcGroups[nPgid] = {} end
    table.insert(g_tProcGroups[nPgid], nPid)
    return true
end

-- Deliver pending signals — called in process context
function oIpc.DeliverSignals(nPid)
    local p = g_tPT[nPid]
    if not p or not p.tPendingSignals then return false end
    if p.bDeliveringSignals then return false end -- prevent reentry
    if #p.tPendingSignals == 0 then return false end

    p.bDeliveringSignals = true
    local nOldIrql = p.nIrql or 0
    p.nIrql = oIpc.APC_LEVEL

    while #p.tPendingSignals > 0 do
        local nSig = table.remove(p.tPendingSignals, 1)

        -- Check mask
        if p.tSignalMask and p.tSignalMask[nSig] then
            table.insert(p.tPendingSignals, nSig) -- re-queue
            break  -- don't spin forever on masked signals
        end

        g_tStats.nSignalsDelivered = g_tStats.nSignalsDelivered + 1
        local fHandler = p.tSignalHandlers and p.tSignalHandlers[nSig]

        if fHandler then
            -- Call user handler
            local bOk, sErr = pcall(fHandler, nSig)
            if not bOk then
                g_fLog("[IPC] Signal handler crashed PID="..nPid.." sig="..nSig..": "..tostring(sErr))
            end
        else
            -- Default action
            local sAct = g_tDefAct[nSig] or DFL_TERM
            if sAct == DFL_TERM then
                g_fLog("[IPC] Default TERM for signal " .. nSig .. " → PID " .. nPid)
                p.status = "dead"
                break
            elseif sAct == DFL_STOP then
                p.status = "stopped"
                break
            elseif sAct == DFL_CONT then
                if p.status == "stopped" then p.status = "ready" end
            end
            -- DFL_IGN: do nothing
        end
    end

    p.nIrql = nOldIrql
    p.bDeliveringSignals = false
    return p.status == "dead"
end

-- Notify parent of child death (SIGCHLD)
function oIpc.NotifyChildDeath(nChildPid)
    local child = g_tPT[nChildPid]
    if not child then return end
    local nParent = child.parent
    if nParent and g_tPT[nParent] and g_tPT[nParent].status ~= "dead" then
        oIpc.SignalSend(nParent, oIpc.SIGCHLD)
    end
end

-- =============================================
-- 15. WAITFORSINGLE / WAITFORMULTIPLE
-- =============================================

local function fResolveWaitable(nPid, sHandle)
    local pH = g_oOb.ObReferenceObjectByHandle(
        nPid, sHandle, 0, g_tPT[nPid] and g_tPT[nPid].synapseToken or "")
    if not pH or not pH.pBody then return nil end
    local b = pH.pBody
    if not b.tDH then return nil end
    return b.tDH, b
end

function oIpc.KeWaitSingle(nPid, sHandle, nTimeoutMs)
    if not fCanBlock(nPid) then return oIpc.STATUS_FAILED, "Cannot block" end
    g_tStats.nWaitsIssued = g_tStats.nWaitsIssued + 1

    local tDH, tBody = fResolveWaitable(nPid, sHandle)
    if not tDH then return oIpc.STATUS_FAILED, "Not waitable" end

    -- Immediate satisfaction
    if tDH.bSignaled then
        if tDH.nType == oIpc.WAIT_TYPE_MUTEX then
            if fMutexAcquire(tBody, nPid) then
                g_tStats.nWaitsSatisfied = g_tStats.nWaitsSatisfied + 1
                return oIpc.STATUS_WAIT_0
            end
        elseif tDH.nType == oIpc.WAIT_TYPE_SEMAPHORE then
            if fSemaphoreAcquire(tBody) then
                g_tStats.nWaitsSatisfied = g_tStats.nWaitsSatisfied + 1
                return oIpc.STATUS_WAIT_0
            end
        else
            if not tDH.bManualReset then tDH.bSignaled = false end
            g_tStats.nWaitsSatisfied = g_tStats.nWaitsSatisfied + 1
            return oIpc.STATUS_WAIT_0
        end
    end

    -- Must sleep — register waiter and optional timeout
    fAddWaiter(tDH, nPid, 0)

    if nTimeoutMs then
        g_tWaitTimeouts[nPid] = {
            nDeadline = g_fUp() + nTimeoutMs / 1000,
            tDH       = tDH,
        }
    end

    g_tPT[nPid]._nWaitResult = nil
    g_tPT[nPid].status = "sleeping"
    g_tPT[nPid].wait_reason = "ke_wait"
    g_fYield()

    -- Woken up — read result from _nWaitResult (set by fSignalObject or ProcessWaitTimeouts)
    g_tWaitTimeouts[nPid] = nil
    local nResult = g_tPT[nPid]._nWaitResult or oIpc.STATUS_WAIT_0
    g_tPT[nPid]._nWaitResult = nil

    if nResult == oIpc.STATUS_TIMEOUT then
        g_tStats.nWaitsTimedOut = g_tStats.nWaitsTimedOut + 1
        return oIpc.STATUS_TIMEOUT
    end

    -- Post-acquisition for mutex/semaphore
    if tDH.nType == oIpc.WAIT_TYPE_MUTEX then fMutexAcquire(tBody, nPid) end
    if tDH.nType == oIpc.WAIT_TYPE_SEMAPHORE then fSemaphoreAcquire(tBody) end

    g_tStats.nWaitsSatisfied = g_tStats.nWaitsSatisfied + 1
    return nResult
end

function oIpc.KeWaitMultiple(nPid, tHandles, bWaitAll, nTimeoutMs)
    if not fCanBlock(nPid) then return oIpc.STATUS_FAILED end
    g_tStats.nWaitsIssued = g_tStats.nWaitsIssued + 1

    local tWaitObjs = {}
    for i, sH in ipairs(tHandles) do
        local tDH, tBody = fResolveWaitable(nPid, sH)
        if not tDH then return oIpc.STATUS_FAILED, "Handle " .. i .. " not waitable" end
        tWaitObjs[i] = {tDH = tDH, tBody = tBody, sHandle = sH}
    end

    -- Immediate check — WaitAll
    if bWaitAll then
        local bAllReady = true
        for _, wo in ipairs(tWaitObjs) do
            if not wo.tDH.bSignaled then bAllReady = false; break end
        end
        if bAllReady then
            for _, wo in ipairs(tWaitObjs) do
                if not wo.tDH.bManualReset then wo.tDH.bSignaled = false end
                if wo.tDH.nType == oIpc.WAIT_TYPE_MUTEX then fMutexAcquire(wo.tBody, nPid) end
                if wo.tDH.nType == oIpc.WAIT_TYPE_SEMAPHORE then fSemaphoreAcquire(wo.tBody) end
            end
            g_tStats.nWaitsSatisfied = g_tStats.nWaitsSatisfied + 1
            return oIpc.STATUS_WAIT_0
        end
    else
        -- Immediate check — WaitAny
        for i, wo in ipairs(tWaitObjs) do
            if wo.tDH.bSignaled then
                if not wo.tDH.bManualReset then wo.tDH.bSignaled = false end
                if wo.tDH.nType == oIpc.WAIT_TYPE_MUTEX then fMutexAcquire(wo.tBody, nPid) end
                if wo.tDH.nType == oIpc.WAIT_TYPE_SEMAPHORE then fSemaphoreAcquire(wo.tBody) end
                g_tStats.nWaitsSatisfied = g_tStats.nWaitsSatisfied + 1
                return oIpc.STATUS_WAIT_0 + i - 1
            end
        end
    end

    -- Must sleep
    local ctx = {tWaitObjs = tWaitObjs, bWaitAll = bWaitAll}
    g_tPT[nPid]._tWaitCtx = ctx

    for i, wo in ipairs(tWaitObjs) do
        fAddWaiter(wo.tDH, nPid, i - 1)
    end

    if nTimeoutMs then
        g_tWaitTimeouts[nPid] = {
            nDeadline = g_fUp() + nTimeoutMs / 1000,
            tDHList   = tWaitObjs,   -- so ProcessWaitTimeouts can clean up all wait lists
        }
    end

    g_tPT[nPid]._nWaitResult = nil
    g_tPT[nPid].status = "sleeping"
    g_tPT[nPid].wait_reason = "ke_wait"
    g_fYield()

    -- Woken up — cleanup
    g_tWaitTimeouts[nPid] = nil
    g_tPT[nPid]._tWaitCtx = nil
    for _, wo in ipairs(tWaitObjs) do fRemoveWaiter(wo.tDH, nPid) end

    local nResult = g_tPT[nPid]._nWaitResult or oIpc.STATUS_WAIT_0
    g_tPT[nPid]._nWaitResult = nil

    if nResult == oIpc.STATUS_TIMEOUT then
        g_tStats.nWaitsTimedOut = g_tStats.nWaitsTimedOut + 1
        return oIpc.STATUS_TIMEOUT
    end

    -- Post-acquisition for the specific object(s) that signaled
    if not bWaitAll then
        local nIdx = nResult - oIpc.STATUS_WAIT_0 + 1
        local wo = tWaitObjs[nIdx]
        if wo then
            if wo.tDH.nType == oIpc.WAIT_TYPE_MUTEX then fMutexAcquire(wo.tBody, nPid) end
            if wo.tDH.nType == oIpc.WAIT_TYPE_SEMAPHORE then fSemaphoreAcquire(wo.tBody) end
        end
    else
        for _, wo in ipairs(tWaitObjs) do
            if wo.tDH.nType == oIpc.WAIT_TYPE_MUTEX then fMutexAcquire(wo.tBody, nPid) end
            if wo.tDH.nType == oIpc.WAIT_TYPE_SEMAPHORE then fSemaphoreAcquire(wo.tBody) end
        end
    end

    g_tStats.nWaitsSatisfied = g_tStats.nWaitsSatisfied + 1
    return nResult
end

-- =============================================
-- 16. TICK (called once per scheduler iteration)
-- =============================================

function oIpc.ProcessWaitTimeouts()
    local nNow = g_fUp()
    for nPid, tTO in pairs(g_tWaitTimeouts) do
        if nNow >= tTO.nDeadline then
            local tW = g_tPT[nPid]
            if tW and tW.status == "sleeping" then
                -- Remove from dispatch header wait lists
                if tTO.tDH then
                    fRemoveWaiter(tTO.tDH, nPid)
                end
                if tTO.tDHList then
                    for _, wo in ipairs(tTO.tDHList) do
                        fRemoveWaiter(wo.tDH, nPid)
                    end
                end
                -- Clean up WaitMultiple context
                if tW._tWaitCtx then
                    for _, wo in ipairs(tW._tWaitCtx.tWaitObjs) do
                        fRemoveWaiter(wo.tDH, nPid)
                    end
                    tW._tWaitCtx = nil
                end
                -- Set result and wake
                tW._nWaitResult = oIpc.STATUS_TIMEOUT
                tW.status = "ready"
                g_fLog("[IPC] Timeout expired for PID " .. nPid)
            end
            g_tWaitTimeouts[nPid] = nil
        end
    end
end

function oIpc.Tick()
    oIpc.ProcessTimers()
    oIpc.ProcessWaitTimeouts()
    oIpc.ProcessDpcQueue()
end

-- =============================================
-- 17. STATISTICS
-- =============================================

function oIpc.GetStats()
    return {
        nDpcsProcessed    = g_tStats.nDpcsProcessed,
        nTimersFired      = g_tStats.nTimersFired,
        nSignalsSent      = g_tStats.nSignalsSent,
        nSignalsDelivered = g_tStats.nSignalsDelivered,
        nPipeCreated      = g_tStats.nPipeCreated,
        nPipeBytes        = g_tStats.nPipeBytes,
        nWaitsIssued      = g_tStats.nWaitsIssued,
        nWaitsSatisfied   = g_tStats.nWaitsSatisfied,
        nWaitsTimedOut    = g_tStats.nWaitsTimedOut,
        nMutexCreated     = g_tStats.nMutexCreated,
        nEventCreated     = g_tStats.nEventCreated,
        nSemCreated       = g_tStats.nSemCreated,
        nSectionCreated   = g_tStats.nSectionCreated,
        nMqCreated        = g_tStats.nMqCreated,
        nActiveDpcs       = #g_tDpcQueue,
        nActiveTimers     = (function() local n=0; for _ in pairs(g_tTimers) do n=n+1 end; return n end)(),
        nNamedPipes       = (function() local n=0; for _ in pairs(g_tNamedPipes) do n=n+1 end; return n end)(),
        nSections         = (function() local n=0; for _ in pairs(g_tSections) do n=n+1 end; return n end)(),
        nMQueues          = (function() local n=0; for _ in pairs(g_tMQueues) do n=n+1 end; return n end)(),
        nProcGroups       = (function() local n=0; for _ in pairs(g_tProcGroups) do n=n+1 end; return n end)(),
    }
end

return oIpc
```


axis-os\src\kernel\lib\machine_identity.lua
```
-- /lib/machine_identity.lua
-- Binds the OS installation to specific hardware.
-- Detects if someone copies the disk to another computer.

local crypto = require("crypto")
local oMachine = {}

local IDENTITY_FILE = "/etc/machine.id"

-- Generate a machine identity that's tied to THIS hardware
function oMachine.ComputeIdentity()
    local bOk = crypto.Init()
    if not bOk then return nil, "No data card" end
    
    -- Collect all hardware addresses
    local tAddrs = {}
    local bListOk, tList = pcall(function()
        local t = {}
        for addr, ctype in component.list() do t[#t+1] = ctype .. addr end
        return t
    end)
    if not bListOk then
        pcall(function()
            for addr, ctype in raw_component.list() do
                tAddrs[#tAddrs+1] = ctype .. addr
            end
        end)
    else
        tAddrs = tList
    end
    
    table.sort(tAddrs)
    local sFingerprint = table.concat(tAddrs, "|")
    
    -- Hash it
    return crypto.Encode64(crypto.SHA256(sFingerprint))
end

-- Check if current hardware matches stored identity
function oMachine.Verify()
    local fs = require("filesystem")
    
    local sCurrentId, sErr = oMachine.ComputeIdentity()
    if not sCurrentId then return nil, sErr end
    
    local h = fs.open(IDENTITY_FILE, "r")
    if not h then
        -- First boot on this hardware — store identity
        h = fs.open(IDENTITY_FILE, "w")
        if h then
            fs.write(h, sCurrentId)
            fs.close(h)
            fs.chmod(IDENTITY_FILE, 400)  -- read-only
            return true, "first_boot"
        end
        return nil, "Cannot write identity file"
    end
    
    local sStoredId = fs.read(h, math.huge)
    fs.close(h)
    
    if sStoredId == sCurrentId then
        return true, "verified"
    else
        return false, "HARDWARE MISMATCH: Disk may have been cloned to different machine"
    end
end

-- Monotonic boot counter (anti-replay)
-- Stored in EEPROM data area (survives disk cloning, tied to hardware)
function oMachine.IncrementBootCounter()
    local bOk, _ = pcall(function()
        local eep
        for addr in component.list("eeprom") do
            eep = component.proxy(addr)
            break
        end
        if not eep then return end
        
        local sData = eep.getData() or string.rep("\0", 256)
        
        -- Boot counter is at bytes 128-131 (big-endian uint32)
        local b1 = sData:byte(129) or 0
        local b2 = sData:byte(130) or 0
        local b3 = sData:byte(131) or 0
        local b4 = sData:byte(132) or 0
        local nCount = b1 * 16777216 + b2 * 65536 + b3 * 256 + b4
        
        nCount = nCount + 1
        
        -- Write back
        local sNew = sData:sub(1, 128) ..
                     string.char(math.floor(nCount / 16777216) % 256) ..
                     string.char(math.floor(nCount / 65536) % 256) ..
                     string.char(math.floor(nCount / 256) % 256) ..
                     string.char(nCount % 256) ..
                     sData:sub(133)
        
        eep.setData(sNew)
        return nCount
    end)
end

function oMachine.GetBootCount()
    local nCount = 0
    pcall(function()
        local eep
        for addr in component.list("eeprom") do
            eep = component.proxy(addr)
            break
        end
        if not eep then return end
        local sData = eep.getData() or ""
        if #sData >= 132 then
            nCount = (sData:byte(129) or 0) * 16777216 +
                     (sData:byte(130) or 0) * 65536 +
                     (sData:byte(131) or 0) * 256 +
                     (sData:byte(132) or 0)
        end
    end)
    return nCount
end

return oMachine
```


axis-os\src\kernel\lib\net.lua
```
--
-- /lib/net.lua
-- AxisOS networking library: TCP sockets + ping
--
-- local net = require("net")
-- local result = net.ping("example.com")
-- local sock = net.connect("example.com", 80)
--

local fs = require("filesystem")
local oNet = {}

local function fOpenNet()
  local h = fs.open("/dev/net", "r")
  if not h then return nil, "Network device not available" end
  return h
end

-- =============================================
-- PING
-- =============================================

function oNet.ping(sHost, nPort, nCount, nTimeout)
  local hNet, sErr = fOpenNet()
  if not hNet then return nil, sErr end

  local bOk, tResult = fs.deviceControl(hNet, "ping", {
    sHost, nPort or 80, nCount or 4, nTimeout or 5
  })

  fs.close(hNet)

  if bOk and type(tResult) == "table" then
    return tResult
  else
    return nil, tostring(tResult or "Ping failed")
  end
end

-- =============================================
-- TCP SOCKETS
-- =============================================

function oNet.connect(sHost, nPort, nTimeout)
  local hNet, sErr = fOpenNet()
  if not hNet then return nil, sErr end

  local bOk, tResult = fs.deviceControl(hNet, "tcp_connect", {
    sHost, nPort, nTimeout or 10
  })

  if not bOk or type(tResult) ~= "table" then
    fs.close(hNet)
    return nil, tostring(tResult or "Connect failed")
  end

  local tSock = {
    _hNet     = hNet,
    _nSession = tResult.nSessionId,
    _bClosed  = false,
    connectMs = tResult.nConnectMs or 0,
  }

  function tSock:write(sData)
    if self._bClosed then return nil, "Socket closed" end
    local bWrOk, nWritten = fs.deviceControl(self._hNet, "tcp_write", {
      self._nSession, sData
    })
    return bWrOk and nWritten or nil, nWritten
  end

  function tSock:read(nCount)
    if self._bClosed then return nil end
    local bRdOk, sData = fs.deviceControl(self._hNet, "tcp_read", {
      self._nSession, nCount or math.huge
    })
    if bRdOk and sData and type(sData) == "string" and #sData > 0 then
      return sData
    end
    return nil
  end

  function tSock:close()
    if self._bClosed then return end
    self._bClosed = true
    fs.deviceControl(self._hNet, "tcp_close", {self._nSession})
    fs.close(self._hNet)
  end

  return tSock
end

-- =============================================
-- UTILITIES
-- =============================================

function oNet.info()
  local hNet = fOpenNet()
  if not hNet then return nil end
  local bOk, tInfo = fs.deviceControl(hNet, "info", {})
  fs.close(hNet)
  return bOk and tInfo or nil
end

function oNet.sessions()
  local hNet = fOpenNet()
  if not hNet then return nil end
  local bOk, tList = fs.deviceControl(hNet, "session_list", {})
  fs.close(hNet)
  return bOk and tList or {}
end

function oNet.cleanup()
  local hNet = fOpenNet()
  if not hNet then return 0 end
  local bOk, nCleaned = fs.deviceControl(hNet, "session_cleanup", {})
  fs.close(hNet)
  return bOk and nCleaned or 0
end

return oNet
```


axis-os\src\kernel\lib\netfilter.lua
```
--
-- /lib/netfilter.lua
-- AxisOS Application-Level Network Policy Engine
-- Loaded by the internet driver at boot.
-- Provides: rule matching, connection tracking, host rewriting, audit logging.
--

local oNF = {}

-- =============================================
-- STATE
-- =============================================

local g_tRules = {}
local g_tHosts = {}
local g_tConnTracker = {}     -- [nPid] = { nCount, nBytes, tConns }
local g_tAuditLog = {}
local g_nMaxAuditEntries = 200
local g_bEnabled = true

-- Per-UID connection limits
local g_nMaxSessionsPerUid = 10

-- =============================================
-- LOADING
-- =============================================

function oNF.LoadRules(sCode)
  if not sCode or #sCode == 0 then
    g_tRules = {{ action = "allow", proto = "any", host = "*", port = "*", ring = "*" }}
    return true
  end
  local f = load(sCode, "netpolicy", "t", {})
  if f then
    local bOk, tResult = pcall(f)
    if bOk and type(tResult) == "table" then
      g_tRules = tResult
      return true
    end
  end
  return false
end

function oNF.LoadHosts(sCode)
  if not sCode or #sCode == 0 then
    g_tHosts = {}
    return true
  end
  local f = load(sCode, "hosts", "t", {})
  if f then
    local bOk, tResult = pcall(f)
    if bOk and type(tResult) == "table" then
      g_tHosts = tResult
      return true
    end
  end
  return false
end

function oNF.SetEnabled(b) g_bEnabled = b end
function oNF.IsEnabled() return g_bEnabled end

-- =============================================
-- HOST RESOLUTION
-- =============================================

-- Extract hostname from a URL
local function fExtractHost(sUrl)
  -- http://host:port/path or https://host/path or host:port
  local sHost = sUrl:match("^https?://([^/:]+)")
  if not sHost then
    sHost = sUrl:match("^([^/:]+)")
  end
  return sHost
end

-- Extract port from URL or default
local function fExtractPort(sUrl)
  local sPort = sUrl:match("^https?://[^/:]+:(%d+)")
  if sPort then return tonumber(sPort) end
  if sUrl:sub(1, 5) == "https" then return 443 end
  return 80
end

-- Rewrite URL based on /etc/hosts
function oNF.RewriteHost(sUrl)
  if not sUrl then return sUrl end
  local sHost = fExtractHost(sUrl)
  if not sHost then return sUrl end

  local sTarget = g_tHosts[sHost]
  if not sTarget then return sUrl end

  -- If target is 0.0.0.0 or 127.0.0.1, block
  if sTarget == "0.0.0.0" or sTarget == "127.0.0.1" then
    return nil, "Blocked by /etc/hosts: " .. sHost
  end

  -- Replace hostname in URL
  local sNewUrl = sUrl:gsub(sHost, sTarget, 1)
  return sNewUrl
end

-- Rewrite a raw host (for TCP connect)
function oNF.RewriteTcpHost(sHost)
  if not sHost then return sHost end
  local sTarget = g_tHosts[sHost]
  if not sTarget then return sHost end
  if sTarget == "0.0.0.0" or sTarget == "127.0.0.1" then
    return nil, "Blocked by /etc/hosts: " .. sHost
  end
  return sTarget
end

-- =============================================
-- RULE MATCHING
-- =============================================

local function fMatchField(sRuleVal, sActual)
  if sRuleVal == "*" then return true end
  if type(sRuleVal) == "number" and type(sActual) == "number" then
    return sRuleVal == sActual
  end
  if type(sRuleVal) == "string" and type(sActual) == "string" then
    -- try exact match first
    if sRuleVal == sActual then return true end
    -- then Lua pattern match
    local bOk, bMatch = pcall(function()
      return sActual:match("^" .. sRuleVal .. "$") ~= nil
    end)
    return bOk and bMatch
  end
  return tostring(sRuleVal) == tostring(sActual)
end

-- Check if a connection is allowed.
-- Returns: "allow", "deny", or "log" (allow + audit)
-- Plus the matched rule for logging.
function oNF.CheckPolicy(sProto, sHost, nPort, nRing, nUid)
  if not g_bEnabled then return "allow", nil end

  for _, tRule in ipairs(g_tRules) do
    local bProtoMatch = fMatchField(tRule.proto or "*", sProto)
                     or fMatchField(tRule.proto or "*", "any")
    local bHostMatch  = fMatchField(tRule.host or "*", sHost or "")
    local bPortMatch  = fMatchField(tRule.port or "*", nPort or 0)
    local bRingMatch  = fMatchField(tRule.ring or "*", nRing or 3)

    -- UID matching (optional field)
    local bUidMatch = true
    if tRule.uid and tRule.uid ~= "*" then
      bUidMatch = fMatchField(tRule.uid, nUid or 1000)
    end

    if bProtoMatch and bHostMatch and bPortMatch and bRingMatch and bUidMatch then
      return tRule.action or "allow", tRule
    end
  end

  -- default allow if no rules matched
  return "allow", nil
end

-- =============================================
-- CONNECTION TRACKING
-- =============================================

function oNF.TrackConnect(nPid, nUid, sProto, sHost, nPort, nSessionId)
  if not g_tConnTracker[nPid] then
    g_tConnTracker[nPid] = {
      nUid   = nUid or 1000,
      nCount = 0,
      nBytes = 0,
      tConns = {},
    }
  end
  local tTracker = g_tConnTracker[nPid]
  tTracker.nCount = tTracker.nCount + 1
  tTracker.tConns[nSessionId] = {
    sProto   = sProto,
    sHost    = sHost,
    nPort    = nPort,
    nStart   = os.clock(),
    nBytes   = 0,
    sStatus  = "open",
  }
  return true
end

function oNF.TrackBytes(nPid, nSessionId, nBytes)
  local tTracker = g_tConnTracker[nPid]
  if not tTracker then return end
  tTracker.nBytes = tTracker.nBytes + nBytes
  local tConn = tTracker.tConns[nSessionId]
  if tConn then tConn.nBytes = tConn.nBytes + nBytes end
end

function oNF.TrackClose(nPid, nSessionId)
  local tTracker = g_tConnTracker[nPid]
  if not tTracker then return end
  local tConn = tTracker.tConns[nSessionId]
  if tConn then
    tConn.sStatus = "closed"
    tConn.nEnd = os.clock()
  end
  tTracker.nCount = math.max(0, tTracker.nCount - 1)
end

function oNF.GetProcessStats(nPid)
  return g_tConnTracker[nPid]
end

function oNF.GetAllStats()
  local tResult = {}
  for nPid, tT in pairs(g_tConnTracker) do
    table.insert(tResult, {
      nPid   = nPid,
      nUid   = tT.nUid,
      nActive = tT.nCount,
      nBytes = tT.nBytes,
    })
  end
  table.sort(tResult, function(a, b) return a.nPid < b.nPid end)
  return tResult
end

-- Check per-UID connection limit
function oNF.CheckConnectionLimit(nUid)
  local nTotal = 0
  for _, tT in pairs(g_tConnTracker) do
    if tT.nUid == nUid then
      nTotal = nTotal + tT.nCount
    end
  end
  return nTotal < g_nMaxSessionsPerUid, nTotal
end

function oNF.SetConnectionLimit(n)
  g_nMaxSessionsPerUid = n
end

-- =============================================
-- AUDIT LOG
-- =============================================

function oNF.Audit(sAction, sProto, sHost, nPort, nPid, nUid, sComment)
  table.insert(g_tAuditLog, {
    nTime    = os.clock(),
    sAction  = sAction,
    sProto   = sProto,
    sHost    = sHost or "?",
    nPort    = nPort or 0,
    nPid     = nPid or 0,
    nUid     = nUid or 0,
    sComment = sComment or "",
  })
  if #g_tAuditLog > g_nMaxAuditEntries then
    table.remove(g_tAuditLog, 1)
  end
end

function oNF.GetAuditLog()
  return g_tAuditLog
end

function oNF.ClearAuditLog()
  g_tAuditLog = {}
end

-- =============================================
-- DUMP (for debug)
-- =============================================

function oNF.DumpRules()
  return g_tRules
end

function oNF.DumpHosts()
  return g_tHosts
end

return oNF
```


axis-os\src\kernel\lib\ob_manager.lua
```
--
-- /lib/ob_manager.lua
-- AxisOS Object Manager — WDM Model
--
-- Implements the kernel object namespace, per-process handle tables,
-- reference-counted object headers, typed objects, access masks,
-- sMLTR-bound handles, standard I/O handle slots, and inheritable
-- handle duplication.
--
-- No file descriptors. No aliases. Handles are opaque tokens.
--

local oOb = {}

-- =============================================
-- CONSTANTS
-- =============================================

-- Object Types (IoCreateDevice, ObCreateObjectType, etc.)
oOb.OB_TYPE_DIRECTORY   = "ObpDirectory"
oOb.OB_TYPE_SYMLINK     = "ObpSymbolicLink"
oOb.OB_TYPE_DEVICE      = "IoDeviceObject"
oOb.OB_TYPE_FILE        = "IoFileObject"
oOb.OB_TYPE_DRIVER      = "IoDriverObject"
oOb.OB_TYPE_EVENT       = "KeEvent"
oOb.OB_TYPE_SECTION     = "MmSectionObject"

-- Access Mask Bits
oOb.ACCESS_READ            = 0x0001
oOb.ACCESS_WRITE           = 0x0002
oOb.ACCESS_EXECUTE         = 0x0004
oOb.ACCESS_DEVICE_CONTROL  = 0x0008
oOb.ACCESS_DELETE          = 0x0010
oOb.ACCESS_READ_ATTRIBUTES = 0x0020
oOb.ACCESS_SYNCHRONIZE     = 0x0040
oOb.ACCESS_ALL             = 0x007F

-- Generic Access (mapped at open time like GENERIC_READ/GENERIC_WRITE)
oOb.GENERIC_READ    = 0x0021  -- READ | READ_ATTRIBUTES
oOb.GENERIC_WRITE   = 0x0002
oOb.GENERIC_EXECUTE = 0x0004
oOb.GENERIC_ALL     = 0x007F

-- Well-Known Standard Handle Indices (GetStdHandle/SetStdHandle)
oOb.STD_INPUT_HANDLE  = -10
oOb.STD_OUTPUT_HANDLE = -11
oOb.STD_ERROR_HANDLE  = -12

-- Status Codes (NTSTATUS style)
oOb.STATUS_SUCCESS                = 0
oOb.STATUS_OBJECT_NAME_NOT_FOUND  = 0xC0000034
oOb.STATUS_OBJECT_NAME_COLLISION  = 0xC0000035
oOb.STATUS_OBJECT_TYPE_MISMATCH   = 0xC0000024
oOb.STATUS_INVALID_HANDLE         = 0xC0000008
oOb.STATUS_ACCESS_DENIED          = 0xC0000022
oOb.STATUS_OBJECT_NAME_INVALID    = 0xC0000033
oOb.STATUS_HANDLE_NOT_CLOSABLE    = 0xC0000235
oOb.STATUS_DELETE_PENDING         = 0xC0000056

-- =============================================
-- INTERNAL STATE
-- =============================================

local g_tObjectDirectory = {}       -- sKernelPath -> OBJECT_HEADER
local g_tProcessHandleTables = {}   -- nPid -> PROCESS_HANDLE_TABLE
local g_tObjectTypes = {}           -- sTypeName -> TYPE_OBJECT

local g_nHandleEntropy  = 0
local g_nObjectIdSeq    = 0

-- =============================================
-- BIT HELPERS (Lua 5.2 safe)
-- =============================================

local bit32 = bit32

local function fCheckAccess(nGranted, nRequired)
    if nRequired == 0 then return true end
    if bit32 then
        return bit32.band(nGranted, nRequired) == nRequired
    end
    local nBit = 1
    while nBit <= nRequired do
        local nReqBit  = math.floor(nRequired / nBit) % 2
        local nGranBit = math.floor(nGranted  / nBit) % 2
        if nReqBit == 1 and nGranBit == 0 then return false end
        nBit = nBit * 2
    end
    return true
end

-- =============================================
-- ENTROPY
-- =============================================

local function fUptime()
    local n = 0
    pcall(function()
        if raw_computer then n = math.floor(raw_computer.uptime() * 100000)
        else n = math.floor(os.clock() * 100000) end
    end)
    return n
end

local function fGenerateToken(sPrefix)
    g_nHandleEntropy = g_nHandleEntropy + 1
    local t = fUptime()
    return string.format("%s%06x-%05x-%04x-%04x",
        sPrefix or "H-",
        math.random(0, 0xFFFFFF),
        t % 0xFFFFF,
        math.random(0, 0xFFFF),
        (g_nHandleEntropy * 7 + math.random(0, 0xFF)) % 0xFFFF)
end

local function fNextObjectId()
    g_nObjectIdSeq = g_nObjectIdSeq + 1
    return g_nObjectIdSeq
end

-- =============================================
-- OBJECT TYPE REGISTRATION
-- (ObCreateObjectType)
-- =============================================

function oOb.ObCreateObjectType(sTypeName, tProcs)
    g_tObjectTypes[sTypeName] = {
        sTypeName        = sTypeName,
        fDeleteProcedure = tProcs.fDeleteProcedure,  -- ref→0: destroy body
        fCloseProcedure  = tProcs.fCloseProcedure,   -- per-handle close
        fOpenProcedure   = tProcs.fOpenProcedure,    -- post-lookup open
        fParseProcedure  = tProcs.fParseProcedure,   -- name parsing into sub-objects
        nTotalObjects    = 0,
        nTotalHandles    = 0,
    }
end

function oOb.ObGetObjectType(sTypeName)
    return g_tObjectTypes[sTypeName]
end

-- =============================================
-- OBJECT HEADER LIFECYCLE
-- (ObCreateObject, ObReferenceObject, ObDereferenceObject)
-- =============================================

function oOb.ObCreateObject(sType, tBody)
    local pType = g_tObjectTypes[sType]

    local pHeader = {
        nObjectId       = fNextObjectId(),
        sType           = sType,
        sName           = nil,            -- set by ObInsertObject
        nReferenceCount = 1,              -- creator holds initial ref
        nHandleCount    = 0,
        tSecurity       = {
            nOwnerUid = 0,
            nGroupGid = 0,
            nMode     = 755,
        },
        pBody           = tBody or {},
        bPermanent      = false,
        bDeletePending  = false,
        pTypeObject     = pType,
    }

    if pType then pType.nTotalObjects = pType.nTotalObjects + 1 end
    return pHeader
end

function oOb.ObReferenceObject(pH)
    if pH then pH.nReferenceCount = pH.nReferenceCount + 1 end
end

function oOb.ObDereferenceObject(pH)
    if not pH then return end
    pH.nReferenceCount = pH.nReferenceCount - 1
    if pH.nReferenceCount <= 0 and pH.nHandleCount <= 0 and not pH.bPermanent then
        if pH.pTypeObject and pH.pTypeObject.fDeleteProcedure then
            pcall(pH.pTypeObject.fDeleteProcedure, pH)
        end
        if pH.sName then g_tObjectDirectory[pH.sName] = nil end
        if pH.pTypeObject then
            pH.pTypeObject.nTotalObjects = pH.pTypeObject.nTotalObjects - 1
        end
    end
end

-- =============================================
-- KERNEL NAMESPACE (OBJECT DIRECTORY)
-- (ObInsertObject, ObLookupObject, ObDeleteObject)
-- =============================================

function oOb.ObInsertObject(pH, sPath)
    if not sPath or #sPath == 0 then return oOb.STATUS_OBJECT_NAME_INVALID end
    if g_tObjectDirectory[sPath]  then return oOb.STATUS_OBJECT_NAME_COLLISION end
    pH.sName = sPath
    g_tObjectDirectory[sPath] = pH
    return oOb.STATUS_SUCCESS
end

function oOb.ObLookupObject(sPath, nMaxDepth)
    nMaxDepth = nMaxDepth or 8
    local pH = g_tObjectDirectory[sPath]
    if not pH then return nil, oOb.STATUS_OBJECT_NAME_NOT_FOUND end
    -- transparently chase symlinks
    if pH.sType == oOb.OB_TYPE_SYMLINK and nMaxDepth > 0 then
        local sTarget = pH.pBody and pH.pBody.sTargetPath
        if sTarget then return oOb.ObLookupObject(sTarget, nMaxDepth - 1) end
    end
    return pH, oOb.STATUS_SUCCESS
end

function oOb.ObDeleteObject(sPath)
    local pH = g_tObjectDirectory[sPath]
    if not pH then return oOb.STATUS_OBJECT_NAME_NOT_FOUND end
    g_tObjectDirectory[sPath] = nil
    pH.sName = nil
    pH.bDeletePending = true
    oOb.ObDereferenceObject(pH)
    return oOb.STATUS_SUCCESS
end

-- =============================================
-- SYMBOLIC LINKS
-- (IoCreateSymbolicLink / IoDeleteSymbolicLink)
-- =============================================

function oOb.ObCreateSymbolicLink(sLinkPath, sTargetPath)
    local pH = oOb.ObCreateObject(oOb.OB_TYPE_SYMLINK, {
        sTargetPath = sTargetPath,
    })
    pH.bPermanent = true
    return oOb.ObInsertObject(pH, sLinkPath)
end

function oOb.ObDeleteSymbolicLink(sPath)
    return oOb.ObDeleteObject(sPath)
end

-- =============================================
-- DIRECTORY ENUMERATION
-- =============================================

function oOb.ObListDirectory(sPrefix)
    if sPrefix:sub(-1) ~= "\\" then sPrefix = sPrefix .. "\\" end
    local tOut = {}
    for sObjPath, pH in pairs(g_tObjectDirectory) do
        if #sObjPath > #sPrefix and sObjPath:sub(1, #sPrefix) == sPrefix then
            local sRem = sObjPath:sub(#sPrefix + 1)
            if not sRem:find("\\") then
                table.insert(tOut, {
                    sName     = sRem,
                    sFullPath = sObjPath,
                    sType     = pH.sType,
                })
            end
        end
    end
    return tOut
end

-- =============================================
-- PER-PROCESS HANDLE TABLE
-- =============================================

local function fNewHandleTable()
    return {
        tEntries         = {},   -- sToken -> HANDLE_ENTRY
        tStandardHandles = {},   -- nStdIndex -> sToken
    }
end

function oOb.ObInitializeProcess(nPid)
    if not g_tProcessHandleTables[nPid] then
        g_tProcessHandleTables[nPid] = fNewHandleTable()
    end
end

function oOb.ObDestroyProcess(nPid)
    local tHT = g_tProcessHandleTables[nPid]
    if not tHT then return end
    for sToken, tEntry in pairs(tHT.tEntries) do
        local pH = tEntry.pObjectHeader
        if pH then
            pH.nHandleCount = pH.nHandleCount - 1
            if pH.pTypeObject and pH.pTypeObject.fCloseProcedure then
                pcall(pH.pTypeObject.fCloseProcedure, pH, nPid, tEntry)
            end
            if pH.pTypeObject then
                pH.pTypeObject.nTotalHandles = pH.pTypeObject.nTotalHandles - 1
            end
            -- if nothing else references it, clean up
            if pH.nReferenceCount <= 0 and pH.nHandleCount <= 0 and not pH.bPermanent then
                if pH.pTypeObject and pH.pTypeObject.fDeleteProcedure then
                    pcall(pH.pTypeObject.fDeleteProcedure, pH)
                end
                if pH.sName then g_tObjectDirectory[pH.sName] = nil end
            end
        end
    end
    g_tProcessHandleTables[nPid] = nil
end

-- =============================================
-- HANDLE OPERATIONS
-- =============================================

--  ObCreateHandle(nPid, pObjectHeader, nDesiredAccess, sSynapseToken [, bInheritable])
--  → sHandleToken, nStatus
--
--  Access is checked HERE. Every subsequent use only validates token + sMLTR.
function oOb.ObCreateHandle(nPid, pH, nDesiredAccess, sSynapseToken, bInheritable)
    if not pH then return nil, oOb.STATUS_INVALID_HANDLE end
    oOb.ObInitializeProcess(nPid)
    local tHT = g_tProcessHandleTables[nPid]

    -- TODO: SeAccessCheck against pH.tSecurity.  For now, grant what was requested.
    local nGranted = nDesiredAccess or oOb.ACCESS_ALL

    local sToken = fGenerateToken("H-")
    while tHT.tEntries[sToken] do sToken = fGenerateToken("H-") end

    tHT.tEntries[sToken] = {
        pObjectHeader  = pH,
        nGrantedAccess = nGranted,
        sSynapseToken  = sSynapseToken,
        bInheritable   = (bInheritable ~= false),
        nCreationTime  = fUptime(),
    }

    pH.nHandleCount = pH.nHandleCount + 1
    if pH.pTypeObject then
        pH.pTypeObject.nTotalHandles = pH.pTypeObject.nTotalHandles + 1
    end

    return sToken, oOb.STATUS_SUCCESS
end

--  ObOpenObjectByName — lookup + ref + create handle
function oOb.ObOpenObjectByName(nPid, sPath, nDesiredAccess, sSynapseToken)
    local pH, nSt = oOb.ObLookupObject(sPath)
    if not pH then return nil, nSt end
    if pH.bDeletePending then return nil, oOb.STATUS_DELETE_PENDING end

    oOb.ObReferenceObject(pH)
    local sToken, nCreateSt = oOb.ObCreateHandle(nPid, pH, nDesiredAccess, sSynapseToken)
    if not sToken then
        oOb.ObDereferenceObject(pH)
        return nil, nCreateSt
    end
    return sToken, oOb.STATUS_SUCCESS
end

--  ObReferenceObjectByHandle — validate token, sMLTR, access → OBJECT_HEADER
--
--  vHandle may be:
--      string  → direct token lookup
--      number < 0  → standard-handle constant (STD_INPUT_HANDLE etc.)
--
--  Returns: pObjectHeader, nStatus, tHandleEntry
function oOb.ObReferenceObjectByHandle(nPid, vHandle, nDesiredAccess, sSynapseToken)
    local tHT = g_tProcessHandleTables[nPid]
    if not tHT then return nil, oOb.STATUS_INVALID_HANDLE end

    -- resolve standard-handle constants
    local sRealToken = vHandle
    if type(vHandle) == "number" and vHandle < 0 then
        sRealToken = tHT.tStandardHandles[vHandle]
        if not sRealToken then return nil, oOb.STATUS_INVALID_HANDLE end
    end

    local tEntry = tHT.tEntries[sRealToken]
    if not tEntry then return nil, oOb.STATUS_INVALID_HANDLE end

    -- sMLTR validation (skip for system PIDs < 20)
    if nPid >= 20 and tEntry.sSynapseToken and sSynapseToken then
        if tEntry.sSynapseToken ~= sSynapseToken then
            return nil, oOb.STATUS_ACCESS_DENIED
        end
    end

    -- access-mask check
    if nDesiredAccess and nDesiredAccess > 0 then
        if not fCheckAccess(tEntry.nGrantedAccess, nDesiredAccess) then
            return nil, oOb.STATUS_ACCESS_DENIED
        end
    end

    return tEntry.pObjectHeader, oOb.STATUS_SUCCESS, tEntry
end

--  ObCloseHandle — remove entry, dereference object
function oOb.ObCloseHandle(nPid, vHandle)
    local tHT = g_tProcessHandleTables[nPid]
    if not tHT then return false, oOb.STATUS_INVALID_HANDLE end

    local sRealToken = vHandle
    if type(vHandle) == "number" and vHandle < 0 then
        sRealToken = tHT.tStandardHandles[vHandle]
        if not sRealToken then return false, oOb.STATUS_INVALID_HANDLE end
        tHT.tStandardHandles[vHandle] = nil
    end

    local tEntry = tHT.tEntries[sRealToken]
    if not tEntry then return false, oOb.STATUS_INVALID_HANDLE end

    local pH = tEntry.pObjectHeader
    tHT.tEntries[sRealToken] = nil

    -- clean up any standard-handle slots pointing at this token
    for nK, sV in pairs(tHT.tStandardHandles) do
        if sV == sRealToken then tHT.tStandardHandles[nK] = nil end
    end

    if pH then
        pH.nHandleCount = pH.nHandleCount - 1
        if pH.pTypeObject and pH.pTypeObject.fCloseProcedure then
            pcall(pH.pTypeObject.fCloseProcedure, pH, nPid, tEntry)
        end
        if pH.pTypeObject then
            pH.pTypeObject.nTotalHandles = pH.pTypeObject.nTotalHandles - 1
        end
        oOb.ObDereferenceObject(pH)
    end

    return true, oOb.STATUS_SUCCESS
end

-- =============================================
-- STANDARD HANDLES  (SetStdHandle / GetStdHandle)
-- =============================================

function oOb.ObSetStandardHandle(nPid, nIndex, sToken)
    oOb.ObInitializeProcess(nPid)
    g_tProcessHandleTables[nPid].tStandardHandles[nIndex] = sToken
    return true
end

function oOb.ObGetStandardHandle(nPid, nIndex)
    local tHT = g_tProcessHandleTables[nPid]
    if not tHT then return nil end
    return tHT.tStandardHandles[nIndex]
end

-- =============================================
-- HANDLE INHERITANCE
-- (NtInheritHandles — called during process creation)
-- =============================================

function oOb.ObInheritHandles(nParentPid, nChildPid, sChildSynapseToken)
    local tParent = g_tProcessHandleTables[nParentPid]
    if not tParent then return end
    oOb.ObInitializeProcess(nChildPid)
    local tChild = g_tProcessHandleTables[nChildPid]

    local tTokenMap = {}  -- parent-token → child-token

    for sParentToken, tEntry in pairs(tParent.tEntries) do
        if tEntry.bInheritable and tEntry.pObjectHeader then
            local pH = tEntry.pObjectHeader
            oOb.ObReferenceObject(pH)

            local sChildToken = fGenerateToken("H-")
            while tChild.tEntries[sChildToken] do sChildToken = fGenerateToken("H-") end

            tChild.tEntries[sChildToken] = {
                pObjectHeader  = pH,
                nGrantedAccess = tEntry.nGrantedAccess,
                sSynapseToken  = sChildSynapseToken,   -- REBIND
                bInheritable   = tEntry.bInheritable,
                nCreationTime  = fUptime(),
            }
            pH.nHandleCount = pH.nHandleCount + 1

            tTokenMap[sParentToken] = sChildToken
        end
    end

    -- map standard-handle slots
    for nStdKey, sParentToken in pairs(tParent.tStandardHandles) do
        if tTokenMap[sParentToken] then
            tChild.tStandardHandles[nStdKey] = tTokenMap[sParentToken]
        end
    end
end

-- =============================================
-- DUPLICATE HANDLE  (DuplicateHandle)
-- =============================================

function oOb.ObDuplicateHandle(nSrcPid, sSrcToken, nDstPid, nDesiredAccess, sSynapseToken)
    local tSrc = g_tProcessHandleTables[nSrcPid]
    if not tSrc then return nil, oOb.STATUS_INVALID_HANDLE end
    local tEntry = tSrc.tEntries[sSrcToken]
    if not tEntry or not tEntry.pObjectHeader then
        return nil, oOb.STATUS_INVALID_HANDLE
    end

    local pH = tEntry.pObjectHeader
    oOb.ObReferenceObject(pH)

    local nAcc = nDesiredAccess or tEntry.nGrantedAccess
    local sNew, nSt = oOb.ObCreateHandle(nDstPid, pH, nAcc, sSynapseToken)
    if not sNew then oOb.ObDereferenceObject(pH); return nil, nSt end
    return sNew, oOb.STATUS_SUCCESS
end

-- =============================================
-- QUERY / DEBUG  (!handle, !object, dt)
-- =============================================

function oOb.ObQueryObjectType(pH)  return pH and pH.sType end
function oOb.ObQueryObjectName(pH)  return pH and pH.sName end

function oOb.ObQueryObjectSecurity(pH)
    return pH and pH.tSecurity
end

function oOb.ObSetObjectSecurity(pH, tNew)
    if not pH then return false end
    for k, v in pairs(tNew) do pH.tSecurity[k] = v end
    return true
end

function oOb.ObListHandles(nPid)
    local tHT = g_tProcessHandleTables[nPid]
    if not tHT then return {} end
    local t = {}
    for sToken, tE in pairs(tHT.tEntries) do
        local pH = tE.pObjectHeader
        table.insert(t, {
            sToken         = sToken,
            sType          = pH and pH.sType or "INVALID",
            sName          = pH and pH.sName or "(unnamed)",
            nGrantedAccess = tE.nGrantedAccess,
            nRefCount      = pH and pH.nReferenceCount or 0,
            nHandleCount   = pH and pH.nHandleCount or 0,
            bInheritable   = tE.bInheritable,
        })
    end
    return t
end

function oOb.ObQueryTypeStatistics(sTypeName)
    local p = g_tObjectTypes[sTypeName]
    if not p then return nil end
    return { sTypeName = p.sTypeName, nTotalObjects = p.nTotalObjects, nTotalHandles = p.nTotalHandles }
end

function oOb.ObDumpDirectory()
    local t = {}
    for sPath, pH in pairs(g_tObjectDirectory) do
        table.insert(t, {
            sPath        = sPath,
            sType        = pH.sType,
            nRefCount    = pH.nReferenceCount,
            nHandleCount = pH.nHandleCount,
        })
    end
    table.sort(t, function(a, b) return a.sPath < b.sPath end)
    return t
end

-- =============================================
-- BOOT-TIME INITIALIZATION
-- =============================================

function oOb.ObInitSystem()
    -- register built-in types (procedures are no-ops; PM registers real ones later)
    local tEmpty = {}
    oOb.ObCreateObjectType(oOb.OB_TYPE_DIRECTORY, tEmpty)
    oOb.ObCreateObjectType(oOb.OB_TYPE_SYMLINK,   tEmpty)
    oOb.ObCreateObjectType(oOb.OB_TYPE_DEVICE,    tEmpty)
    oOb.ObCreateObjectType(oOb.OB_TYPE_FILE,      tEmpty)
    oOb.ObCreateObjectType(oOb.OB_TYPE_DRIVER,    tEmpty)
    oOb.ObCreateObjectType(oOb.OB_TYPE_EVENT,     tEmpty)
    oOb.ObCreateObjectType(oOb.OB_TYPE_SECTION,   tEmpty)

    -- create root namespace directories
    local function mkDir(sPath)
        local p = oOb.ObCreateObject(oOb.OB_TYPE_DIRECTORY, {})
        p.bPermanent = true
        oOb.ObInsertObject(p, sPath)
    end
    mkDir("\\")
    mkDir("\\Device")
    mkDir("\\DosDevices")
    mkDir("\\ObjectTypes")
end

return oOb
```


axis-os\src\kernel\lib\pipe.lua
```
--
-- /lib/pipe.lua — User-space pipe API
--

local oPipe = {}

function oPipe.create(nBufSize)
    local hRead, hWrite = syscall("ke_create_pipe", nBufSize or 4096)
    if not hRead then return nil, hWrite end
    return {
        read  = hRead,
        write = hWrite,
        _open = true,
    }
end

function oPipe.createNamed(sName, nBufSize)
    local hR, hW = syscall("ke_create_named_pipe", sName, nBufSize or 4096)
    if not hR then return nil, hW end
    return {read = hR, write = hW, _open = true, name = sName}
end

function oPipe.connectNamed(sName)
    local h, sErr = syscall("ke_connect_named_pipe", sName)
    if not h then return nil, sErr end
    return {handle = h, _open = true, name = sName}
end

function oPipe.write(hWrite, sData)
    return syscall("ke_pipe_write", hWrite, sData)
end

function oPipe.read(hRead, nCount)
    return syscall("ke_pipe_read", hRead, nCount or math.huge)
end

function oPipe.closeRead(hRead)
    return syscall("ke_pipe_close", hRead, false)
end

function oPipe.closeWrite(hWrite)
    return syscall("ke_pipe_close", hWrite, true)
end

return oPipe
```


axis-os\src\kernel\lib\pipeline_manager.lua
```
--
-- /lib/pipeline_manager.lua
-- VFS Router with Object Handle & sMLTR Support
-- v3: Per-process handle tokens, synapse token validation, handle inheritance.
--

local syscall = syscall

syscall("kernel_register_pipeline")
syscall("kernel_log", "[PM] Ring 1 Pipeline Manager started.")

local nMyPid = syscall("process_get_pid") 

local tPermCache = nil

local nDkmsPid, sDkmsErr = syscall("process_spawn", "/system/dkms.lua", 1)
if not nDkmsPid then syscall("kernel_panic", "Could not spawn DKMS: " .. tostring(sDkmsErr)) end
syscall("kernel_log", "[PM] DKMS process started as PID " .. tostring(nDkmsPid))

local vfs_state = { oRootFs = nil }
local g_tPmInternal = {}     -- [nId] -> { type, devname, driverPid, rawHandle }
local g_nPmNextInternal = 1
-- local tProcessNextAlias = {} -- [pid] = next alias number for that process
local g_tPmSignalBuffer = {}
local g_nRingFsId  = nil      -- internal PM FD for ringfs (kept open for ongoing writes)
local g_tLogState   = nil      -- permanent log file handles { hLogFile, hVblFile, ... }
local g_tSysConfig  = nil      -- parsed /etc/sys.cfg

syscall("syscall_override", "vfs_open")
syscall("syscall_override", "vfs_read")
syscall("syscall_override", "vfs_write")
syscall("syscall_override", "vfs_close")
syscall("syscall_override", "vfs_list")
syscall("syscall_override", "vfs_delete")
syscall("syscall_override", "vfs_mkdir")
syscall("syscall_override", "vfs_chmod")
syscall("syscall_override", "vfs_device_control")

syscall("syscall_override", "driver_load")


local function parse_options(sOptions)
  local tOpts = {}
  if not sOptions then return tOpts end
  for sPart in string.gmatch(sOptions, "[^,]+") do
    local k, v = sPart:match("([^=]+)=(.*)")
    if k then 
      tOpts[k] = tonumber(v) or v 
    else
      tOpts[sPart] = true
    end
  end
  return tOpts
end

-- ==========================================
-- sMLTR HELPERS
-- ==========================================


local OB_ACCESS_READ    = 0x0001
local OB_ACCESS_WRITE   = 0x0002
local OB_ACCESS_DEVCTL  = 0x0008

local function fResolveObject(nCallerPid, sSynapseToken, vHandle, nAccess)
    local pObj, nSt = syscall("ob_reference_by_handle",
                              nCallerPid, vHandle, nAccess, sSynapseToken)
    if not pObj then
        return nil, "Handle invalid or access denied (status " .. tostring(nSt) .. ")"
    end
    return pObj
end

--[[
-- Validate that the caller's synapse token matches what's stored in the handle.
-- Returns true if valid, false + reason if not.
local function fValidateSynapseToken(nCallerPid, sSynapseToken, tObjectHeader)
  if not tObjectHeader then return false, "No object header" end
  -- System processes (PID < 20) bypass sMLTR
  if nCallerPid < 20 then return true end
  -- If handle has no token stored (legacy), allow access but log
  if not tObjectHeader.sSynapseToken then return true end
  -- The actual check
  if tObjectHeader.sSynapseToken ~= sSynapseToken then
    syscall("kernel_log", "[PM] sMLTR VIOLATION: PID " .. nCallerPid .. " token mismatch on handle")
    return false, "Synapse token mismatch"
  end
  return true
end

-- Resolve a handle (token string or numeric alias) for a given process.
-- Uses kernel ob_manager syscalls. Returns the internal FD and the object header.
local function fResolveHandle(nCallerPid, sSynapseToken, vHandle)
  local tObj = syscall("ob_resolve_handle", nCallerPid, vHandle)
  if not tObj then
    -- Auto-create standard aliases for FDs 0, 1, 2 if they don't exist yet
    if type(vHandle) == "number" and vHandle <= 2 then
      local bOk, sToken = fAutoCreateStdHandle(nCallerPid, sSynapseToken, vHandle)
      if bOk then
        tObj = syscall("ob_resolve_handle", nCallerPid, vHandle)
      end
    end
    if not tObj then return nil, nil, "Handle not found" end
  end
  
  -- sMLTR validation
  local bValid, sReason = fValidateSynapseToken(nCallerPid, sSynapseToken, tObj)
  if not bValid then return nil, nil, sReason end
  
  return tObj.nInternalFd, tObj
end

-- Auto-create standard I/O handles (stdin=0, stdout=1, stderr=2)
-- This handles the case where a child process uses print() / fd 1
-- without having explicitly opened /dev/tty.
function fAutoCreateStdHandle(nCallerPid, sSynapseToken, nAlias)
  syscall("kernel_log", "[PM] Auto-creating std handle alias " .. nAlias .. " for PID " .. nCallerPid)
  
  -- Open /dev/tty for this process
  local sMode = (nAlias == 0) and "r" or "w"
  
  -- Do the internal open (we are PM, we call ourselves)
  local bOk, nFd = _doInternalOpen(nMyPid, "/dev/tty", sMode)
  if not bOk then return false end
  
  -- Create handle token in ob_manager
  local sToken = syscall("ob_create_handle", nCallerPid, {
    nInternalFd = nFd,
    sSynapseToken = sSynapseToken,
    sPath = "/dev/tty",
  })
  
  if sToken then
    syscall("ob_set_alias", nCallerPid, nAlias, sToken)
    return true, sToken
  end
  return false
end

--]]


-- ==========================================
-- LOG ROTATION SYSTEM
-- ==========================================

local function _loadSysConfig()
  if not vfs_state.oRootFs then return {} end
  local bOk, h = syscall("raw_component_invoke", vfs_state.oRootFs.address, "open", "/etc/sys.cfg", "r")
  if not bOk or not h then return {} end
  local _, d = syscall("raw_component_invoke", vfs_state.oRootFs.address, "read", h, math.huge)
  syscall("raw_component_invoke", vfs_state.oRootFs.address, "close", h)
  if not d or type(d) ~= "string" then return {} end
  local f = load(d, "sys.cfg", "t", {})
  if not f then return {} end
  local bPcallOk, tResult = pcall(f)
  return (bPcallOk and type(tResult) == "table") and tResult or {}
end

local function _rotateLogDir(sDir, nMax)
  local bOk, tList = syscall("raw_component_invoke", vfs_state.oRootFs.address, "list", sDir)
  if not bOk or not tList then return 1 end
  local tFiles = {}
  local nMaxNum = 0
  for _, sName in ipairs(tList) do
    local sClean = sName
    if sClean:sub(-1) == "/" then sClean = sClean:sub(1, -2) end
    -- match syslog_NNN.log or syslog_NNN.vbl
    local sNum = sClean:match("syslog_(%d+)")
    if sNum then
      local n = tonumber(sNum)
      table.insert(tFiles, { name = sClean, num = n })
      if n > nMaxNum then nMaxNum = n end
    end
  end
  -- sort oldest first
  table.sort(tFiles, function(a, b) return a.num < b.num end)
  -- delete oldest until under limit
  while #tFiles >= nMax do
    local sOldPath = sDir .. "/" .. tFiles[1].name
    syscall("raw_component_invoke", vfs_state.oRootFs.address, "remove", sOldPath)
    syscall("kernel_log", "[PM] Log rotate: deleted " .. sOldPath)
    table.remove(tFiles, 1)
  end
  return nMaxNum + 1
end

local function _setupLogRotation(tConfig)
  local tLog = tConfig and tConfig.logging
  if not tLog or not tLog.enable_log_rotation_saver then
    syscall("kernel_log", "[PM] Log rotation disabled in sys.cfg.")
    return nil
  end

  local sLogDir = tLog.log_dir or "/log"
  local sVblDir = tLog.vbl_dir or "/vbl"
  local nMax    = tLog.max_log_files or 5

  -- create directories (ignore errors if they exist)
  pcall(function() syscall("raw_component_invoke", vfs_state.oRootFs.address, "makeDirectory", sLogDir) end)
  pcall(function() syscall("raw_component_invoke", vfs_state.oRootFs.address, "makeDirectory", sVblDir) end)

  -- rotate old files
  local nLogNum = _rotateLogDir(sLogDir, nMax)
  local nVblNum = _rotateLogDir(sVblDir, nMax)
  local nNum    = math.max(nLogNum, nVblNum)
  local sNumStr = string.format("%03d", nNum)

  local sLogPath = sLogDir .. "/syslog_" .. sNumStr .. ".log"
  local sVblPath = sVblDir .. "/syslog_" .. sNumStr .. ".vbl"

  local bOk1, hLog = syscall("raw_component_invoke", vfs_state.oRootFs.address, "open", sLogPath, "w")
  local bOk2, hVbl = syscall("raw_component_invoke", vfs_state.oRootFs.address, "open", sVblPath, "w")

  syscall("kernel_log", "[PM] Log rotation active:")
  if bOk1 and hLog then syscall("kernel_log", "[PM]   .log -> " .. sLogPath) end
  if bOk2 and hVbl then syscall("kernel_log", "[PM]   .vbl -> " .. sVblPath) end

  return {
    hLogFile = (bOk1 and hLog) or nil,
    hVblFile = (bOk2 and hVbl) or nil,
    sLogPath = sLogPath,
    sVblPath = sVblPath,
  }
end

local function _writeToLogFiles(sText)
  if not g_tLogState or not sText or #sText == 0 then return end

  -- .vbl gets EVERYTHING (verbose)
  if g_tLogState.hVblFile then
    pcall(function()
      syscall("raw_component_invoke", vfs_state.oRootFs.address,
              "write", g_tLogState.hVblFile, sText)
    end)
  end

  -- .log gets only non-debug entries
  if g_tLogState.hLogFile then
    pcall(function()
      local sFiltered = ""
      for sLine in (sText .. "\n"):gmatch("([^\n]*)\n") do
        if #sLine > 0 then
          local bSkip = false
          -- skip [dev], [debug], and [DK] (driver kit verbose) lines
          if sLine:match("^%[dev%]")   then bSkip = true end
          if sLine:match("^%[debug%]") then bSkip = true end
          if sLine:match("%[DK%]")     then bSkip = true end
          if not bSkip then
            sFiltered = sFiltered .. sLine .. "\n"
          end
        end
      end
      if #sFiltered > 0 then
        syscall("raw_component_invoke", vfs_state.oRootFs.address,
                "write", g_tLogState.hLogFile, sFiltered)
      end
    end)
  end
end

local function _drainKernelLog()
  local sNewLog = syscall("kernel_get_boot_log")
  if not sNewLog or #sNewLog == 0 then return end

  -- write to ringfs live buffer
  if g_nRingFsId then
    pcall(function() _doInternalWrite(g_nRingFsId, sNewLog .. "\n") end)
  end

  -- write to permanent files
  _writeToLogFiles(sNewLog)
end


-- ==========================================
-- BOOT LOG FLUSH
-- ==========================================

local function flush_boot_log(sLogDevice)
  syscall("kernel_log", "[PM] Initializing log system on " .. sLogDevice)

  -- 1. Load system config
  g_tSysConfig = _loadSysConfig()

  -- 2. Set up persistent log rotation FIRST (before any writes)
  g_tLogState = _setupLogRotation(g_tSysConfig)

  -- 3. Open ringfs and keep handle for ongoing writes
  local bOk, nId = _doInternalOpen(sLogDevice, "w")
  if bOk then
    g_nRingFsId = nId
    syscall("kernel_log", "[PM] Ringfs handle opened (persistent).")
  else
    syscall("kernel_log", "[PM] Warning: Could not open " .. sLogDevice)
  end

  -- 4. Drain all accumulated boot log to every destination
  _drainKernelLog()

  syscall("kernel_log", "[PM] Log system initialized.")
end

local function wait_for_dkms()
  while true do
    local bOk, nSender, sSig, p1, p2, p3, p4, p5 = syscall("signal_pull")
    if bOk then
        if sSig == "syscall_return" and nSender == nDkmsPid then
           return p1, p2
        elseif sSig == "os_event" then
           syscall("signal_send", nDkmsPid, "os_event", p1, p2, p3, p4, p5)
        else
           -- Buffer any other signals so they aren't lost
           table.insert(g_tPmSignalBuffer, {nSender, sSig, p1, p2, p3, p4, p5})
        end
    end
  end
end

local function load_perms()
  local bOk, h = syscall("raw_component_invoke", vfs_state.oRootFs.address, "open", "/etc/perms.lua", "r")
  if bOk and h then
     local bReadOk, d = syscall("raw_component_invoke", vfs_state.oRootFs.address, "read", h, math.huge)
     syscall("raw_component_invoke", vfs_state.oRootFs.address, "close", h)
     if bReadOk and d then 
        local f = load(d, "perms", "t", {})
        if f then tPermCache = f() end
     end
  end
  if not tPermCache then tPermCache = {} end
end

local function save_perms()
  if not tPermCache then return end
  local sData = "return {\n"
  for sPath, tInfo in pairs(tPermCache) do
     sData = sData .. string.format('  ["%s"] = { uid = %d, gid = %d, mode = %d },\n', 
       sPath, tInfo.uid or 0, tInfo.gid or 0, tInfo.mode or 755)
  end
  sData = sData .. "}"
  local bOk, h = syscall("raw_component_invoke", vfs_state.oRootFs.address, "open", "/etc/perms.lua", "w")
  if bOk and h then
     syscall("raw_component_invoke", vfs_state.oRootFs.address, "write", h, sData)
     syscall("raw_component_invoke", vfs_state.oRootFs.address, "close", h)
  else
     syscall("kernel_log", "[PM] ERROR: Failed to save permissions to disk!")
  end
end

local function check_access(nPid, sPath, sMode)
  local nUid = 1000
  if nPid < 20 then nUid = 0 end
  if nUid == 0 then return true end
  if not tPermCache then load_perms() end
  local tP = tPermCache[sPath]
  if not tP then tP = { uid=0, gid=0, mode=755 } end
  local nReq = 4
  if sMode == "w" or sMode == "a" then nReq = 2 end
  local nPermDigit = 0
  local sModeStr = tostring(tP.mode)
  if nUid == tP.uid then
     nPermDigit = tonumber(sModeStr:sub(1,1))
  else
     nPermDigit = tonumber(sModeStr:sub(3,3))
  end
  local bAllowed = false
  if nReq == 4 then
     if nPermDigit >= 4 then bAllowed = true end
  elseif nReq == 2 then
     if nPermDigit == 2 or nPermDigit == 3 or nPermDigit == 6 or nPermDigit == 7 then bAllowed = true end
  end
  if not bAllowed then
     syscall("kernel_log", "[PM] ACCESS DENIED: PID " .. nPid .. " tried to " .. sMode .. " " .. sPath)
  end
  return bAllowed
end


-- ==========================================
-- INTERNAL VFS OPS (used by PM itself, no handle tokens)
-- ==========================================
local function _resolveDeviceName(sPath)
    -- Keep hardcoded fast-path for TTY (fire-and-forget writes)
    if sPath == "/dev/tty"  then return "\\Device\\TTY0" end
    if sPath == "/dev/gpu0" then return "\\Device\\Gpu0" end
    -- Everything else: pass the VFS path directly.
    -- DKMS resolves it via its symlink table.
    return sPath
end

local function _sendDeviceCreate(sDevName)
    local tDKStructs = require("shared_structs")
    local pIrp = tDKStructs.fNewIrp(tDKStructs.IRP_MJ_CREATE)
    pIrp.sDeviceName = sDevName
    pIrp.nSenderPid  = nMyPid
    syscall("signal_send", nDkmsPid, "vfs_io_request", pIrp)
    local nStatus, vInfo = wait_for_dkms()
    local nDriverPid = (type(vInfo) == "number") and vInfo or nDkmsPid
    return nStatus, nDriverPid
end

local function _sendDeviceWrite(sDevName, nDriverPid, sData)
    local tDKStructs = require("shared_structs")
    local pIrp = tDKStructs.fNewIrp(tDKStructs.IRP_MJ_WRITE)
    pIrp.sDeviceName     = sDevName
    pIrp.nSenderPid      = nMyPid
    pIrp.tParameters.sData = sData
    -- fast-path for TTY (fire-and-forget)
    if sDevName == "\\Device\\TTY0" then
        pIrp.nFlags = tDKStructs.IRP_FLAG_NO_REPLY
        syscall("signal_send", nDriverPid, "irp_dispatch", pIrp)
        return true, #sData
    end
    syscall("signal_send", nDkmsPid, "vfs_io_request", pIrp)
    local nSt, vInfo = wait_for_dkms()
    return (nSt == 0), vInfo
end

local function _sendDeviceRead(sDevName)
    local tDKStructs = require("shared_structs")
    local pIrp = tDKStructs.fNewIrp(tDKStructs.IRP_MJ_READ)
    pIrp.sDeviceName = sDevName
    pIrp.nSenderPid  = nMyPid
    syscall("signal_send", nDkmsPid, "vfs_io_request", pIrp)
    local nSt, vInfo = wait_for_dkms()
    return (nSt == 0), vInfo
end

local function _sendDeviceClose(sDevName)
    local tDKStructs = require("shared_structs")
    local pIrp = tDKStructs.fNewIrp(tDKStructs.IRP_MJ_CLOSE)
    pIrp.sDeviceName = sDevName
    pIrp.nSenderPid  = nMyPid
    syscall("signal_send", nDkmsPid, "vfs_io_request", pIrp)
    wait_for_dkms()
end

local function _sendDeviceControl(sDevName, sMethod, tArgs)
    local tDKStructs = require("shared_structs")
    local pIrp = tDKStructs.fNewIrp(tDKStructs.IRP_MJ_DEVICE_CONTROL)
    pIrp.sDeviceName = sDevName
    pIrp.nSenderPid  = nMyPid
    pIrp.tParameters.sMethod = sMethod
    pIrp.tParameters.tArgs   = tArgs or {}
    syscall("signal_send", nDkmsPid, "vfs_io_request", pIrp)
    local nSt, vInfo = wait_for_dkms()
    return (nSt == 0), vInfo
end

function _doInternalOpen(sPath, sMode)
    local nId = g_nPmNextInternal; g_nPmNextInternal = g_nPmNextInternal + 1
    if sPath:sub(1, 5) == "/dev/" then
        local sDevName = _resolveDeviceName(sPath)
        local nSt, nDrvPid = _sendDeviceCreate(sDevName)
        if nSt ~= 0 then return nil, "Device open failed" end
        g_tPmInternal[nId] = { type="device", devname=sDevName, driverPid=nDrvPid }
        return true, nId
    end
    local bOk, hRaw, sReason = syscall("raw_component_invoke",
                                        vfs_state.oRootFs.address, "open", sPath, sMode)
    if not hRaw then return nil, sReason end
    g_tPmInternal[nId] = { type="file", rawHandle=hRaw }
    return true, nId
end

function _doInternalWrite(nId, sData)
    local t = g_tPmInternal[nId]; if not t then return nil end
    if t.type == "file" then
        return syscall("raw_component_invoke", vfs_state.oRootFs.address, "write", t.rawHandle, sData)
    else
        return _sendDeviceWrite(t.devname, t.driverPid, sData)
    end
end

function _doInternalRead(nId, nCount)
    local t = g_tPmInternal[nId]; if not t then return nil end
    if t.type == "file" then
        local r1, r2 = syscall("raw_component_invoke",
                                vfs_state.oRootFs.address, "read", t.rawHandle, nCount)
        if type(r2) == "boolean" then r2 = nil end
        return r1, r2
    else
        return _sendDeviceRead(t.devname)
    end
end

function _doInternalClose(nId)
    local t = g_tPmInternal[nId]; if not t then return end
    if t.type == "file" then
        syscall("raw_component_invoke", vfs_state.oRootFs.address, "close", t.rawHandle)
    else
        _sendDeviceClose(t.devname)
    end
    g_tPmInternal[nId] = nil
end


-- ==========================================
-- PUBLIC VFS HANDLERS (called via syscall override)
-- These now accept synapse tokens from the kernel dispatcher.
-- ==========================================
-- ==========================================
-- PUBLIC VFS HANDLERS  (syscall override targets)
-- These create/resolve ObManager objects — no FDs leave PM.
-- ==========================================

function vfs_state.handle_open(nSenderPid, sSynapseToken, sPath, sMode)
    -- permission check (unchanged)
    if sPath:sub(1, 5) ~= "/dev/" then
        if not check_access(nSenderPid, sPath, sMode or "r") then
            return nil, "Permission denied"
        end
    end

    local tBody = { sPath = sPath, sMode = sMode }

    if sPath:sub(1, 5) == "/dev/" then
        local sDevName = _resolveDeviceName(sPath)
        local nSt, nDrvPid = _sendDeviceCreate(sDevName)
        if nSt ~= 0 then return nil, "Device open failed" end
        tBody.sCategory  = "device"
        tBody.sDeviceName = sDevName
        tBody.nDriverPid  = nDrvPid
    else
        local bOk, hRaw = syscall("raw_component_invoke",
                                    vfs_state.oRootFs.address, "open", sPath, sMode)
        if not hRaw then return nil, "File not found" end
        tBody.sCategory = "file"
        tBody.hRawHandle = hRaw
    end

    -- create the IoFileObject in the kernel Object Manager
    local pObj = syscall("ob_create_object", "IoFileObject", tBody)
    if not pObj then return nil, "ObCreateObject failed" end

    -- choose access mask from mode
    local nAccess = OB_ACCESS_READ
    if sMode == "w" or sMode == "a" then nAccess = OB_ACCESS_WRITE end
    if sMode == "rw" then nAccess = OB_ACCESS_READ + OB_ACCESS_WRITE end
    nAccess = nAccess + OB_ACCESS_DEVCTL  -- always allow ioctl

    -- mint a handle token for the calling process
    local sToken = syscall("ob_create_handle",
                           nSenderPid, pObj, nAccess, sSynapseToken)
    if not sToken then
        syscall("ob_dereference_object", pObj)
        return nil, "ObCreateHandle failed"
    end

    -- auto-assign standard handles for /dev/tty
    if sPath == "/dev/tty" then
        if sMode == "r" then
            if not syscall("ob_get_standard_handle", nSenderPid, -10) then
                syscall("ob_set_standard_handle", nSenderPid, -10, sToken)
            end
        end
        if sMode == "w" or sMode == "rw" then
            if not syscall("ob_get_standard_handle", nSenderPid, -11) then
                syscall("ob_set_standard_handle", nSenderPid, -11, sToken)
            end
            if not syscall("ob_get_standard_handle", nSenderPid, -12) then
                syscall("ob_set_standard_handle", nSenderPid, -12, sToken)
            end
        end
    end

    return true, sToken
end


function vfs_state.handle_write(nSenderPid, sSynapseToken, vHandle, sData)
    local pObj, sErr = fResolveObject(nSenderPid, sSynapseToken, vHandle, OB_ACCESS_WRITE)
    if not pObj then return nil, sErr end
    local b = pObj.pBody
    if b.sCategory == "device" then
        return _sendDeviceWrite(b.sDeviceName, b.nDriverPid, sData)
    else
        return syscall("raw_component_invoke",
                        vfs_state.oRootFs.address, "write", b.hRawHandle, sData)
    end
end


function vfs_state.handle_read(nSenderPid, sSynapseToken, vHandle, nCount)
    local pObj, sErr = fResolveObject(nSenderPid, sSynapseToken, vHandle, OB_ACCESS_READ)
    if not pObj then return nil, sErr end
    local b = pObj.pBody
    if b.sCategory == "device" then
        return _sendDeviceRead(b.sDeviceName)
    else
        local r1, r2 = syscall("raw_component_invoke",
                                vfs_state.oRootFs.address, "read", b.hRawHandle, nCount)
        if type(r2) == "boolean" then r2 = nil end
        return r1, r2
    end
end


function vfs_state.handle_close(nSenderPid, sSynapseToken, vHandle)
    local pObj, sErr = fResolveObject(nSenderPid, sSynapseToken, vHandle, 0)
    if not pObj then return nil end
    local b = pObj.pBody
    -- I/O cleanup BEFORE releasing the handle
    if b.sCategory == "device" then
        _sendDeviceClose(b.sDeviceName)
    elseif b.hRawHandle then
        syscall("raw_component_invoke",
                vfs_state.oRootFs.address, "close", b.hRawHandle)
    end
    syscall("ob_close_handle", nSenderPid, vHandle)
    return true
end


function vfs_state.handle_chmod(nSenderPid, sPath, nMode)
  local nUid = syscall("process_get_uid", nSenderPid) or 1000
  if not tPermCache then load_perms() end
  local tEntry = tPermCache[sPath]
  if not tEntry then
     tEntry = { uid = nUid, gid = 0, mode = 755 }
     tPermCache[sPath] = tEntry
  end
  if nUid ~= 0 and tEntry.uid ~= nUid then
     syscall("kernel_log", "[PM] CHMOD DENIED: PID " .. nSenderPid .. " (UID " .. nUid .. ") tried to touch " .. sPath)
     return nil, "Operation not permitted (Not owner)"
  end
  if nUid ~= 0 and (sPath:sub(1,5) == "/boot" or sPath:sub(1,4) == "/sys") then
     return nil, "Operation not permitted (System protected)"
  end
  tEntry.mode = nMode
  save_perms()
  syscall("kernel_log", "[PM] CHMOD: " .. sPath .. " -> " .. nMode .. " by UID " .. nUid)
  return true
end

function vfs_state.handle_device_control(nSenderPid, sSynapseToken, vHandle, sMethod, tArgs)
    local pObj, sErr = fResolveObject(nSenderPid, sSynapseToken, vHandle, OB_ACCESS_DEVCTL)
    if not pObj then return nil, sErr end
    local b = pObj.pBody
    if b.sCategory ~= "device" then return nil, "Not a device handle" end
    return _sendDeviceControl(b.sDeviceName, sMethod, tArgs)
end

function vfs_state.handle_list(nSenderPid, sPath)
  local sCleanPath = sPath
  if #sCleanPath > 1 and string.sub(sCleanPath, -1) == "/" then
     sCleanPath = string.sub(sCleanPath, 1, -2)
  end
  if sCleanPath == "/dev" then
     syscall("signal_send", nDkmsPid, "dkms_list_devices_request", nSenderPid)
     while true do
        local bOk, nSender, sSig, p1, p2 = syscall("signal_pull")
        if bOk and nSender == nDkmsPid then
           if sSig == "dkms_list_devices_result" and p1 == nSenderPid then
              return true, p2
           elseif sSig == "os_event" then
              syscall("signal_send", nDkmsPid, "os_event", p1, p2)
           end
        end
     end
  end
  local bOk, tListOrErr = syscall("raw_component_invoke", vfs_state.oRootFs.address, "list", sPath)
  if bOk then return true, tListOrErr else return nil, tListOrErr end
end

function vfs_state.handle_delete(nSenderPid, sPath)
  -- block dangerous paths
  if not sPath or sPath == "/" then return nil, "Cannot delete root" end
  if sPath:sub(1, 5) == "/dev/"  then return nil, "Cannot delete device nodes" end
  if sPath:sub(1, 5) == "/boot"  then return nil, "Cannot delete boot files" end

  -- /tmp/ is world-writable; everything else needs permission check
  if sPath:sub(1, 5) ~= "/tmp/" then
    if not check_access(nSenderPid, sPath, "w") then
      return nil, "Permission denied"
    end
  end

  local bOk, sResult = syscall("raw_component_invoke",
                                vfs_state.oRootFs.address, "remove", sPath)
  if bOk then return true else return nil, tostring(sResult) end
end

function vfs_state.handle_mkdir(nSenderPid, sPath)
  if sPath:sub(1, 5) == "/dev/" then return nil, "Cannot mkdir in /dev" end
  -- /tmp/ is world-writable
  if sPath:sub(1, 5) ~= "/tmp/" then
    if not check_access(nSenderPid, sPath, "w") then
      return nil, "Permission denied"
    end
  end
  local bOk, sResult = syscall("raw_component_invoke",
                                vfs_state.oRootFs.address, "makeDirectory", sPath)
  if bOk then return true else return nil, tostring(sResult) end
end


function vfs_state.handle_driver_load(nSenderPid, sPath)
  -- Security: check ring and UID
  local nCallerRing = syscall("process_get_ring")
  -- nCallerRing here is PM's ring (1), not the original caller's.
  -- We check the original caller's UID instead.
  local nUid = syscall("process_get_uid", nSenderPid) or 1000
  if nUid ~= 0 then
     syscall("kernel_log", "[PM] DRIVER_LOAD DENIED: PID " .. nSenderPid .. " (UID " .. nUid .. ") is not root")
     return nil, "Permission denied: only root (UID 0) can load drivers"
  end

  syscall("kernel_log", "[PM] User (PID " .. nSenderPid .. ") requested load of: " .. sPath)
  syscall("signal_send", nDkmsPid, "load_driver_path_request", sPath, nSenderPid)
  while true do
    local bOk, nSender, sSig, p1, p2, p3, p4 = syscall("signal_pull") 
    if bOk and nSender == nDkmsPid then
       if sSig == "load_driver_result" and p1 == nSenderPid then
          local nStatus, sDrvName, nDrvPid = p2, p3, p4
          if not sDrvName then sDrvName = "Unknown" end
          if nStatus == 0 then 
             local sMsg = (nDrvPid == 0) and string.format("[PM] Success: %s", sDrvName) or string.format("[PM] Success: Loaded '%s' (PID %d)", sDrvName, nDrvPid)
             syscall("kernel_log", sMsg)
             return true, sMsg 
          else
             local sMsg = "[PM] Driver load failed. Status: " .. tostring(nStatus)
             syscall("kernel_log", sMsg)
             return nil, sMsg 
          end
       elseif sSig == "os_event" then
          syscall("signal_send", nDkmsPid, "os_event", p1, p2, p3, p4)
       else
          table.insert(g_tPmSignalBuffer, {nSender, sSig, p1, p2, p3, p4})
       end
    elseif bOk then
       -- Signal from non-DKMS sender — buffer it
       table.insert(g_tPmSignalBuffer, {nSender, sSig, p1, p2, p3, p4})
    end
  end
end


-- ==========================================
-- BOOT HELPERS
-- ==========================================

local function get_gpu_proxy()
  local bOk, tList = syscall("raw_component_list", "gpu")
  if not bOk or not tList then return nil end
  for sAddr in pairs(tList) do return syscall("raw_component_proxy", sAddr) end
end

local function get_screen_addr()
  local bOk, tList = syscall("raw_component_list", "screen")
  if not bOk or not tList then return nil end
  for sAddr in pairs(tList) do return sAddr end
end

local function wait_with_throbber(sMessage, nSeconds)
  local oGpu = get_gpu_proxy()
  local sScreen = get_screen_addr()
  local nWidth, nHeight = 80, 25
  if oGpu and sScreen then 
     oGpu.bind(sScreen) 
     nWidth, nHeight = oGpu.getResolution()
  end
  local nStartTime = computer.uptime()
  local nDeadline = nStartTime + nSeconds
  local nFrame = 0
  local nThrobberWidth = 12
  syscall("kernel_log", "[PM] " .. sMessage)
  while computer.uptime() < nDeadline do
    if oGpu then
       local nPos = math.floor(nFrame / 1.5) % (nThrobberWidth * 2 - 2)
       if nPos >= nThrobberWidth then nPos = (nThrobberWidth * 2 - 2) - nPos end
       local sLine = "("
       for i = 0, nThrobberWidth - 1 do
          if i >= nPos and i < nPos + 3 then sLine = sLine .. "*"
          else sLine = sLine .. " " end
       end
       sLine = sLine .. ")"
       local sFullMsg = string.format("%s %s", sLine, "Driver loading...")
       oGpu.set(1, nHeight, sFullMsg .. string.rep(" ", nWidth - #sFullMsg))
       nFrame = nFrame + 1
    end
    syscall("process_yield")
  end
  if oGpu then oGpu.fill(1, nHeight, nWidth, 1, " ") end
end

local function __scandrvload()
  syscall("kernel_log", "[PM] Loading TTY Driver explicitly...")
  syscall("signal_send", nDkmsPid, "load_driver_path", "/drivers/tty.sys.lua")
  
  local deadline = computer.uptime() + 0.0
  while computer.uptime() < deadline do syscall("process_yield") end

  syscall("kernel_log", "[PM] Scanning components...")

  local sRootUuid, oRootProxy = syscall("kernel_get_root_fs")
  if not oRootProxy then syscall("kernel_panic", "Pipeline could not get root FS info.") end
  vfs_state.oRootFs = oRootProxy
  
  local bListOk, tCompList = syscall("raw_component_list")
  if not bListOk then return end
  
  for sAddr, sCtype in pairs(tCompList) do
    if sCtype ~= "screen" and sCtype ~= "gpu" and sCtype ~= "keyboard" then
        syscall("kernel_log", "[PM] Loading driver for " .. sCtype)
        syscall("signal_send", nDkmsPid, "load_driver_for_component", sCtype, sAddr)
    end
  end

  -- === REGISTRY: enumerate hardware ===
  if bListOk and tCompList then
    for sAddr, sCtype in pairs(tCompList) do
      local sHwPath = "@VT\\SYS\\HARDWARE\\" .. sCtype .. "_" .. sAddr:sub(1, 6)
      syscall("reg_create_key", sHwPath)
      syscall("reg_set_value", sHwPath, "Address",       sAddr,  "STR")
      syscall("reg_set_value", sHwPath, "ComponentType",  sCtype, "STR")
      syscall("reg_set_value", sHwPath, "ShortAddress",   sAddr:sub(1, 8), "STR")
    end
  end

end


local function process_fstab()
  syscall("kernel_log", "[PM] Processing fstab...")
  local bOpenOk, hFstab = syscall("raw_component_invoke", vfs_state.oRootFs.address, "open", "/etc/fstab.lua", "r")
  if bOpenOk and hFstab then
     local bReadOk, sData = syscall("raw_component_invoke", vfs_state.oRootFs.address, "read", hFstab, math.huge)
     syscall("raw_component_invoke", vfs_state.oRootFs.address, "close", hFstab)
     if bReadOk and type(sData) == "string" then
        local f, sErr = load(sData, "fstab", "t", {})
        if f then 
           local tFstab = f()
           if type(tFstab) == "table" then
               for _, tEntry in ipairs(tFstab) do
                  if tEntry.type == "ringfs" then
                     if not bRingFsLoaded then
                         -- Check if ringfs device already exists
                         local bProbe, nProbeId = _doInternalOpen("/dev/ringlog", "w")
                         if bProbe then
                            _doInternalClose(nProbeId)
                            syscall("kernel_log", "[PM] RingFS already present, skipping load.")
                         else
                            syscall("kernel_log", "[PM] Loading RingFS driver...")
                            syscall("signal_send", nDkmsPid, "load_driver_path", "/drivers/ringfs.sys.lua")
                            syscall("process_wait", 0)
                         end
                         bRingFsLoaded = true
                     end
                     local tOpts = parse_options(tEntry.options)
                     if tOpts.size then
                        local tDKStructs = require("shared_structs")
                        local pIrp = tDKStructs.fNewIrp(tDKStructs.IRP_MJ_DEVICE_CONTROL)
                        pIrp.sDeviceName = "\\Device\\ringlog"
                        pIrp.nSenderPid = nMyPid
                        pIrp.tParameters.sMethod = "resize"
                        pIrp.tParameters.tArgs = { tOpts.size }
                        syscall("signal_send", nDkmsPid, "vfs_io_request", pIrp)
                        wait_for_dkms()
                     end
                     if string.sub(tEntry.path, 1, 5) == "/dev/" then
                        flush_boot_log(tEntry.path)
                     end
                  end
               end
           end
        else
            syscall("kernel_log", "[PM] Syntax error in fstab: " .. tostring(sErr))
        end
     end
  else
     syscall("kernel_log", "[PM] Warning: /etc/fstab.lua not found or unreadable.")
  end
end

local function process_autoload()
  syscall("kernel_log", "[PM] Processing autoload...")
  local bOk, hFile = syscall("raw_component_invoke", vfs_state.oRootFs.address, "open", "/etc/autoload.lua", "r")
  if bOk and hFile then
     local _, sData = syscall("raw_component_invoke", vfs_state.oRootFs.address, "read", hFile, math.huge)
     syscall("raw_component_invoke", vfs_state.oRootFs.address, "close", hFile)
     if sData then
        local f = load(sData, "autoload", "t", {})
        if f then
           local tList = f()
           if tList then
              for _, sDrvPath in ipairs(tList) do
                 syscall("kernel_log", "[PM] Autoloading: " .. sDrvPath)
                 syscall("signal_send", nDkmsPid, "load_driver_path", sDrvPath)
                 syscall("process_wait", 0)
              end
           end
        end
     end
  end
end


-- ==========================================
-- BOOT SEQUENCE
-- ==========================================

__scandrvload()
process_fstab()
if env.SAFE_MODE then
   syscall("kernel_log", "[PM] SAFE MODE ENABLED: Skipping autoload.lua")
else
   process_autoload()
end

wait_with_throbber("Waiting for system stabilization...", 1.0)
-- === REGISTRY: populate system info ===
syscall("kernel_log", "[PM] Populating @VT\\SYS...")
pcall(function()
    if g_tSysConfig then
        syscall("reg_set_value", "@VT\\SYS\\CONFIG", "Hostname",
                g_tSysConfig.hostname or "AxisBox", "STR")
        if g_tSysConfig.logging then
            for k, v in pairs(g_tSysConfig.logging) do
                syscall("reg_set_value", "@VT\\SYS\\CONFIG",
                        "logging." .. k, tostring(v), "STR")
            end
        end
    end
    syscall("reg_set_value", "@VT\\SYS\\BOOT", "SafeMode",
            env.SAFE_MODE and "true" or "false", "STR")
    syscall("reg_set_value", "@VT\\SYS\\BOOT", "InitPath",
            env.INIT_PATH or "/bin/init.lua", "STR")
end)

syscall("kernel_log", "[PM] Silence on deck. Handing off to userspace.")
syscall("kernel_set_log_mode", false)


local sInitPath = env.INIT_PATH or "/bin/init.lua"
syscall("kernel_log", "[PM] Spawning " .. sInitPath .. "...")
local nInitPid, sInitErr = syscall("process_spawn", sInitPath, 3)

if not nInitPid then syscall("kernel_log", "[PM] FAILED TO SPAWN INIT: " .. tostring(sInitErr))
else syscall("kernel_log", "[PM] Init spawned as PID " .. tostring(nInitPid)) end


-- ==========================================
-- MAIN DISPATCH LOOP
-- ==========================================

while true do
    _drainKernelLog()
   -- Drain buffered signals first
   while #g_tPmSignalBuffer > 0 do
      local tSig = table.remove(g_tPmSignalBuffer, 1)
      local nBufSender, sBufSig = tSig[1], tSig[2]
      local bp1, bp2, bp3, bp4, bp5 = tSig[3], tSig[4], tSig[5], tSig[6], tSig[7]
      
      if sBufSig == "syscall" then
        local tData = bp1
        local sName = tData.name
        local tArgs = tData.args
        local nCaller = tData.sender_pid
        local sSynToken = tData.synapse_token
        local result1, result2
        
        if sName == "vfs_open" then result1, result2 = vfs_state.handle_open(nCaller, sSynToken, tArgs[1], tArgs[2])
        elseif sName == "vfs_write" then result1, result2 = vfs_state.handle_write(nCaller, sSynToken, tArgs[1], tArgs[2])
        elseif sName == "vfs_read" then result1, result2 = vfs_state.handle_read(nCaller, sSynToken, tArgs[1], tArgs[2])
        elseif sName == "vfs_close" then result1, result2 = vfs_state.handle_close(nCaller, sSynToken, tArgs[1])
        elseif sName == "vfs_list" then result1, result2 = vfs_state.handle_list(nCaller, tArgs[1])
        elseif sName == "vfs_delete" then result1, result2 = vfs_state.handle_delete(nCaller, tArgs[1])
        elseif sName == "vfs_mkdir"  then result1, result2 = vfs_state.handle_mkdir(nCaller, tArgs[1])
        elseif sName == "vfs_chmod" then result1, result2 = vfs_state.handle_chmod(nCaller, tArgs[1], tArgs[2])
        elseif sName == "vfs_device_control" then result1, result2 = vfs_state.handle_device_control(nCaller, sSynToken, tArgs[1], tArgs[2], tArgs[3])
        elseif sName == "driver_load" then result1, result2 = vfs_state.handle_driver_load(nCaller, tArgs[1])
        end
        
        if result1 ~= "async_wait" then
          syscall("signal_send", nCaller, "syscall_return", result1, result2)
        end
      elseif sBufSig == "os_event" then
        syscall("signal_send", nDkmsPid, "os_event", bp1, bp2, bp3, bp4, bp5)
      end
    end
  local bOk, nSender, sSignal, p1, p2, p3, p4, p5 = syscall("signal_pull")
  if bOk then
    if sSignal == "syscall" then
      local tData = p1
      local sName = tData.name
      local tArgs = tData.args
      local nCaller = tData.sender_pid
      local sSynapseToken = tData.synapse_token -- sMLTR: token from kernel
      local result1, result2
      
      if sName == "vfs_open" then 
        result1, result2 = vfs_state.handle_open(nCaller, sSynapseToken, tArgs[1], tArgs[2])
      elseif sName == "vfs_write" then 
        result1, result2 = vfs_state.handle_write(nCaller, sSynapseToken, tArgs[1], tArgs[2])
      elseif sName == "vfs_read" then 
        result1, result2 = vfs_state.handle_read(nCaller, sSynapseToken, tArgs[1], tArgs[2])
      elseif sName == "vfs_close" then 
        result1, result2 = vfs_state.handle_close(nCaller, sSynapseToken, tArgs[1])
      elseif sName == "vfs_list" then 
        result1, result2 = vfs_state.handle_list(nCaller, tArgs[1])
      elseif sName == "vfs_chmod" then 
        result1, result2 = vfs_state.handle_chmod(nCaller, tArgs[1], tArgs[2])
      elseif sName == "vfs_device_control" then
        result1, result2 = vfs_state.handle_device_control(nCaller, sSynapseToken, tArgs[1], tArgs[2], tArgs[3])
      elseif sName == "driver_load" then 
        result1, result2 = vfs_state.handle_driver_load(nCaller, tArgs[1])
      end
      
      if result1 ~= "async_wait" then
         syscall("signal_send", nCaller, "syscall_return", result1, result2)
      end
    elseif sSignal == "os_event" then
       syscall("signal_send", nDkmsPid, "os_event", p1, p2, p3, p4, p5)
    end
  end
end
```


axis-os\src\kernel\lib\pki_client.lua
```
-- /lib/pki_client.lua
-- Cloud PKI Client for AxisOS
-- Communicates with pki.axis-os.ru API

local http = require("http")
local crypto = require("crypto")

local oPki = {}

local PKI_BASE = "https://pki.axis-os.ru/api"
local g_sApiToken = nil
local g_tKeyCache = {}     -- fingerprint → {pubkey, status, cached_at}
local g_tHashCache = {}    -- sha256 → {status, signer, cached_at}
local CACHE_TTL = 3600     -- 1 hour cache

function oPki.SetToken(sToken)
    g_sApiToken = sToken
end

-- Load token from /etc/pki.cfg
function oPki.LoadConfig()
    local fs = require("filesystem")
    local h = fs.open("/etc/pki.cfg", "r")
    if not h then return false end
    local d = fs.read(h, math.huge)
    fs.close(h)
    if not d then return false end
    local f = load(d, "pki.cfg", "t", {})
    if f then
        local cfg = f()
        if cfg then
            g_sApiToken = cfg.api_token
            PKI_BASE = cfg.pki_url or PKI_BASE
            return true
        end
    end
    return false
end

-- Register a new ECDSA public key with the cloud PKI
function oPki.RegisterKey(sPublicKeyB64, sKeyType)
    if not g_sApiToken then return nil, "No API token configured" end
    
    local resp = http.request("POST", PKI_BASE .. "/register.php",
        '{"public_key":"' .. sPublicKeyB64 .. '","type":"' .. (sKeyType or "ECDSA-384") .. '"}',
        {["X-API-Token"] = g_sApiToken, ["Content-Type"] = "application/json"})
    
    if resp.code == 200 then
        return true, resp.body
    end
    return nil, resp.body or ("HTTP " .. resp.code)
end

-- Check key status (approved/pending/revoked)
function oPki.CheckKeyStatus(sPublicKeyB64)
    local resp = http.request("POST", PKI_BASE .. "/status.php",
        '{"public_key":"' .. sPublicKeyB64 .. '"}',
        {["Content-Type"] = "application/json"})
    
    if resp.code == 200 and resp.body then
        local ok, data = pcall(function()
            -- minimal JSON parse
            local status = resp.body:match('"status"%s*:%s*"([^"]+)"')
            return status
        end)
        if ok then return data end
    end
    return "unknown"
end

-- Get all approved signing keys from cloud
function oPki.FetchApprovedKeys()
    if not g_sApiToken then return nil, "No token" end
    
    local resp = http.request("POST", PKI_BASE .. "/approved_keys.php",
        '{}',
        {["X-API-Token"] = g_sApiToken, ["Content-Type"] = "application/json"})
    
    if resp.code == 200 and resp.body then
        -- Parse the JSON response (simplified)
        local tKeys = {}
        -- Each key entry: {"fingerprint":"...","public_key":"...","username":"...","status":"approved"}
        for fp, pk, user in resp.body:gmatch(
            '"fingerprint"%s*:%s*"([^"]+)"%s*,%s*"public_key"%s*:%s*"([^"]+)"%s*,%s*"username"%s*:%s*"([^"]+)"') do
            tKeys[fp] = {public_key = pk, username = user, status = "approved"}
        end
        return tKeys
    end
    return nil, "Fetch failed"
end

-- Verify a file hash against cloud manifest
function oPki.CloudVerifyHash(sHash, sFileName)
    -- Check local cache first
    local tCached = g_tHashCache[sHash]
    if tCached and (os.clock() - tCached.cached_at) < CACHE_TTL then
        return tCached.status, tCached.signer
    end
    
    if not g_sApiToken then return "offline", nil end
    
    local resp = http.request("POST", PKI_BASE .. "/verify_hash.php",
        '{"hash":"' .. sHash .. '","filename":"' .. (sFileName or "") .. '"}',
        {["X-API-Token"] = g_sApiToken, ["Content-Type"] = "application/json"})
    
    if resp.code == 200 and resp.body then
        local status = resp.body:match('"status"%s*:%s*"([^"]+)"')
        local signer = resp.body:match('"signer"%s*:%s*"([^"]*)"')
        
        if status then
            g_tHashCache[sHash] = {status = status, signer = signer, cached_at = os.clock()}
            return status, signer
        end
    end
    
    return "unverified", nil
end

-- Revoke a key
function oPki.RevokeKey(sPublicKeyB64)
    if not g_sApiToken then return nil, "No token" end
    local resp = http.request("POST", PKI_BASE .. "/revoke.php",
        '{"public_key":"' .. sPublicKeyB64 .. '"}',
        {["X-API-Token"] = g_sApiToken, ["Content-Type"] = "application/json"})
    return resp.code == 200, resp.body
end

-- Sync approved keys to local cache file
function oPki.SyncKeyStore()
    local tKeys, sErr = oPki.FetchApprovedKeys()
    if not tKeys then return false, sErr end
    
    local fs = require("filesystem")
    local sData = "-- Auto-synced PKI key store\nreturn {\n"
    for fp, tInfo in pairs(tKeys) do
        sData = sData .. string.format(
            '  ["%s"] = {public_key="%s", username="%s", status="%s"},\n',
            fp, tInfo.public_key, tInfo.username, tInfo.status)
    end
    sData = sData .. "}\n"
    
    local h = fs.open("/etc/pki_keystore.lua", "w")
    if h then
        fs.write(h, sData)
        fs.close(h)
        return true
    end
    return false, "Cannot write keystore"
end

-- Load local key store (offline fallback)
function oPki.LoadLocalKeyStore()
    local fs = require("filesystem")
    local h = fs.open("/etc/pki_keystore.lua", "r")
    if not h then return {} end
    local d = fs.read(h, math.huge)
    fs.close(h)
    if not d then return {} end
    local f = load(d, "keystore", "t", {})
    if f then return f() or {} end
    return {}
end

return oPki
```


axis-os\src\kernel\lib\preempt.lua
```
--
-- /lib/preempt.lua
--
-- Injects yield-checkpoint calls (__pc()) into Lua source at loop and
-- branch boundaries.
--
-- Injection points (after keyword + whitespace):
--   do   →  every for/while/do-block iteration
--   then →  every if/elseif branch entry
--   repeat → every repeat-until iteration
--   else →  every else branch entry  (but NOT "elseif")
--
-- The scanner correctly skips:
--   • single-quoted and double-quoted string literals
--   • long strings  [[ ]], [=[ ]=], etc.
--   • short comments  --
--   • long comments   --[[ ]], --[=[ ]=], etc.
--
-- Identifiers containing keywords (do_something, redo, etc.) are
-- protected by word-boundary checks on both sides.
--

local oPreempt = {}

-- =============================================
-- CONFIGURATION
-- =============================================

-- Time quantum per process slice (seconds).
-- A process that has been running for longer than this since its last
-- yield will be preempted at the next __pc() call.
oPreempt.DEFAULT_QUANTUM = 0.05   -- 50 ms

-- __pc() call-count threshold.  We only read the wall clock every N
-- calls to avoid the overhead of computer.uptime() on every loop
-- iteration.  Higher = less overhead, slightly less responsive.
oPreempt.CHECK_INTERVAL = 256

-- =============================================
-- STATISTICS  (read by the kernel for diagnostics)
-- =============================================

oPreempt.nTotalInstrumented = 0
oPreempt.nTotalInjections   = 0

-- =============================================
-- SOURCE CODE INSTRUMENTER
-- =============================================

function oPreempt.instrument(sCode, sLabel)
    if not sCode or #sCode == 0 then return sCode, 0 end

    local tOut        = {}
    local nOutIdx     = 0
    local nLen        = #sCode
    local nPos        = 1
    local nInjections = 0

    --  helper ---------------------------------------------------------
    local function isIdChar(c)
        if not c or c == "" then return false end
        local b = c:byte()
        return (b >= 65 and b <= 90)        -- A-Z
            or (b >= 97 and b <= 122)       -- a-z
            or (b >= 48 and b <= 57)        -- 0-9
            or b == 95                       -- _
    end

    local function emit(s)
        nOutIdx = nOutIdx + 1
        tOut[nOutIdx] = s
    end
    --  ----------------------------------------------------------------

    while nPos <= nLen do
        local c = sCode:sub(nPos, nPos)

        -- ==== String literals ("…" or '…') ====
        if c == '"' or c == "'" then
            local q      = c
            local nStart = nPos
            nPos = nPos + 1
            while nPos <= nLen do
                local c2 = sCode:sub(nPos, nPos)
                if c2 == '\\' then
                    nPos = nPos + 2          -- skip escaped char
                elseif c2 == q then
                    nPos = nPos + 1
                    break
                else
                    nPos = nPos + 1
                end
            end
            emit(sCode:sub(nStart, nPos - 1))

        -- ==== Comments  (-- …) ====
        elseif c == '-' and nPos + 1 <= nLen
                        and sCode:sub(nPos + 1, nPos + 1) == '-' then
            local nComStart = nPos
            nPos = nPos + 2                   -- skip  --

            -- long comment?  --[[ or --[==[  etc.
            local bLong = false
            if nPos <= nLen and sCode:sub(nPos, nPos) == '[' then
                local nEq    = 0
                local nProbe = nPos + 1
                while nProbe <= nLen and sCode:sub(nProbe, nProbe) == '=' do
                    nEq = nEq + 1;  nProbe = nProbe + 1
                end
                if nProbe <= nLen and sCode:sub(nProbe, nProbe) == '[' then
                    bLong = true
                    local sClose = ']' .. string.rep('=', nEq) .. ']'
                    local nEnd   = sCode:find(sClose, nProbe + 1, true)
                    if nEnd then
                        nPos = nEnd + #sClose
                    else
                        nPos = nLen + 1
                    end
                end
            end

            if not bLong then
                -- short comment: consume to end of line
                local nEol = sCode:find('\n', nPos)
                nPos = nEol and (nEol + 1) or (nLen + 1)
            end

            emit(sCode:sub(nComStart, nPos - 1))

        -- ==== Long strings  [[ ]], [=[ ]=]  etc. ====
        elseif c == '[' then
            local nEq    = 0
            local nProbe = nPos + 1
            while nProbe <= nLen and sCode:sub(nProbe, nProbe) == '=' do
                nEq = nEq + 1;  nProbe = nProbe + 1
            end
            if nProbe <= nLen and sCode:sub(nProbe, nProbe) == '[' then
                local sClose = ']' .. string.rep('=', nEq) .. ']'
                local nEnd   = sCode:find(sClose, nProbe + 1, true)
                if nEnd then
                    emit(sCode:sub(nPos, nEnd + #sClose - 1))
                    nPos = nEnd + #sClose
                else
                    emit(sCode:sub(nPos))
                    nPos = nLen + 1
                end
            else
                emit(c);  nPos = nPos + 1
            end

        -- ==== Keywords  (do / then / repeat / else) ====
        else
            local bInjected = false
            local cPrev = (nPos > 1) and sCode:sub(nPos - 1, nPos - 1) or ""

            if not isIdChar(cPrev) then
                for _, sKw in ipairs({"repeat", "then", "else", "do"}) do
                    local nKwLen = #sKw
                    if nPos + nKwLen - 1 <= nLen
                       and sCode:sub(nPos, nPos + nKwLen - 1) == sKw then

                        -- word boundary AFTER the keyword
                        local cAfter = (nPos + nKwLen <= nLen)
                                       and sCode:sub(nPos + nKwLen, nPos + nKwLen) or ""
                        if not isIdChar(cAfter) then

                            -- guard: "else" immediately before "if" → elseif
                            if sKw == "else" then
                                local sLook = sCode:sub(nPos + nKwLen)
                                if sLook:match("^%s*if[^%w_]")
                                or sLook:match("^%s*if$") then
                                    goto skip_keyword
                                end
                            end

                            -- emit keyword
                            emit(sKw)
                            nPos = nPos + nKwLen

                            -- preserve whitespace after keyword
                            while nPos <= nLen do
                                local cW = sCode:sub(nPos, nPos)
                                if cW == ' ' or cW == '\t'
                                or cW == '\n' or cW == '\r' then
                                    emit(cW);  nPos = nPos + 1
                                else
                                    break
                                end
                            end

                            -- >>> INJECT <<<
                            emit("__pc();")
                            nInjections = nInjections + 1
                            bInjected = true
                            break
                        end
                    end
                    ::skip_keyword::
                end  -- for keywords
            end

            if not bInjected then
                emit(c);  nPos = nPos + 1
            end
        end
    end  -- while

    oPreempt.nTotalInstrumented = oPreempt.nTotalInstrumented + 1
    oPreempt.nTotalInjections   = oPreempt.nTotalInjections + nInjections

    return table.concat(tOut), nInjections
end

-- =============================================
-- HELPERS
-- =============================================

function oPreempt.getStats()
    return {
        nTotalInstrumented = oPreempt.nTotalInstrumented,
        nTotalInjections   = oPreempt.nTotalInjections,
        nQuantumMs         = oPreempt.DEFAULT_QUANTUM * 1000,
        nCheckInterval     = oPreempt.CHECK_INTERVAL,
    }
end

return oPreempt
```


axis-os\src\kernel\lib\rdb.lua
```
--
-- /lib/rdb.lua
-- Amiga-style RDB partition table for AxisOS
--
local B = require("bpack")
local RDB = {}

RDB.MAGIC = "AXRD"
RDB.PT_MAGIC = "AXPT"
RDB.VERSION = 1
RDB.MAX_PARTS = 8

-- Header: sector 0
-- 0-3:magic 4:ver 5-6:ss 7-10:total 11:nparts 12-27:label 28-31:checksum

function RDB.packHeader(t, nSS)
  local s = RDB.MAGIC .. string.char(RDB.VERSION)
    .. B.u16(t.sectorSize) .. B.u32(t.totalSectors)
    .. string.char(#t.partitions) .. B.str(t.label, 16) .. "\0\0\0\0"
  return B.pad(s, nSS)
end

function RDB.readHeader(s)
  if #s < 32 or s:sub(1,4) ~= RDB.MAGIC then return nil, "No RDB" end
  return {
    version = s:byte(5),
    sectorSize = B.r16(s,6),
    totalSectors = B.r32(s,8),
    nParts = s:byte(12),
    label = B.rstr(s,13,16),
  }
end

-- Partition entry: sectors 1..1+MAX_PARTS
-- 0-3:magic 4:idx 5-20:name 21-28:fstype 29-32:start 33-36:size 37:flags 38:bootpri

function RDB.packPart(t, nSS)
  local s = RDB.PT_MAGIC .. string.char(t.index or 0)
    .. B.str(t.name or "PART", 16) .. B.str(t.fsType or "raw", 8)
    .. B.u32(t.startSector) .. B.u32(t.sizeInSectors)
    .. string.char(t.flags or 0) .. string.char(t.bootPriority or 0)
  return B.pad(s, nSS)
end

function RDB.readPart(s)
  if #s < 40 or s:sub(1,4) ~= RDB.PT_MAGIC then return nil end
  return {
    index = s:byte(5),
    name = B.rstr(s,6,16),
    fsType = B.rstr(s,22,8),
    startSector = B.r32(s,30),
    sizeInSectors = B.r32(s,34),
    flags = s:byte(38),
    bootPriority = s:byte(39),
  }
end

function RDB.write(tDisk, tRdb)
  tDisk.writeSector(0, RDB.packHeader(tRdb, tDisk.sectorSize))
  for i = 1, RDB.MAX_PARTS do
    local p = tRdb.partitions[i]
    if p then p.index = i-1; tDisk.writeSector(i, RDB.packPart(p, tDisk.sectorSize))
    else tDisk.writeSector(i, B.pad("", tDisk.sectorSize)) end
  end
  return true
end

function RDB.read(tDisk)
  local sH = tDisk.readSector(0)
  if not sH then return nil, "Read error" end
  local tH, sE = RDB.readHeader(sH)
  if not tH then return nil, sE end
  local tRdb = {
    label = tH.label, sectorSize = tH.sectorSize,
    totalSectors = tH.totalSectors, partitions = {},
  }
  for i = 1, tH.nParts do
    local sP = tDisk.readSector(i)
    if sP then
      local p = RDB.readPart(sP)
      if p then table.insert(tRdb.partitions, p) end
    end
  end
  return tRdb
end

-- Calculate next free sector after RDB + existing partitions
function RDB.nextFree(tRdb)
  local nNext = 1 + RDB.MAX_PARTS  -- after header + partition slots
  for _, p in ipairs(tRdb.partitions) do
    local nEnd = p.startSector + p.sizeInSectors
    if nEnd > nNext then nNext = nEnd end
  end
  return nNext
end

return RDB
```


axis-os\src\kernel\lib\registry.lua
```
--
-- /lib/registry.lua
-- AxisOS Virtual Registry — @VT Namespace
-- Hierarchical key-value store for device, driver, and system metadata.
--
-- Path format: @VT\DEV\VIRT_001  (backslash separated, @VT root)
-- Values are typed: STR, NUM, BOOL, TAB
--

local oReg = {}

-- =============================================
-- INTERNAL TREE
-- =============================================

local g_nNextDevId = 1
local g_nUptime = 0

local function fUptime()
    pcall(function()
        if raw_computer then
            g_nUptime = raw_computer.uptime()
        end
    end)
    return g_nUptime
end

local function fNewNode(sName)
    return {
        sName     = sName,
        tSubKeys  = {},
        tValues   = {},
        tMeta     = {
            nCreated  = fUptime(),
            nModified = fUptime(),
            nOwnerPid = 0,
        },
    }
end

local g_tRoot = fNewNode("@VT")

-- =============================================
-- PATH NAVIGATION
-- =============================================

local function fParsePath(sPath)
    if not sPath or #sPath == 0 then return {} end
    local sStripped = sPath
    -- strip @VT prefix
    if sStripped == "@VT" then return {} end
    if sStripped:sub(1, 4) == "@VT\\" then
        sStripped = sStripped:sub(5)
    elseif sStripped:sub(1, 3) == "@VT" then
        sStripped = sStripped:sub(4)
        if sStripped:sub(1, 1) == "\\" then sStripped = sStripped:sub(2) end
    end
    if #sStripped == 0 then return {} end
    local tParts = {}
    local nStart = 1
    for i = 1, #sStripped do
        if sStripped:sub(i, i) == "\\" then
            if i > nStart then
                table.insert(tParts, sStripped:sub(nStart, i - 1))
            end
            nStart = i + 1
        end
    end
    if nStart <= #sStripped then
        table.insert(tParts, sStripped:sub(nStart))
    end
    return tParts
end

local function fNavigate(sPath, bCreate)
    local tParts = fParsePath(sPath)
    local tCur = g_tRoot
    for _, sPart in ipairs(tParts) do
        if not tCur.tSubKeys[sPart] then
            if bCreate then
                tCur.tSubKeys[sPart] = fNewNode(sPart)
            else
                return nil
            end
        end
        tCur = tCur.tSubKeys[sPart]
    end
    return tCur
end

local function fGetParentAndChild(sPath)
    local tParts = fParsePath(sPath)
    if #tParts == 0 then return nil, nil end
    local sChild = table.remove(tParts)
    local sParent = "@VT"
    if #tParts > 0 then sParent = "@VT\\" .. table.concat(tParts, "\\") end
    return sParent, sChild
end

-- =============================================
-- PUBLIC API — KEY OPERATIONS
-- =============================================

function oReg.CreateKey(sPath)
    local tNode = fNavigate(sPath, true)
    return tNode ~= nil
end

function oReg.DeleteKey(sPath)
    local sParent, sChild = fGetParentAndChild(sPath)
    if not sParent or not sChild then return false end
    local tParent = fNavigate(sParent, false)
    if not tParent then return false end
    tParent.tSubKeys[sChild] = nil
    tParent.tMeta.nModified = fUptime()
    return true
end

function oReg.KeyExists(sPath)
    return fNavigate(sPath, false) ~= nil
end

-- =============================================
-- PUBLIC API — VALUE OPERATIONS
-- =============================================

function oReg.SetValue(sPath, sName, vValue, sType)
    local tNode = fNavigate(sPath, false)
    if not tNode then return false end
    if not sType then
        local t = type(vValue)
        if t == "number" then sType = "NUM"
        elseif t == "boolean" then sType = "BOOL"
        elseif t == "table" then sType = "TAB"
        else sType = "STR" end
    end
    tNode.tValues[sName] = { sType = sType, value = vValue }
    tNode.tMeta.nModified = fUptime()
    return true
end

function oReg.GetValue(sPath, sName)
    local tNode = fNavigate(sPath, false)
    if not tNode then return nil, nil end
    local tEntry = tNode.tValues[sName]
    if not tEntry then return nil, nil end
    return tEntry.value, tEntry.sType
end

function oReg.DeleteValue(sPath, sName)
    local tNode = fNavigate(sPath, false)
    if not tNode then return false end
    tNode.tValues[sName] = nil
    tNode.tMeta.nModified = fUptime()
    return true
end

-- =============================================
-- PUBLIC API — ENUMERATION
-- =============================================

function oReg.EnumKeys(sPath)
    local tNode = fNavigate(sPath, false)
    if not tNode then return {} end
    local tResult = {}
    for sName in pairs(tNode.tSubKeys) do
        table.insert(tResult, sName)
    end
    table.sort(tResult)
    return tResult
end

function oReg.EnumValues(sPath)
    local tNode = fNavigate(sPath, false)
    if not tNode then return {} end
    local tResult = {}
    for sName, tEntry in pairs(tNode.tValues) do
        table.insert(tResult, {
            sName = sName,
            sType = tEntry.sType,
            value = tEntry.value,
        })
    end
    table.sort(tResult, function(a, b) return a.sName < b.sName end)
    return tResult
end

function oReg.QueryInfo(sPath)
    local tNode = fNavigate(sPath, false)
    if not tNode then return nil end
    local nSubKeys = 0
    for _ in pairs(tNode.tSubKeys) do nSubKeys = nSubKeys + 1 end
    local nValues = 0
    for _ in pairs(tNode.tValues) do nValues = nValues + 1 end
    return {
        sName     = tNode.sName,
        nSubKeys  = nSubKeys,
        nValues   = nValues,
        nCreated  = tNode.tMeta.nCreated,
        nModified = tNode.tMeta.nModified,
        nOwnerPid = tNode.tMeta.nOwnerPid,
    }
end

-- =============================================
-- PUBLIC API — DEVICE ID GENERATION
-- =============================================

function oReg.AllocateDeviceId(sClass)
    local sPrefix = "DEV"
    if sClass == "virtual" then sPrefix = "VIRT"
    elseif sClass == "physical" then sPrefix = "PHYS"
    elseif sClass == "network" then sPrefix = "NET"
    elseif sClass == "block" then sPrefix = "BLK"
    end
    local sId = sPrefix .. "_" .. string.format("%03d", g_nNextDevId)
    g_nNextDevId = g_nNextDevId + 1
    return sId
end

-- =============================================
-- PUBLIC API — TREE DUMP (for debug/export)
-- =============================================

function oReg.DumpTree(sPath, nMaxDepth)
    nMaxDepth = nMaxDepth or 20
    local tResult = {}

    local function walk(sNodePath, nDepth)
        if nDepth > nMaxDepth then return end
        local tInfo = oReg.QueryInfo(sNodePath)
        if not tInfo then return end
        table.insert(tResult, {
            sPath    = sNodePath,
            nDepth   = nDepth,
            sName    = tInfo.sName,
            nSubKeys = tInfo.nSubKeys,
            nValues  = tInfo.nValues,
        })
        local tKeys = oReg.EnumKeys(sNodePath)
        for _, sKey in ipairs(tKeys) do
            walk(sNodePath .. "\\" .. sKey, nDepth + 1)
        end
    end

    walk(sPath or "@VT", 0)
    return tResult
end

-- =============================================
-- INITIALIZATION
-- =============================================

function oReg.InitSystem()
    fNavigate("@VT\\DEV", true)
    fNavigate("@VT\\DRV", true)
    fNavigate("@VT\\SYS", true)
    fNavigate("@VT\\SYS\\BOOT", true)
    fNavigate("@VT\\SYS\\CONFIG", true)
    fNavigate("@VT\\SYS\\HARDWARE", true)

    oReg.SetValue("@VT\\SYS\\BOOT", "KernelVersion", "0.3", "STR")
    oReg.SetValue("@VT\\SYS\\BOOT", "BootTime", fUptime(), "NUM")
    oReg.SetValue("@VT\\SYS\\BOOT", "RegistryVersion", "1.0.0", "STR")
end

return oReg
```


axis-os\src\kernel\lib\signal_lib.lua
```
--
-- /lib/signal_lib.lua — User-space signal API
--

local oSig = {}

oSig.SIGHUP=1  oSig.SIGINT=2  oSig.SIGQUIT=3  oSig.SIGILL=4
oSig.SIGABRT=6 oSig.SIGKILL=9 oSig.SIGPIPE=13 oSig.SIGALRM=14
oSig.SIGTERM=15 oSig.SIGCHLD=17 oSig.SIGCONT=18 oSig.SIGSTOP=19
oSig.SIGTSTP=20 oSig.SIGUSR1=30 oSig.SIGUSR2=31

oSig.SIG_DFL = nil   -- pass nil to reset to default
oSig.SIG_IGN = function() end  -- ignore handler

function oSig.handle(nSignal, fHandler)
    return syscall("ke_signal_handler", nSignal, fHandler)
end

function oSig.send(nPid, nSignal)
    return syscall("ke_signal_send", nPid, nSignal)
end

function oSig.sendGroup(nPgid, nSignal)
    return syscall("ke_signal_group", nPgid, nSignal)
end

function oSig.mask(tMask)
    return syscall("ke_signal_mask", tMask)
end

function oSig.setpgid(nPid, nPgid)
    return syscall("ke_setpgid", nPid, nPgid)
end

function oSig.getpgid()
    return syscall("ke_getpgid")
end

return oSig
```


axis-os\src\kernel\lib\sync.lua
```
--
-- /lib/sync.lua — User-space synchronization primitives
--

local oSync = {}

function oSync.createEvent(bManualReset, bInitial)
    return syscall("ke_create_event", bManualReset or false, bInitial or false)
end
function oSync.setEvent(h) return syscall("ke_set_event", h) end
function oSync.resetEvent(h) return syscall("ke_reset_event", h) end
function oSync.pulseEvent(h) return syscall("ke_pulse_event", h) end

function oSync.createMutex(bOwned)
    return syscall("ke_create_mutex", bOwned or false)
end
function oSync.releaseMutex(h) return syscall("ke_release_mutex", h) end

function oSync.createSemaphore(nInit, nMax)
    return syscall("ke_create_semaphore", nInit or 1, nMax or 0x7FFFFFFF)
end
function oSync.releaseSemaphore(h, n)
    return syscall("ke_release_semaphore", h, n or 1)
end

function oSync.wait(h, nTimeoutMs)
    return syscall("ke_wait_single", h, nTimeoutMs)
end

function oSync.waitMultiple(tHandles, bWaitAll, nTimeoutMs)
    return syscall("ke_wait_multiple", tHandles, bWaitAll or false, nTimeoutMs)
end

function oSync.createTimer()
    return syscall("ke_create_timer")
end
function oSync.setTimer(h, nDelayMs, nPeriodMs)
    return syscall("ke_set_timer", h, nDelayMs, nPeriodMs)
end
function oSync.cancelTimer(h)
    return syscall("ke_cancel_timer", h)
end

oSync.WAIT_0       = 0
oSync.WAIT_TIMEOUT = 258
oSync.WAIT_FAILED  = -1

return oSync
```


axis-os\src\kernel\lib\syscall.lua
```
--
-- /lib/syscall.lua
-- User-mode syscall convenience wrappers.
-- v2: Object Handle aware. Synapse token retrieval.
--

local sys = {}

sys.write = function(...)
  local parts = {}
  for i = 1, select("#", ...) do
    parts[i] = tostring(select(i, ...))
  end
  syscall("vfs_write", 1, table.concat(parts, "\t")) -- alias 1 = stdout
end

sys.read = function()
  local ok, data = syscall("vfs_read", 0) -- alias 0 = stdin
  return data
end

sys.spawn = function(path, ring_or_env, env)
  local r = 3
  local e = {}
  if type(ring_or_env) == "number" then
     r = ring_or_env
     e = env or {}
  else
     e = ring_or_env or {}
  end
  return syscall("process_spawn", path, r, e)
end

sys.wait = function(pid)
  return syscall("process_wait", pid)
end

sys.reboot = function()
  return syscall("computer_reboot")
end

sys.shutdown = function()
  return syscall("computer_shutdown")
end

-- sMLTR: get this process's synapse token
sys.getSynapseToken = function()
  return syscall("synapse_get_token")
end

-- syscall passthrough for insmod etc
sys.syscall = function(...)
  return syscall(...)
end

return sys
```


axis-os\src\kernel\lib\thread.lua
```
--
-- /lib/thread.lua
-- Multithreading library for AxisOS Ring 3.
-- v2: Proper join, kill, status, and detach.
--     Threads run cooperatively in user-space via the kernel scheduler.
--

local oSys = require("syscall")
local oThread = {}

-- Thread state constants (mirrors kernel process status)
oThread.RUNNING  = "running"
oThread.READY    = "ready"
oThread.SLEEPING = "sleeping"
oThread.DEAD     = "dead"

-- Creates a new thread from a function.
-- The thread shares the parent process's sandbox (globals, env, fds).
-- Returns a thread object or nil + error.
function oThread.create(fFunc)
  if type(fFunc) ~= "function" then
    return nil, "Argument must be a function"
  end

  local nPid, sErr = syscall("process_thread", fFunc)
  
  if not nPid then
    return nil, sErr or "Failed to create thread"
  end
  
  local tThreadObj = {
    pid = nPid,
    _detached = false,
    _joined = false,
  }
  
  -- Wait for the thread to finish. Blocks the calling thread.
  function tThreadObj:join()
    if self._joined then return true end
    if self._detached then return nil, "Cannot join detached thread" end
    self._joined = true
    return oSys.wait(self.pid)
  end
  
  -- Kill the thread. Sends SIGKILL equivalent.
  function tThreadObj:kill()
    local bOk, sErr = syscall("process_kill", self.pid)
    return bOk, sErr
  end
  
  -- Check if the thread is still alive.
  function tThreadObj:alive()
    local sStatus = syscall("process_status", self.pid)
    return sStatus and sStatus ~= "dead"
  end
  
  -- Get thread status string.
  function tThreadObj:status()
    return syscall("process_status", self.pid) or "dead"
  end
  
  -- Detach the thread. It will clean up on its own when done.
  function tThreadObj:detach()
    self._detached = true
  end
  
  return tThreadObj
end

-- Yield the current thread's timeslice to let others run.
function oThread.yield()
  syscall("process_yield")
end

-- Sleep the current thread for approximately nSeconds.
function oThread.sleep(nSeconds)
  local nDeadline = require("computer").uptime() + nSeconds
  while require("computer").uptime() < nDeadline do
    syscall("process_wait", 0)
  end
end

-- Get a list of thread PIDs spawned by the current process.
function oThread.list()
  return syscall("process_list_threads") or {}
end

-- Spawn multiple threads and wait for all of them.
-- tFuncs is a list of functions. Returns when all complete.
function oThread.parallel(tFuncs)
  local tThreads = {}
  for _, fFunc in ipairs(tFuncs) do
    local t, sErr = oThread.create(fFunc)
    if t then
      table.insert(tThreads, t)
    end
  end
  for _, t in ipairs(tThreads) do
    t:join()
  end
  return #tThreads
end

return oThread
```


axis-os\src\kernel\sys\security\dkms_sec.lua
```
-- /sys/security/dkms_sec.lua
-- AxisOS Driver Security Validator v2
-- Now with REAL cryptographic signature verification

local tStatus = require("errcheck")
local tDKStructs = require("shared_structs")

local oSec = {}

-- Signature block format embedded in driver files:
-- Last lines of the file contain:
--   --@SIGNATURE:base64_encoded_ecdsa_signature
--   --@SIGNER:fingerprint_of_signing_key
--   --@HASH:sha256_of_code_without_signature_block

local g_oCrypto = nil
local g_tApprovedKeys = {}
local g_bInitialized = false
local g_nSecurityLevel = 0  -- 0=disabled, 1=warn, 2=enforce

function oSec.Initialize(tConfig)
    if g_bInitialized then return true end

    local nStart = os.clock()
    syscall("kernel_log", "[SEC] ── Security Subsystem Init ──")

    -- =============================================
    -- STEP 1: Crypto provider
    -- crypto.lua uses component.list() which works via
    -- the sandbox metatable chain. No PM round-trip.
    -- =============================================
    syscall("kernel_log", "[SEC] [1/3] Crypto provider...")
    local bOk, oCrypto = pcall(require, "crypto")
    if bOk and oCrypto then
        local bInit, nTier = oCrypto.Init()
        if bInit then
            g_oCrypto = oCrypto
            syscall("kernel_log", "[SEC] [1/3] Data Card Tier " .. nTier)
        else
            syscall("kernel_log", "[SEC] [1/3] No data card. Hash-only mode.")
        end
    else
        syscall("kernel_log", "[SEC] [1/3] crypto.lua unavailable. UNSIGNED mode.")
    end

    -- =============================================
    -- STEP 2: Security policy (direct kernel read — NO PM)
    -- syscall("vfs_read_file") is NOT overridden to PM,
    -- it calls primitive_load() = raw filesystem access.
    -- =============================================
    syscall("kernel_log", "[SEC] [2/3] Security policy...")
    g_nSecurityLevel = (tConfig and tConfig.security_level) or 0

    local sCfgCode = syscall("vfs_read_file", "/etc/pki.cfg")
    if sCfgCode then
        local fCfg = load(sCfgCode, "pki.cfg", "t", {})
        if fCfg then
            local bCfgOk, tCfg = pcall(fCfg)
            if bCfgOk and type(tCfg) == "table" then
                g_nSecurityLevel = tCfg.security_level or g_nSecurityLevel
            end
        end
    end

    local tLevelNames = {
        [0] = "DISABLED", [1] = "WARN", [2] = "ENFORCE",
    }
    syscall("kernel_log", "[SEC] [2/3] Level " ..
            g_nSecurityLevel .. " (" ..
            (tLevelNames[g_nSecurityLevel] or "?") .. ")")

    -- =============================================
    -- STEP 3: Approved key store (direct kernel read — NO PM)
    -- We do NOT require("pki_client") here because it
    -- pulls in http → filesystem → PM round-trips.
    -- Instead we read the keystore file directly.
    -- =============================================
    syscall("kernel_log", "[SEC] [3/3] Key store...")
    g_tApprovedKeys = {}

    local sKeyCode = syscall("vfs_read_file", "/etc/pki_keystore.lua")
    if sKeyCode and #sKeyCode > 0 then
        local fKeys = load(sKeyCode, "keystore", "t", {})
        if fKeys then
            local bKeysOk, tKeys = pcall(fKeys)
            if bKeysOk and type(tKeys) == "table" then
                g_tApprovedKeys = tKeys
            end
        end
    end

    local nKeys = 0
    for _ in pairs(g_tApprovedKeys) do nKeys = nKeys + 1 end
    syscall("kernel_log", "[SEC] [3/3] " .. nKeys .. " approved key(s)")

    local nMs = math.floor((os.clock() - nStart) * 1000)
    syscall("kernel_log", "[SEC] ── Ready in " .. nMs .. "ms ──")

    g_bInitialized = true
    return true
end

-- Extract signature block from driver source code
local function fExtractSignature(sCode)
    local sSig, sSigner, sHash
    local sCodeBody = sCode
    
    -- Find and extract signature lines from end of file
    local tLines = {}
    for line in sCode:gmatch("[^\n]+") do
        tLines[#tLines + 1] = line
    end
    
    -- Scan last 5 lines for signature block
    local nSigStart = nil
    for i = math.max(1, #tLines - 4), #tLines do
        local line = tLines[i]
        if not sSig then
            local s = line:match("^%-%-@SIGNATURE:(.+)$")
            if s then sSig = s; nSigStart = nSigStart or i end
        end
        if not sSigner then
            local s = line:match("^%-%-@SIGNER:(.+)$")
            if s then sSigner = s; nSigStart = nSigStart or i end
        end
        if not sHash then
            local s = line:match("^%-%-@HASH:(.+)$")
            if s then sHash = s; nSigStart = nSigStart or i end
        end
    end
    
    -- Reconstruct code body without signature block
    if nSigStart then
        local tBody = {}
        for i = 1, nSigStart - 1 do
            tBody[#tBody + 1] = tLines[i]
        end
        sCodeBody = table.concat(tBody, "\n")
    end
    
    return sSig, sSigner, sHash, sCodeBody
end

-- Validate driver signature
function oSec.fValidateDriverSignature(sDriverCode)
    if not g_bInitialized then oSec.Initialize() end
    
    -- Security level 0 = no enforcement
    if g_nSecurityLevel == 0 then
        return tStatus.STATUS_SUCCESS
    end
    
    -- No crypto available
    if not g_oCrypto then
        if g_nSecurityLevel >= 2 then
            return tStatus.STATUS_DRIVER_VALIDATION_FAILED, 
                   "No data card: cannot verify signatures (enforcement mode)"
        end
        syscall("kernel_log", "[SEC] WARN: Loading unsigned driver (no data card)")
        return tStatus.STATUS_SUCCESS
    end
    
    -- Extract signature
    local sSig, sSigner, sExpectedHash, sCodeBody = fExtractSignature(sDriverCode)
    
    if not sSig or not sSigner then
        if g_nSecurityLevel >= 2 then
            return tStatus.STATUS_DRIVER_VALIDATION_FAILED,
                   "Driver is NOT SIGNED. Blocked by security policy."
        end
        syscall("kernel_log", "[SEC] WARN: Loading UNSIGNED driver")
        return tStatus.STATUS_SUCCESS
    end
    
    -- Verify hash matches code body
    local sActualHash = g_oCrypto.Encode64(g_oCrypto.SHA256(sCodeBody))
    if sExpectedHash and sActualHash ~= sExpectedHash then
        return tStatus.STATUS_DRIVER_VALIDATION_FAILED,
               "Hash mismatch: driver code was MODIFIED after signing"
    end
    
    -- Look up signer in approved keys
    local tKeyInfo = g_tApprovedKeys[sSigner]
    if not tKeyInfo then
        -- Try cloud lookup
        local bPkiOk, oPki = pcall(require, "pki_client")
        if bPkiOk then
            local sStatus = oPki.CheckKeyStatus(sSigner)
            if sStatus ~= "approved" then
                if g_nSecurityLevel >= 2 then
                    return tStatus.STATUS_DRIVER_VALIDATION_FAILED,
                           "Signing key " .. sSigner:sub(1,12) .. "... is NOT APPROVED (status: " .. sStatus .. ")"
                end
                syscall("kernel_log", "[SEC] WARN: Signer key not approved: " .. sSigner:sub(1,12))
                return tStatus.STATUS_SUCCESS
            end
        else
            if g_nSecurityLevel >= 2 then
                return tStatus.STATUS_DRIVER_VALIDATION_FAILED,
                       "Unknown signer and PKI unavailable"
            end
        end
    end
    
    -- ECDSA signature verification (Tier 3 only)
    if g_oCrypto.GetTier() >= 3 and tKeyInfo then
        local oPubKey = g_oCrypto.DeserializeKey(tKeyInfo.public_key, "ec-public")
        if oPubKey then
            local sSigRaw = g_oCrypto.Decode64(sSig)
            local bValid = g_oCrypto.Verify(sCodeBody, sSigRaw, oPubKey)
            
            if bValid then
                syscall("kernel_log", "[SEC] ✓ Signature VALID (signer: " .. 
                        (tKeyInfo.username or "?") .. ", key: " .. sSigner:sub(1,12) .. "...)")
                return tStatus.STATUS_SUCCESS
            else
                return tStatus.STATUS_DRIVER_VALIDATION_FAILED,
                       "Signature INVALID! Code may be tampered."
            end
        else
            syscall("kernel_log", "[SEC] WARN: Could not deserialize signer public key")
        end
    end
    
    -- If we get here with enforcement, hash-only verification passed
    syscall("kernel_log", "[SEC] Hash verified, ECDSA skipped (Tier < 3 or key unavailable)")
    return tStatus.STATUS_SUCCESS
end

-- Unchanged from original
function oSec.fValidateDriverInfo(tDriverInfo)
    if type(tDriverInfo) ~= "table" then
        return tStatus.STATUS_INVALID_DRIVER_INFO, "g_tDriverInfo is not a table"
    end
    if type(tDriverInfo.sDriverName) ~= "string" or #tDriverInfo.sDriverName == 0 then
        return tStatus.STATUS_INVALID_DRIVER_INFO, "Missing or invalid sDriverName"
    end
    if type(tDriverInfo.sDriverType) ~= "string" then
        return tStatus.STATUS_INVALID_DRIVER_INFO, "Missing sDriverType"
    end
    if tDriverInfo.sDriverType ~= tDKStructs.DRIVER_TYPE_KMD and 
       tDriverInfo.sDriverType ~= tDKStructs.DRIVER_TYPE_UMD and
       tDriverInfo.sDriverType ~= tDKStructs.DRIVER_TYPE_CMD then
        return tStatus.STATUS_INVALID_DRIVER_TYPE, "Unknown sDriverType"
    end
    if type(tDriverInfo.nLoadPriority) ~= "number" then
        return tStatus.STATUS_INVALID_DRIVER_INFO, "Missing nLoadPriority"
    end
    return tStatus.STATUS_SUCCESS
end

return oSec
```


axis-os\src\kernel\system\lib\dk\common_api.lua
```
--
-- /system/lib/dk/common_api.lua
-- functions for every driver, whether you're a god-tier kernel driver
-- or a humble user-mode peasant.
--

local fSyscall = syscall
local oDK = {}

-- the one true print function for drivers.
-- it's just a wrapper around the kernel log, but it feels more official.
function oDK.DkPrint(sMessage)
  fSyscall("kernel_log", "[DK] " .. tostring(sMessage))
end

return oDK
```


axis-os\src\kernel\system\lib\dk\kmd_api.lua
```
--
-- /system/lib/dk/kmd_api.lua
--

local fSyscall = syscall
local tStatus = require("errcheck")
local oKMD = require("common_api") 

local function CallDkms(sName, ...)
  local bOk, val1, val2 = fSyscall(sName, ...)
  return val1, val2
end

function oKMD.DkCreateDevice(pDriverObject, sDeviceName)
  oKMD.DkPrint("DkCreateDevice: " .. sDeviceName)
  
  -- Removed pDriverObject.nDriverPid.
  -- DKMS will automatically determine the caller's PID.
  local pDeviceObject, nStatus = CallDkms("dkms_create_device", sDeviceName)
  
  if pDeviceObject then
    return tStatus.STATUS_SUCCESS, pDeviceObject
  else
    return nStatus or tStatus.STATUS_UNSUCCESSFUL, nil
  end
end

function oKMD.DkCreateSymbolicLink(sLinkName, sDeviceName)
  oKMD.DkPrint("SymLink: " .. sLinkName .. " -> " .. sDeviceName)
  local nStatus = CallDkms("dkms_create_symlink", sLinkName, sDeviceName)
  return nStatus
end

function oKMD.DkDeleteDevice(pDeviceObject)
  if not pDeviceObject or type(pDeviceObject) ~= "table" then return tStatus.STATUS_INVALID_PARAMETER end
  local nStatus = CallDkms("dkms_delete_device", pDeviceObject.sDeviceName)
  return nStatus
end

function oKMD.DkDeleteSymbolicLink(sLinkName)
  local nStatus = CallDkms("dkms_delete_symlink", sLinkName)
  return nStatus
end

function oKMD.DkCompleteRequest(pIrp, nStatus, vInformation)
  pIrp.tIoStatus.nStatus = nStatus
  pIrp.tIoStatus.vInformation = vInformation
  fSyscall("dkms_complete_irp", pIrp)
end

function oKMD.DkGetHardwareProxy(sAddress)
    -- direct syscall, returns data immediately
    local oProxyOrErr, sErr = fSyscall("raw_component_proxy", sAddress)
    if oProxyOrErr then
        return tStatus.STATUS_SUCCESS, oProxyOrErr
    else
        return tStatus.STATUS_NO_SUCH_DEVICE, sErr
    end
end

function oKMD.DkRegisterInterrupt(sEventName)
    local nStatus = CallDkms("dkms_register_interrupt", sEventName)
    return nStatus
end

function oKMD.DkCreateComponentDevice(pDriverObject, sDeviceTypeName)
  -- 1. Verify we are actually a component driver
  local sAddress = env.address
  if not sAddress then
    oKMD.DkPrint("DkCreateComponentDevice: No address in env! Are you a CMD?")
    return tStatus.STATUS_INVALID_PARAMETER
  end
  
  -- 2. Get the next available index from DKMS
  local nIndex, _ = CallDkms("dkms_get_next_index", sDeviceTypeName)
  if not nIndex then nIndex = 0 end -- fallback, shouldn't happen
  
  -- 3. Format the names
  -- short address is first 6 chars. enough to be unique-ish.
  local sShortAddr = string.sub(sAddress, 1, 6)
  
  -- Internal Kernel Name: \Device\iter_a1b2c3
  -- We don't strictly need the index here if address is unique, but let's keep it clean.
  local sInternalName = string.format("\\Device\\%s_%s", sDeviceTypeName, sShortAddr)
  
  -- User-facing Symlink: /dev/iter_a1b2c3_0
  local sSymlinkName = string.format("/dev/%s_%s_%d", sDeviceTypeName, sShortAddr, nIndex)
  
  oKMD.DkPrint("Auto-creating CMD Device: " .. sSymlinkName)
  
  -- 4. Create the Device Object
  local nStatus, pDeviceObject = oKMD.DkCreateDevice(pDriverObject, sInternalName)
  if nStatus ~= tStatus.STATUS_SUCCESS then
    return nStatus, nil
  end
  
  -- 5. Create the Symlink
  nStatus = oKMD.DkCreateSymbolicLink(sSymlinkName, sInternalName)
  if nStatus ~= tStatus.STATUS_SUCCESS then
    oKMD.DkDeleteDevice(pDeviceObject)
    return nStatus, nil
  end
  
  -- Store the auto-generated names in the extension so we can delete them later easily
  pDeviceObject.pDeviceExtension.sAutoSymlink = sSymlinkName
  
  return tStatus.STATUS_SUCCESS, pDeviceObject
end

return oKMD
```


axis-os\src\kernel\system\lib\dk\shared_structs.lua
```
--
-- /system/lib/dk/shared_structs.lua
-- the blueprints for our driver model.
-- these are the lego bricks that every driver is built from.
--

local oDK = {}

-- IRP Major Function Codes
-- basically, "what kind of job is this?"
oDK.IRP_MJ_CREATE = 0x00
oDK.IRP_MJ_CLOSE = 0x02
oDK.IRP_MJ_READ = 0x03
oDK.IRP_MJ_WRITE = 0x04
oDK.IRP_MJ_DEVICE_CONTROL = 0x0E

-- Driver Types
oDK.DRIVER_TYPE_KMD = "KernelModeDriver"    -- Ring 0-2, full power, god mode enabled
oDK.DRIVER_TYPE_UMD = "UserModeDriver"      -- Ring 3, sandboxed, playing with plastic toys
oDK.DRIVER_TYPE_CMD = "ComponentModeDriver" -- Ring 2, strict hardware binding. no address? no entry.

oDK.IRP_FLAG_NO_REPLY = 0x10



-- The DRIVER_OBJECT
-- this is the driver's soul. it represents the loaded driver image.
function oDK.fNewDriverObject()
  return {
    sDriverPath = nil,         -- path to the driver file
    nDriverPid = nil,          -- the PID of the process running the driver code
    pDeviceObject = nil,       -- linked list of devices this driver owns
    fDriverUnload = nil,       -- the function to call when unloading
    tDispatch = {},            -- the table of IRP handlers (e.g., [IRP_MJ_READ] = fMyReadFunc)
    tDriverInfo = {},          -- a copy of the driver's static info table
  }
end

-- The DEVICE_OBJECT
-- this represents a thing the driver controls. a virtual tty, a gpu, a file system...
function oDK.fNewDeviceObject()
  return {
    pDriverObject = nil,       -- back-pointer to the driver that owns this
    pNextDevice = nil,         -- for the linked list of devices
    sDeviceName = nil,         -- e.g., "\\Device\\Serial0"
    pDeviceExtension = {},     -- a scratchpad for the driver to store its own state
    nFlags = 0,
  }
end

-- The IRP (I/O Request Packet)
-- a little packet of work. a "please do this" note passed to the driver.
function oDK.fNewIrp(nMajorFunction)
  return {
    nMajorFunction = nMajorFunction,
    pDeviceObject = nil,
    tParameters = {},          -- arguments for the operation (e.g., buffer for read, data for write)
    tIoStatus = {
      nStatus = 0,             -- will be filled with a STATUS_ code
      vInformation = nil,      -- return value (e.g., bytes read)
    },
    nSenderPid = nil,          -- who originally sent this request?
    nFlags = 0
  }
end

return oDK
```


axis-os\src\kernel\system\lib\dk\spinlock.lua
```
-- /system/lib/dk/spinlock.lua
local tDKStructs = require("shared_structs")
local syscall = syscall

local SpinLock = {}

function SpinLock.KeInitializeSpinLock()
  return { bLocked = false }
end

function SpinLock.KeAcquireSpinLock(tLock)
  local nOldIrql = syscall("KeRaiseIrql", tDKStructs.DISPATCH_LEVEL)
  tLock.bLocked = true
  
  return nOldIrql
end

function SpinLock.KeReleaseSpinLock(tLock, nNewIrql)
  tLock.bLocked = false
  syscall("KeLowerIrql", nNewIrql)
end

return SpinLock
```


axis-os\src\kernel\system\lib\dk\umd_api.lua
```
--
-- /system/lib/dk/umd_api.lua
-- the user-mode driver api. you live in a little box and you'll be happy about it.
-- no direct hardware access for you. talk to your host process.
--

local fSyscall = syscall
local tStatus = require("errcheck")
local oUMD = require("common_api") -- inherit common functions

-- for a UMD, all "privileged" operations are just signals to the UMDH process.

function oUMD.UmdCompleteRequest(pIrp, nStatus, vInformation)
  pIrp.tIoStatus.nStatus = nStatus
  pIrp.tIoStatus.vInformation = vInformation
  -- we can't call the kernel directly. we send a signal to our host,
  -- and the host will complete the request for us.
  fSyscall("signal_send", env.nHostPid, "umd_complete_irp", pIrp)
end

-- UMDs can't create devices or links. this is done by a higher-level manager.
-- these functions are intentionally left out. trying to call them would be an error.

return oUMD
```


axis-os\src\kernel\system\dkms.lua
```
--
-- /system/dkms.lua
-- Dynamic Kernel Module System (Buffered)
--

local syscall = syscall
local tStatus = require("errcheck")
local tDKStructs = require("shared_structs")
local oSec = require("dkms_sec")
local oDispatcher = require("driverdispatch")

syscall("kernel_log", "[DKMS] Ring 1 Driver Manager starting.")

syscall("kernel_log", "[DKMS] Ring 1 Driver Manager starting.")

-- Initialize security subsystem EAGERLY (before any driver loads)
-- This prevents a stall during the first load_driver() call.
oSec.Initialize()

local g_tDriverRegistry = {}
local g_tDeviceTree = {}
local g_tSymbolicLinks = {}
local g_tPendingIrps = {}
local g_tSignalQueue = {}

local g_tDeviceTypeCounters = {}
-- ====================================

-- Syscall Overrides
syscall("syscall_override", "dkms_create_device")
syscall("syscall_override", "dkms_create_symlink")
syscall("syscall_override", "dkms_delete_device")
syscall("syscall_override", "dkms_delete_symlink")
syscall("syscall_override", "dkms_complete_irp")
syscall("syscall_override", "dkms_register_interrupt")

syscall("syscall_override", "dkms_get_next_index") 

local tSyscallHandlers = {}


function tSyscallHandlers.dkms_create_device(nCallerPid, sDeviceName)
  local pDriverObject
  for _, pObj in pairs(g_tDriverRegistry) do
    if pObj.nDriverPid == nCallerPid then pDriverObject = pObj; break end
  end
  if not pDriverObject then return nil, tStatus.STATUS_ACCESS_DENIED end
  if g_tDeviceTree[sDeviceName] then return nil, tStatus.STATUS_DEVICE_ALREADY_EXISTS end

  local pDeviceObject = tDKStructs.fNewDeviceObject()
  pDeviceObject.pDriverObject = pDriverObject
  pDeviceObject.sDeviceName = sDeviceName
  pDeviceObject.pNextDevice = pDriverObject.pDeviceObject
  pDriverObject.pDeviceObject = pDeviceObject
  g_tDeviceTree[sDeviceName] = pDeviceObject
  syscall("kernel_log", "[DKMS] Device '" .. sDeviceName .. "' created.")

  -- === REGISTRY: register device ===
  local tInfo = pDriverObject.tDriverInfo or {}
  local bPhysical = (tInfo.sDriverType == tDKStructs.DRIVER_TYPE_CMD)
  local sClass = bPhysical and "physical" or "virtual"
  local sDevId = syscall("reg_alloc_device_id", sClass)

  if sDevId then
    local sRegPath = "@VT\\DEV\\" .. sDevId
    syscall("reg_create_key", sRegPath)
    syscall("reg_set_value", sRegPath, "DeviceName",   sDeviceName,                   "STR")
    syscall("reg_set_value", sRegPath, "DriverName",    tInfo.sDriverName or "Unknown", "STR")
    syscall("reg_set_value", sRegPath, "DriverPID",     nCallerPid,                     "NUM")
    syscall("reg_set_value", sRegPath, "DriverType",    tInfo.sDriverType or "Unknown", "STR")
    syscall("reg_set_value", sRegPath, "DriverVersion", tInfo.sVersion or "N/A",        "STR")
    syscall("reg_set_value", sRegPath, "DeviceClass",   sClass,                         "STR")
    syscall("reg_set_value", sRegPath, "Status",        "online",                       "STR")
    syscall("reg_set_value", sRegPath, "Ring",          2,                              "NUM")

    -- store the registry ID in the device object for later cleanup
    pDeviceObject.sRegistryId = sDevId
    pDeviceObject.sRegistryPath = sRegPath

    syscall("kernel_log", "[DKMS] Registered in @VT\\DEV\\" .. sDevId)
  end

  return pDeviceObject, tStatus.STATUS_SUCCESS
end

function tSyscallHandlers.dkms_create_symlink(nCallerPid, sLinkName, sDeviceName)
  if not g_tDeviceTree[sDeviceName] then return tStatus.STATUS_NO_SUCH_DEVICE end
  g_tSymbolicLinks[sLinkName] = sDeviceName
  syscall("kernel_log", "[DKMS] Symlink '" .. sLinkName .. "' -> '" .. sDeviceName .. "' created.")

  -- === REGISTRY: store symlink on the device node ===
  local pDev = g_tDeviceTree[sDeviceName]
  if pDev and pDev.sRegistryPath then
    syscall("reg_set_value", pDev.sRegistryPath, "Symlink", sLinkName, "STR")
    -- extract friendly name from symlink: /dev/tty → tty
    local sFriendly = sLinkName:match("^/dev/(.+)$") or sLinkName
    syscall("reg_set_value", pDev.sRegistryPath, "FriendlyName", sFriendly, "STR")
  end

  return tStatus.STATUS_SUCCESS
end

function tSyscallHandlers.dkms_delete_device(nCallerPid, sDeviceName)
    local pDeviceObject = g_tDeviceTree[sDeviceName]
    if not pDeviceObject then return tStatus.STATUS_NO_SUCH_DEVICE end

    -- === REGISTRY: mark offline then delete ===
    if pDeviceObject.sRegistryPath then
        syscall("reg_set_value", pDeviceObject.sRegistryPath, "Status", "offline", "STR")
        syscall("reg_delete_key", pDeviceObject.sRegistryPath)
    end

    g_tDeviceTree[sDeviceName] = nil
    pDeviceObject.pDriverObject.pDeviceObject = nil
    return tStatus.STATUS_SUCCESS
end

function tSyscallHandlers.dkms_delete_symlink(nCallerPid, sLinkName)
    g_tSymbolicLinks[sLinkName] = nil
    return tStatus.STATUS_SUCCESS
end

function tSyscallHandlers.dkms_complete_irp(nCallerPid, pIrp, nStatusOverride)
    if not pIrp then return tStatus.STATUS_INVALID_PARAMETER end
    if nStatusOverride then pIrp.tIoStatus.nStatus = nStatusOverride end

    if pIrp.nMajorFunction == 0x00 then -- IRP_MJ_CREATE
       local pDev = g_tDeviceTree[pIrp.sDeviceName]
       if pDev and pDev.pDriverObject then
          pIrp.tIoStatus.vInformation = pDev.pDriverObject.nDriverPid
       end
    end
    -- [[ END FIX ]]

    local bNoReply = false
    if pIrp.nFlags and type(pIrp.nFlags) == "number" then
       local nFlagVal = tDKStructs.IRP_FLAG_NO_REPLY
       local nRem = pIrp.nFlags % (nFlagVal * 2)
       if nRem >= nFlagVal then bNoReply = true end
    end
    
    if not bNoReply then
       syscall("signal_send", pIrp.nSenderPid, "syscall_return", pIrp.tIoStatus.nStatus, pIrp.tIoStatus.vInformation)
    end
    
    g_tPendingIrps[pIrp.nSenderPid] = nil
    return tStatus.STATUS_SUCCESS
end

function tSyscallHandlers.dkms_register_interrupt(nCallerPid, sEventName)
    syscall("kernel_log", "[DKMS] PID " .. nCallerPid .. " registered for interrupt '" .. sEventName .. "'")
    return tStatus.STATUS_SUCCESS
end

function tSyscallHandlers.dkms_get_next_index(nCallerPid, sDeviceType)
    if not sDeviceType then return nil, tStatus.STATUS_INVALID_PARAMETER end
    
    if not g_tDeviceTypeCounters[sDeviceType] then
        g_tDeviceTypeCounters[sDeviceType] = 0
    end
    
    local nIndex = g_tDeviceTypeCounters[sDeviceType]
    g_tDeviceTypeCounters[sDeviceType] = nIndex + 1
    
    return nIndex, tStatus.STATUS_SUCCESS
end

local function inspect_driver(sDriverPath)
  local sCode, sErr = syscall("vfs_read_file", sDriverPath)
  if not sCode then return nil, tStatus.STATUS_NO_SUCH_FILE end
  
  -- give the inspection sandbox access to require, 
  -- otherwise drivers calling require() at the top level will crash here.
  local tTempEnv = { require = require }
  
  local fChunk, sLoadErr = load(sCode, "@" .. sDriverPath, "t", tTempEnv)
  if not fChunk then return nil, tStatus.STATUS_INVALID_DRIVER_OBJECT end
  
  -- run the chunk. it might fail if it tries to do actual work, 
  -- but we only care if it defines g_tDriverInfo.
  pcall(fChunk)
  
  if type(tTempEnv.g_tDriverInfo) ~= "table" then
     return nil, tStatus.STATUS_INVALID_DRIVER_INFO
  end
  
  return tTempEnv.g_tDriverInfo
end

function load_driver(sDriverPath, tDriverEnv)
  syscall("kernel_log", "[DKMS] Loading: " .. sDriverPath)
  
  local sCode, sErr = syscall("vfs_read_file", sDriverPath)
  if not sCode then return tStatus.STATUS_NO_SUCH_FILE end
  
  local nStatus = oSec.fValidateDriverSignature(sCode)
  if nStatus ~= tStatus.STATUS_SUCCESS then return nStatus end
  
  local tTempEnv = { require = require }
  local fChunk, sLoadErr = load(sCode, "@" .. sDriverPath, "t", tTempEnv)
  if not fChunk then return tStatus.STATUS_INVALID_DRIVER_OBJECT end
  pcall(fChunk)
  
  local tDriverInfo = tTempEnv.g_tDriverInfo
  nStatus, sErr = oSec.fValidateDriverInfo(tDriverInfo)
  if nStatus ~= tStatus.STATUS_SUCCESS then return nStatus end
  
  -- ISOLATION LOGIC HERE
  -- if it's a component driver, verify we actually have a component address.
  if tDriverInfo.sDriverType == tDKStructs.DRIVER_TYPE_CMD then
     if not tDriverEnv or not tDriverEnv.address then
        syscall("kernel_log", "[DKMS] SECURITY: Blocked loading of CMD '" .. tDriverInfo.sDriverName .. "' without component address.")
        return tStatus.STATUS_INVALID_PARAMETER
     end
  end
  
  -- CMDs run at Ring 2 (Kernel Mode), same as KMDs, but with stricter init reqs.
  local nRing = (tDriverInfo.sDriverType == tDKStructs.DRIVER_TYPE_UMD) and 3 or 2
  local nPid, sSpawnErr = syscall("process_spawn", sDriverPath, nRing, tDriverEnv)
  if not nPid then return tStatus.STATUS_DRIVER_INIT_FAILED end
  
  local pDriverObject = tDKStructs.fNewDriverObject()
  pDriverObject.sDriverPath = sDriverPath
  pDriverObject.nDriverPid = nPid
  pDriverObject.tDriverInfo = tDriverInfo
  
  -- register the driver IMMEDIATELY so that it can call DkCreateDevice
  g_tDriverRegistry[sDriverPath] = pDriverObject
  
  syscall("signal_send", nPid, "driver_init", pDriverObject)
  
  while true do
      local bOk, nSenderPid, sSignalName, p1, p2, p3, p4, p5 = syscall("signal_pull")
      if bOk then
          if sSignalName == "driver_init_complete" and nSenderPid == nPid then
              local nEntryStatus = p1
              local pInitializedDriverObject = p2
              
              if nEntryStatus == tStatus.STATUS_SUCCESS and pInitializedDriverObject then
                  syscall("kernel_log", "[DKMS] Loaded '" .. tDriverInfo.sDriverName .. "' (PID " .. nPid .. ")")
                  g_tDriverRegistry[sDriverPath] = pInitializedDriverObject
                  -- === REGISTRY: register driver ===
                    local sDrvRegPath = "@VT\\DRV\\" .. tDriverInfo.sDriverName
                    syscall("reg_create_key", sDrvRegPath)
                    syscall("reg_set_value", sDrvRegPath, "Path",         sDriverPath,                     "STR")
                    syscall("reg_set_value", sDrvRegPath, "PID",          nPid,                            "NUM")
                    syscall("reg_set_value", sDrvRegPath, "Type",         tDriverInfo.sDriverType or "?",  "STR")
                    syscall("reg_set_value", sDrvRegPath, "LoadPriority", tDriverInfo.nLoadPriority or 0,  "NUM")
                    syscall("reg_set_value", sDrvRegPath, "Version",      tDriverInfo.sVersion or "N/A",   "STR")
                    syscall("reg_set_value", sDrvRegPath, "Status",       "loaded",                        "STR")
                    if tDriverInfo.sSupportedComponent then
                        syscall("reg_set_value", sDrvRegPath, "Component", tDriverInfo.sSupportedComponent, "STR")
                    end
                  return tStatus.STATUS_SUCCESS
              else
                  syscall("kernel_log", "[DKMS] Err: DriverEntry failed: " .. tostring(nEntryStatus))
                  g_tDriverRegistry[sDriverPath] = nil
                  return nEntryStatus or tStatus.STATUS_DRIVER_INIT_FAILED
              end
              
          elseif sSignalName == "syscall" then
              local tData = p1
              local fHandler = tSyscallHandlers[tData.name]
              if fHandler then
                   local ret1, ret2 = fHandler(tData.sender_pid, table.unpack(tData.args))
                   syscall("signal_send", tData.sender_pid, "syscall_return", ret1, ret2)
              end
              
          else
              table.insert(g_tSignalQueue, {nSenderPid, sSignalName, p1, p2, p3, p4, p5})
          end
      end
  end
end

-- Main Loop
while true do
  local nSenderPid, sSignalName, p1, p2, p3, p4
  
  -- CHECKING SIGNAL BUFFER!!!!!!
  if #g_tSignalQueue > 0 then
      local tSig = table.remove(g_tSignalQueue, 1)
      nSenderPid = tSig[1]
      sSignalName = tSig[2]
      p1 = tSig[3]
      p2 = tSig[4]
      p3 = tSig[5]
      p4 = tSig[6]
      p5 = tSig[7]
  else
      -- if buffer empty then wait
      local bOk
      bOk, nSenderPid, sSignalName, p1, p2, p3, p4, p5 = syscall("signal_pull")
      if not bOk then goto continue end
  end
  
  if sSignalName == "syscall" then
      local tData = p1
      local fHandler = tSyscallHandlers[tData.name]
      if fHandler then
        local ret1, ret2 = fHandler(tData.sender_pid, table.unpack(tData.args))
        syscall("signal_send", tData.sender_pid, "syscall_return", ret1, ret2)
      end
      
elseif sSignalName == "vfs_io_request" then 
      local pIrp = p1
      if pIrp and type(pIrp) == "table" then
          g_tPendingIrps[pIrp.nSenderPid] = pIrp
          local nDispatchStatus = oDispatcher.DispatchIrp(pIrp, g_tDeviceTree, g_tSymbolicLinks)
          
          if pIrp.nMajorFunction == 0x00 then -- IRP_MJ_CREATE
             local pDevice = g_tDeviceTree[pIrp.sDeviceName]
             if pDevice and pDevice.pDriverObject then
                pIrp.tIoStatus.vInformation = pDevice.pDriverObject.nDriverPid
             end
          end

          if nDispatchStatus ~= tStatus.STATUS_PENDING then
            tSyscallHandlers.dkms_complete_irp(0, pIrp, nDispatchStatus)
          end
      end
  elseif sSignalName == "dkms_list_devices_request" then
      local nOriginalRequester = p1
      
      local tList = {}
      -- g_tSymbolicLinks keys are like "/dev/tty", "/dev/gpu0"
      for sLinkPath, sDeviceName in pairs(g_tSymbolicLinks) do
          -- we strip the "/dev/" prefix to get just the filename
          local sName = string.match(sLinkPath, "^/dev/(.+)$")
          if sName then
             table.insert(tList, sName)
          end
      end
      
      -- send the list back to PM
      syscall("signal_send", nSenderPid, "dkms_list_devices_result", nOriginalRequester, tList)

  elseif sSignalName == "load_driver_for_component" then
      local sComponentType = p1
      local sComponentAddress = p2
      local sDriverPath = "/drivers/" .. sComponentType .. ".sys.lua"
      load_driver(sDriverPath, { address = sComponentAddress })

  elseif sSignalName == "load_driver_path" then
      local sPath = p1
      -- loading via path implies generic KMD/UMD. 
      -- if the driver at sPath is a CMD, load_driver will reject it because env is empty.
      load_driver(sPath, {})
      
elseif sSignalName == "load_driver_path_request" then
      local sPath = p1
      local nOriginalRequester = p2
      
      -- 1. inspect the driver first
      local tInfo, nInspectErr = inspect_driver(sPath)
      
      if not tInfo then
          -- file broken or missing
          syscall("signal_send", nSenderPid, "load_driver_result", nOriginalRequester, nInspectErr or tStatus.STATUS_UNSUCCESSFUL, "Unknown", -1)
          goto continue
      end
      
      -- 2. check for Auto-Discovery (CMD + sSupportedComponent)
      if tInfo.sDriverType == tDKStructs.DRIVER_TYPE_CMD and tInfo.sSupportedComponent then
          
          syscall("kernel_log", "[DKMS] Auto-discovery for type: " .. tInfo.sSupportedComponent)
          
          -- scan hardware
          local bOk, tList = syscall("raw_component_list", tInfo.sSupportedComponent)
          local nLoadedCount = 0
          local nLastStatus = tStatus.STATUS_NO_SUCH_DEVICE
          
          if bOk and tList then
              for sAddr, _ in pairs(tList) do
                  -- try to load for THIS specific address
                  -- we pass the address in the environment
                  local nSt = load_driver(sPath, { address = sAddr })
                  if nSt == tStatus.STATUS_SUCCESS then
                      nLoadedCount = nLoadedCount + 1
                  end
                  nLastStatus = nSt
              end
          end
          
          if nLoadedCount > 0 then
             local sMsg = string.format("Auto-loaded %d instances of %s", nLoadedCount, tInfo.sDriverName)
             -- return success (0) and our custom message as the "Name"
             syscall("signal_send", nSenderPid, "load_driver_result", nOriginalRequester, tStatus.STATUS_SUCCESS, sMsg, 0)
          else
             -- found nothing or failed all
             syscall("signal_send", nSenderPid, "load_driver_result", nOriginalRequester, nLastStatus, tInfo.sDriverName, -1)
          end
          
      else
          -- 3. standard Load (KMD, UMD, or manual CMD)
          -- pass empty env (CMD will fail here if not manual, which is correct security)
          local nStatus = load_driver(sPath, {})
          
          -- find the object to get PID
          local pObj = g_tDriverRegistry[sPath]
          local sName = tInfo.sDriverName
          local nPid = pObj and pObj.nDriverPid or -1
          
          syscall("signal_send", nSenderPid, "load_driver_result", nOriginalRequester, nStatus, sName, nPid)
      end
      
      ::continue::


    elseif sSignalName == "os_event" and p1 == "clipboard" then
        -- p2 = keyboard address, p3 = pasted text
        for _, pDriver in pairs(g_tDriverRegistry) do
            if pDriver.tDriverInfo.sDriverName == "AxisTTY" then
                syscall("signal_send", pDriver.nDriverPid, "hardware_interrupt", "clipboard", p3)
            end
        end

    elseif sSignalName == "os_event" and p1 == "key_down" then
      for _, pDriver in pairs(g_tDriverRegistry) do
          if pDriver.tDriverInfo.sDriverName == "AxisTTY" then
              syscall("signal_send", pDriver.nDriverPid, "hardware_interrupt", "key_down", p2, p3, p4)
          end
      end


    elseif sSignalName == "os_event" and p1 == "scroll" then
        -- p2=screenAddr, p3=x, p4=y, p5=direction (1=up, -1=down)
        for _, pDriver in pairs(g_tDriverRegistry) do
            if pDriver.tDriverInfo.sDriverName == "AxisTTY" then
                syscall("signal_send", pDriver.nDriverPid, "hardware_interrupt", "scroll", p5)
            end
        end
    end
  
  ::continue::
end
```


axis-os\src\kernel\system\driverdispatch.lua
```
--
-- /system/driverdispatch.lua
-- v2: Resolves VFS symlinks before device tree lookup.
--

local tStatus = require("errcheck")
local oDispatch = {}

function oDispatch.DispatchIrp(pIrp, g_tDeviceTree, g_tSymbolicLinks)
  local sName = pIrp.sDeviceName

  -- 1. Try direct device tree lookup (handles \\Device\\TTY0 etc.)
  local pDeviceObject = g_tDeviceTree[sName]

  -- 2. If not found, try resolving as a VFS symlink (/dev/net → \\Device\\Net0)
  if not pDeviceObject and g_tSymbolicLinks then
    local sResolved = g_tSymbolicLinks[sName]
    if sResolved then
      pDeviceObject = g_tDeviceTree[sResolved]
      if pDeviceObject then
        -- Update the IRP so downstream code sees the real device name
        pIrp.sDeviceName = sResolved
        sName = sResolved
      end
    end
  end

  if not pDeviceObject then
    syscall("kernel_log", "[DD] Error: No device object for '" .. sName ..
            "' (original: " .. pIrp.sDeviceName .. "')")
    return tStatus.STATUS_NO_SUCH_DEVICE
  end

  local pDriverObject = pDeviceObject.pDriverObject
  if not pDriverObject then
    syscall("kernel_log", "[DD] Error: Device '" .. sName .. "' has no driver!")
    return tStatus.STATUS_INVALID_DRIVER_OBJECT
  end

  local fHandler = pDriverObject.tDispatch[pIrp.nMajorFunction]

  if not fHandler then
    return tStatus.STATUS_NOT_IMPLEMENTED
  end

  syscall("signal_send", pDriverObject.nDriverPid, "irp_dispatch", pIrp, fHandler)

  return tStatus.STATUS_PENDING
end

return oDispatch
```


axis-os\src\kernel\system\driverhost.lua
```
--
-- /system/driverhost.lua
-- user mode driver host.
-- this is a ring 2.5 process that loads a single ring 3 driver (UMD),
-- supervises it, and acts as a secure proxy for any privileged operations
-- it needs to perform. it's a sandbox within a sandbox.
--

local krnlstatus = require("errcheck")

-- environment from pipeline manager
local sDriverPath = env.driver_path
local tComponentInfo = env.component_info
local nPipelineManagerPid = env.pm_pid
local nMyPid = syscall("process_get_pid")

if not sDriverPath or not nPipelineManagerPid then
  syscall("kernel_log", "[DriverHost] FATAL: Missing env variables.")
  return
end

syscall("kernel_log", "[DriverHost] Hosting UMD: " .. sDriverPath)

-- 1. Spawn the Ring 3 driver process
local nDriverPid, sSpawnErr = syscall("process_spawn", sDriverPath, 3, {
  component_info = tComponentInfo,
  pm_pid = nPipelineManagerPid,
  host_pid = nMyPid, -- CRITICAL: the UMD needs to know who its host is.
})

if not nDriverPid then
  syscall("kernel_log", "[DriverHost] Failed to spawn Ring 3 process for UMD: " .. sSpawnErr)
  syscall("signal_send", nPipelineManagerPid, "driver_load_result", sDriverPath, krnlstatus.STATUS_INSUFFICIENT_RESOURCES)
  return
end

syscall("kernel_log", "[DriverHost] UMD " .. sDriverPath .. " spawned as PID " .. nDriverPid)

-- 2. Create the Driver Object and call UMDriverEntry
local bCreateOk, nStatus, oDriverObject = syscall("driver_create_object", sDriverPath, nDriverPid)
if not (bCreateOk and nStatus == krnlstatus.STATUS_SUCCESS) then
  syscall("kernel_log", "[DriverHost] Kernel failed to create driver object.")
  syscall("signal_send", nPipelineManagerPid, "driver_load_result", sDriverPath, nStatus)
  return
end

-- tell the UMD process to start its initialization.
syscall("signal_send", nDriverPid, "umd_initialize", oDriverObject)

-- 3. Main loop: process RPC requests from our hosted UMD
while true do
  local bSyscallOk, bPullOk, nSender, sSignalName, tRequest = syscall("signal_pull")
  if bSyscallOk and bPullOk then
    if sSignalName == "umd_request" and nSender == nDriverPid then
      -- it's a request from our child. process it.
      local sType = tRequest.type
      local tPayload = tRequest.payload
      local nStatus, tData = krnlstatus.STATUS_NOT_IMPLEMENTED, nil

      if sType == "create_device" then
        bSyscallOk, nStatus, tData = syscall("driver_create_device", tPayload.driver_object, tPayload.device_type, tPayload.device_name)
      elseif sType == "create_symlink" then
        bSyscallOk, nStatus = syscall("driver_create_symlink", tPayload.link_name, tPayload.device_name)
      elseif sType == "complete_init" then
        -- this is a notification, not a request/reply
        syscall("signal_send", nPipelineManagerPid, "driver_load_result", sDriverPath, tPayload.status)
        if tPayload.status ~= krnlstatus.STATUS_SUCCESS then break end -- init failed, shut down
        goto continue -- skip reply
      elseif sType == "complete_request" then
        -- forward the IRP completion to the IO manager
        local oIrp = tPayload.irp
        syscall("signal_send", oIrp.nIoManagerPid, "irp_complete", {
          requester_pid = oIrp.nOriginalRequesterPid,
          request_id = oIrp.nOriginalRequestId,
          status = tPayload.status,
          info = tPayload.info,
        })
        nStatus = krnlstatus.STATUS_SUCCESS
      end
      
      -- send the reply back to the UMD
      syscall("signal_send", nDriverPid, "umd_reply", { status = nStatus, data = tData })

    elseif sSignalName == "umd_unload_request" then
      syscall("kernel_log", "[DriverHost] Received unload request for " .. nDriverPid)
      syscall("signal_send", nDriverPid, "umd_unload")
      syscall("driver_delete_object", oDriverObject)
      break
    end
    ::continue::
  end
end

syscall("kernel_log", "[DriverHost] Shutting down for driver: " .. sDriverPath)
```


axis-os\src\kernel\tmp\.pipe_1_20669.0
```
[33mnet[37m
[33mringlog[37m
[33mtty[37m

```


axis-os\src\kernel\tmp\.pipe_1_74644.0
```
[33mnet[37m
[33mringlog[37m
[33mtty[37m

```


axis-os\src\kernel\tmp\.pipe_1_92173.0
```

```


axis-os\src\kernel\tmp\.pipe_1_92368.0
```

```


axis-os\src\kernel\usr\commands\axfs_flash.lua
```
--
-- /usr/commands/axfs_flash.lua
-- Flash the AXFS bootloader to EEPROM
--
local fs = require("filesystem")
local tArgs = env.ARGS or {}

local C = {R="\27[37m", G="\27[32m", E="\27[31m", Y="\27[33m", C="\27[36m"}

local function getProxy(sType)
  local bOk, tList = syscall("raw_component_list", sType)
  if bOk and tList then
    for addr in pairs(tList) do
      local _, p = pcall(function() return raw_component.proxy(addr) end)
      if not p then _, p = pcall(function() return component.proxy(addr) end) end
      if p then return p, addr end
    end
  end
end

local oEep = getProxy("eeprom")
if not oEep then print(C.E .. "No EEPROM found!" .. C.R); return end

local sBoot = "/boot/axfs_boot.lua"
if tArgs[1] then sBoot = tArgs[1] end

local h = fs.open(sBoot, "r")
if not h then print(C.E .. "Cannot read " .. sBoot .. C.R); return end
local tC = {}
while true do
  local s = fs.read(h, math.huge); if not s then break end; tC[#tC+1] = s
end
fs.close(h)
local sCode = table.concat(tC)

if #sCode > 4096 then
  print(C.E .. "Boot code too large: " .. #sCode .. " bytes (max 4096)" .. C.R)
  return
end

print(C.C .. "Flashing AXFS bootloader..." .. C.R)
print("  Source: " .. sBoot)
print("  Size:   " .. #sCode .. " / 4096 bytes")
print("")

print(C.Y .. "  This will overwrite the EEPROM." .. C.R)
print(C.Y .. "  Type 'FLASH' to confirm:" .. C.R)
io.write("  > ")
local sConfirm = io.read()
if sConfirm ~= "FLASH" then print("  Aborted."); return end

oEep.set(sCode)
oEep.setLabel("AxisOS AXFS Boot")

print("")
print(C.G .. "  EEPROM flashed successfully!" .. C.R)
print("  Reboot to boot from AXFS.")
```


axis-os\src\kernel\usr\commands\axfs_install.lua
```
--
-- /usr/commands/axfs_install.lua
-- Install AxisOS onto an AXFS partition
--
-- Usage:
--   axfs_install <device> <partition#>
--
-- Copies the entire OS tree from the managed FS root
-- onto the specified AXFS partition, making it bootable.
--

local fs = require("filesystem")
local tArgs = env.ARGS or {}

local C = {R="\27[37m", G="\27[32m", Y="\27[33m", C="\27[36m", E="\27[31m", D="\27[90m"}

local sDev  = tArgs[1]
local sPart = tArgs[2]

if not sDev or not sPart then
  print(C.C .. "axfs_install" .. C.R .. " — Install AxisOS to AXFS partition")
  print("  Usage: axfs_install <device> <partition#>")
  print("")
  print("  Example:")
  print("    axfs init /dev/drive_xxx_0")
  print("    axfs addpart /dev/drive_xxx_0 SYSTEM 900")
  print("    axfs format /dev/drive_xxx_0 0 AxisOS")
  print("    axfs_install /dev/drive_xxx_0 0")
  print("")
  print("  Then flash /boot/axfs_boot.lua to EEPROM to boot from it.")
  return
end

-- Open device + partition
local hDev = fs.open(sDev, "r")
if not hDev then print(C.E .. "Cannot open " .. sDev .. C.R); return end

-- Get partition info
local AX = require("axfs_core")
local RDB = require("rdb")

local bI, tI = fs.deviceControl(hDev, "info", {})
if not bI or not tI then
  fs.close(hDev); print(C.E .. "Device info failed" .. C.R); return
end

-- We need to use the raw approach via AXFS
-- Read RDB through device control
local function readSec(n)
  local bOk, sData = fs.deviceControl(hDev, "read_sector", {n + 1})
  return bOk and sData or nil
end

local function writeSec(n, sData)
  return fs.deviceControl(hDev, "write_sector", {n + 1, sData})
end

-- Parse RDB
local s0 = readSec(0)
if not s0 or s0:sub(1,4) ~= "AXRD" then
  fs.close(hDev); print(C.E .. "No RDB on device" .. C.R); return
end

local nP = tonumber(sPart)
local ps = readSec(nP + 1)
if not ps or ps:sub(1,4) ~= "AXPT" then
  fs.close(hDev); print(C.E .. "Partition " .. sPart .. " not found" .. C.R); return
end

local B = require("bpack")
local pOff = B.r32(ps, 30)
local pCnt = B.r32(ps, 34)

print(C.C .. "Installing AxisOS to partition " .. sPart .. C.R)
print(C.D .. "  Offset: sector " .. pOff .. ", Size: " .. pCnt .. " sectors" .. C.R)

-- Create a tDisk wrapper for AXFS
local tDisk = {
  sectorSize = tI.sectorSize,
  sectorCount = pCnt,
  readSector = function(n) return readSec(pOff + n) end,
  writeSector = function(n, d)
    d = d or ""
    if #d < tI.sectorSize then d = d .. string.rep("\0", tI.sectorSize - #d) end
    return writeSec(pOff + n, d:sub(1, tI.sectorSize))
  end,
}

-- Mount AXFS
local vol, vErr = AX.mount(tDisk)
if not vol then
  fs.close(hDev); print(C.E .. "Mount failed: " .. tostring(vErr) .. C.R); return
end

-- Recursive copy from managed FS to AXFS
local nFiles = 0
local nDirs = 0
local nBytes = 0
local nErrors = 0

-- Directories to skip (runtime-generated, not needed)
local tSkip = {
  ["/tmp"] = true,
  ["/log"] = true,
  ["/vbl"] = true,
}

local function copyTree(sSrcDir, sDstDir)
  local tList = fs.list(sSrcDir)
  if not tList then return end

  for _, sName in ipairs(tList) do
    local bIsDir = sName:sub(-1) == "/"
    local sClean = bIsDir and sName:sub(1, -2) or sName
    local sSrcPath = sSrcDir .. (sSrcDir == "/" and "" or "/") .. sClean
    local sDstPath = sDstDir .. (sDstDir == "/" and "" or "/") .. sClean

    sSrcPath = sSrcPath:gsub("//", "/")
    sDstPath = sDstPath:gsub("//", "/")

    if tSkip[sSrcPath] then
      io.write(C.D .. "  SKIP  " .. sSrcPath .. C.R .. "\n")
    elseif bIsDir then
      io.write(C.Y .. "  DIR   " .. sDstPath .. C.R .. "\n")
      vol:mkdir(sDstPath)
      nDirs = nDirs + 1
      copyTree(sSrcPath, sDstPath)
    else
      -- Read file from managed FS
      local hSrc = fs.open(sSrcPath, "r")
      if hSrc then
        local tChunks = {}
        while true do
          local sChunk = fs.read(hSrc, math.huge)
          if not sChunk then break end
          tChunks[#tChunks + 1] = sChunk
        end
        fs.close(hSrc)
        local sData = table.concat(tChunks)

        -- Strip CR from CRLF
        sData = sData:gsub("\r\n", "\n")

        local bOk, sErr = vol:writeFile(sDstPath, sData)
        if bOk then
          nFiles = nFiles + 1
          nBytes = nBytes + #sData
          io.write(C.G .. "  FILE  " .. C.R .. sDstPath ..
                   C.D .. " (" .. #sData .. "B)" .. C.R .. "\n")
        else
          nErrors = nErrors + 1
          io.write(C.E .. "  FAIL  " .. sDstPath .. ": " .. tostring(sErr) .. C.R .. "\n")
        end
      else
        nErrors = nErrors + 1
        io.write(C.E .. "  FAIL  Cannot read " .. sSrcPath .. C.R .. "\n")
      end
    end
  end
end

print("")
print(C.C .. "Copying filesystem tree..." .. C.R)
print("")

-- Create essential directories first
for _, sDir in ipairs({"/bin", "/etc", "/lib", "/drivers", "/system",
    "/usr", "/usr/commands", "/home", "/tmp", "/boot",
    "/system/lib", "/system/lib/dk", "/lib/vi",
    "/sys", "/sys/security"}) do
  vol:mkdir(sDir)
end

-- Copy everything
copyTree("/", "/")

-- Flush
vol:flush()
fs.close(hDev)

-- Summary
print("")
print(C.C .. string.rep("=", 50) .. C.R)
print(C.G .. "  Installation complete!" .. C.R)
print(string.format("  %s%d%s files, %s%d%s directories, %s%s%s bytes",
  C.G, nFiles, C.R, C.Y, nDirs, C.R,
  C.C, tostring(nBytes), C.R))
if nErrors > 0 then
  print(C.E .. "  " .. nErrors .. " error(s) — check output above" .. C.R)
end
print(C.C .. string.rep("=", 50) .. C.R)
print("")
print("  Next steps:")
print("  1. Flash the AXFS bootloader to EEPROM:")
print("     " .. C.Y .. "provision" .. C.R .. " (or manually flash /boot/axfs_boot.lua)")
print("  2. Reboot — the system will boot from AXFS")
print("")
```


axis-os\src\kernel\usr\commands\axfs.lua
```
--
-- /usr/commands/axfs.lua
-- AXFS multi-tool: partition, format, mount, read/write
--
-- Usage:
--   axfs scan                              List block devices
--   axfs init <dev>                        Write empty RDB
--   axfs parts <dev>                       Show partitions
--   axfs addpart <dev> <name> <sectors>    Create partition
--   axfs rmpart <dev> <index>              Remove partition
--   axfs format <dev> <part#> [label]      Format with AXFS
--   axfs info <dev> <part#>                FS info
--   axfs ls <dev> <part#> [path]           List directory
--   axfs cat <dev> <part#> <path>          Read file
--   axfs write <dev> <part#> <path> <data> Write file
--   axfs mkdir <dev> <part#> <path>        Create directory
--   axfs rm <dev> <part#> <path>           Remove file/dir
--   axfs stat <dev> <part#> <path>         Inode info
--   axfs import <dev> <part#> <src> <dst>  Managed FS → AXFS
--   axfs export <dev> <part#> <src> <dst>  AXFS → Managed FS
--

local fs = require("filesystem")
local AX = require("axfs_core")
local RDB = require("rdb")
local B = require("bpack")
local args = env.ARGS or {}

local C = {R="\27[37m",G="\27[32m",Y="\27[33m",C="\27[36m",E="\27[31m",D="\27[90m"}

local function die(s) print(C.E .. "Error: " .. C.R .. s); return end
local function ok(s)  print(C.G .. "[OK] " .. C.R .. s) end

-- Open block device and return tDisk wrapper
local function openDev(sPath)
  local h = fs.open(sPath, "r")
  if not h then return nil, "Cannot open " .. sPath end
  local tD, sE = AX.wrapDevice(h, fs, 0)
  if not tD then fs.close(h); return nil, sE end
  tD._handle = h
  tD._close = function() fs.close(h) end
  return tD
end

-- Open device + partition → tDisk scoped to partition
local function openPart(sPath, nPart)
  local tD, sE = openDev(sPath)
  if not tD then return nil, nil, sE end
  local tRdb, sRE = RDB.read(tD)
  if not tRdb then tD._close(); return nil, nil, sRE end
  nPart = tonumber(nPart)
  if not nPart or not tRdb.partitions[nPart+1] then
    tD._close(); return nil, nil, "Partition " .. tostring(nPart) .. " not found"
  end
  local p = tRdb.partitions[nPart+1]
  -- re-open wrapped to partition boundaries
  local h2 = fs.open(sPath, "r")
  if not h2 then tD._close(); return nil, nil, "Reopen failed" end
  local tPD, sE2 = AX.wrapDevice(h2, fs, p.startSector, p.sizeInSectors)
  if not tPD then fs.close(h2); tD._close(); return nil, nil, sE2 end
  tPD._handle = h2
  tPD._close = function() fs.close(h2); tD._close() end
  return tPD, p
end

local function fmtSz(n)
  if n >= 1048576 then return string.format("%.1f MB", n/1048576) end
  if n >= 1024 then return string.format("%.1f KB", n/1024) end
  return n .. " B"
end

-- =============================================
-- COMMANDS
-- =============================================

local cmd = args[1]

if not cmd or cmd == "help" or cmd == "-h" then
  print(C.C .. "axfs" .. C.R .. " — AxisOS Filesystem Tool")
  print("  axfs scan                         List block devices")
  print("  axfs init <dev>                   Initialize RDB")
  print("  axfs parts <dev>                  Show partitions")
  print("  axfs addpart <dev> <name> <sects> Add partition")
  print("  axfs format <dev> <#> [label]     Format AXFS")
  print("  axfs info <dev> <#>               Filesystem info")
  print("  axfs ls <dev> <#> [path]          List directory")
  print("  axfs cat <dev> <#> <path>         Read file")
  print("  axfs write <dev> <#> <path> <str> Write file")
  print("  axfs mkdir <dev> <#> <path>       Create directory")
  print("  axfs rm <dev> <#> <path>          Remove file/dir")
  print("  axfs stat <dev> <#> <path>        Inode info")
  print("  axfs import <dev> <#> <src> <dst> Copy in from VFS")
  print("  axfs export <dev> <#> <src> <dst> Copy out to VFS")
  return

elseif cmd == "scan" then
  local tDev = fs.list("/dev")
  if not tDev then die("Cannot list /dev"); return end
  local n = 0
  for _, sName in ipairs(tDev) do
    local sC = sName:gsub("/$", "")
    if sC:find("drive", 1, true) then
      local h = fs.open("/dev/" .. sC, "r")
      if h then
        local bI, tI = fs.deviceControl(h, "info", {})
        fs.close(h)
        if bI and tI then
          n = n + 1
          print(string.format("  %s/dev/%-20s%s %s  %d sectors  %d-byte",
            C.Y, sC, C.R, fmtSz(tI.capacity), tI.sectorCount, tI.sectorSize))
        end
      end
    end
  end
  if n == 0 then print(C.D .. "  No block devices found. Install an unmanaged drive and: insmod blkdev" .. C.R) end

elseif cmd == "init" then
  local sDev = args[2]; if not sDev then die("Usage: axfs init <device>"); return end
  local tD, sE = openDev(sDev)
  if not tD then die(sE); return end
  local tRdb = RDB.create("AxisDisk", tD.sectorSize, tD.sectorCount)
  RDB.write(tD, tRdb)
  tD._close()
  ok("RDB initialized on " .. sDev .. " (" .. tD.sectorCount .. " sectors)")

elseif cmd == "parts" then
  local sDev = args[2]; if not sDev then die("Usage: axfs parts <device>"); return end
  local tD, sE = openDev(sDev)
  if not tD then die(sE); return end
  local tRdb, sRE = RDB.read(tD)
  tD._close()
  if not tRdb then die(sRE); return end
  print(C.C .. "Disk: " .. C.R .. tRdb.label .. "  " .. fmtSz(tRdb.totalSectors * tRdb.sectorSize))
  if #tRdb.partitions == 0 then
    print(C.D .. "  No partitions. Use: axfs addpart" .. C.R); return
  end
  print(string.format("  %s%-3s %-12s %-6s %8s %8s %s%s",
    C.D, "#", "NAME", "TYPE", "START", "SIZE", "FLAGS", C.R))
  for i, p in ipairs(tRdb.partitions) do
    print(string.format("  %-3d %s%-12s%s %-6s %8d %8s %s",
      i-1, C.Y, p.name, C.R, p.fsType, p.startSector,
      fmtSz(p.sizeInSectors * tRdb.sectorSize),
      (p.flags % 2 == 1) and "boot" or ""))
  end

elseif cmd == "addpart" then
  local sDev, sName, sSects = args[2], args[3], args[4]
  if not sDev or not sName or not sSects then
    die("Usage: axfs addpart <dev> <name> <sectors>"); return
  end
  local nSects = tonumber(sSects); if not nSects then die("Bad sector count"); return end
  local tD, sE = openDev(sDev); if not tD then die(sE); return end
  local tRdb, sRE = RDB.read(tD)
  if not tRdb then tD._close(); die(sRE); return end
  if #tRdb.partitions >= RDB.MAX_PARTS then tD._close(); die("Max partitions reached"); return end
  local nStart = RDB.nextFree(tRdb)
  if nStart + nSects > tRdb.totalSectors then
    tD._close(); die("Not enough space (max " .. (tRdb.totalSectors - nStart) .. " sectors free)"); return
  end
  table.insert(tRdb.partitions, {name=sName, fsType="axfs", startSector=nStart, sizeInSectors=nSects, flags=0, bootPriority=0})
  RDB.write(tD, tRdb)
  tD._close()
  ok(string.format("Partition '%s' created: sectors %d-%d (%s)",
    sName, nStart, nStart+nSects-1, fmtSz(nSects * tRdb.sectorSize)))

elseif cmd == "rmpart" then
  local sDev, sIdx = args[2], args[3]
  if not sDev or not sIdx then die("Usage: axfs rmpart <dev> <index>"); return end
  local nIdx = tonumber(sIdx); if not nIdx then die("Bad index"); return end
  local tD, sE = openDev(sDev); if not tD then die(sE); return end
  local tRdb, sRE = RDB.read(tD)
  if not tRdb then tD._close(); die(sRE); return end
  if not tRdb.partitions[nIdx+1] then tD._close(); die("No such partition"); return end
  table.remove(tRdb.partitions, nIdx+1)
  RDB.write(tD, tRdb); tD._close()
  ok("Partition " .. nIdx .. " removed")

elseif cmd == "format" then
  local sDev, sPart, sLabel = args[2], args[3], args[4]
  if not sDev or not sPart then die("Usage: axfs format <dev> <part#> [label]"); return end
  local tPD, tPart, sE = openPart(sDev, sPart)
  if not tPD then die(sE); return end
  local bOk, sFE = AX.format(tPD, sLabel or tPart.name)
  tPD._close()
  if bOk then ok("Formatted partition " .. sPart .. " (" .. fmtSz(tPD.sectorCount * tPD.sectorSize) .. ")")
  else die(sFE) end

elseif cmd == "info" then
  local sDev, sPart = args[2], args[3]
  if not sDev or not sPart then die("Usage: axfs info <dev> <part#>"); return end
  local tPD, _, sE = openPart(sDev, sPart)
  if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD)
  if not vol then tPD._close(); die(sVE); return end
  local t = vol:info(); vol:unmount(); tPD._close()
  print(C.C .. "AXFS Volume: " .. C.R .. t.label)
  print("  Sector size:   " .. t.sectorSize)
  print("  Total sectors: " .. t.totalSectors)
  print("  Max inodes:    " .. t.maxInodes .. " (free: " .. t.freeInodes .. ")")
  print("  Data blocks:   " .. t.maxBlocks .. " (free: " .. t.freeBlocks .. ")")
  print("  Used:          " .. fmtSz(t.usedKB*1024) .. " / " .. fmtSz(t.totalKB*1024))

elseif cmd == "ls" then
  local sDev, sPart, sPath = args[2], args[3], args[4] or "/"
  if not sDev or not sPart then die("Usage: axfs ls <dev> <part#> [path]"); return end
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local ents, sLE = vol:listDir(sPath); vol:unmount(); tPD._close()
  if not ents then die(sLE); return end
  for _, e in ipairs(ents) do
    local sT = ({[1]="f",[2]="d",[3]="l"})[e.iType] or "?"
    local sC = e.iType == 2 and C.C or C.R
    print(string.format("  %s %5d  i%-3d  %s%s%s",
      sT, e.size, e.inode, sC, e.name, C.R))
  end
  if #ents == 0 then print(C.D .. "  (empty)" .. C.R) end

elseif cmd == "cat" then
  local sDev, sPart, sPath = args[2], args[3], args[4]
  if not sDev or not sPart or not sPath then die("Usage: axfs cat <dev> <part#> <path>"); return end
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local data, sFE = vol:readFile(sPath); vol:unmount(); tPD._close()
  if data then io.write(data) else die(sFE) end

elseif cmd == "write" then
  local sDev, sPart, sPath, sData = args[2], args[3], args[4], args[5]
  if not sDev or not sPart or not sPath or not sData then
    die("Usage: axfs write <dev> <part#> <path> <data>"); return
  end
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local bOk, sFE = vol:writeFile(sPath, sData); vol:unmount(); tPD._close()
  if bOk then ok("Written " .. #sData .. "B to " .. sPath) else die(sFE) end

elseif cmd == "mkdir" then
  local sDev, sPart, sPath = args[2], args[3], args[4]
  if not sDev or not sPart or not sPath then die("Usage: axfs mkdir <dev> <part#> <path>"); return end
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local bOk, sFE = vol:mkdir(sPath); vol:unmount(); tPD._close()
  if bOk then ok("Created " .. sPath) else die(sFE) end

elseif cmd == "rm" then
  local sDev, sPart, sPath = args[2], args[3], args[4]
  if not sDev or not sPart or not sPath then die("Usage: axfs rm <dev> <part#> <path>"); return end
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local bOk, sFE = vol:removeFile(sPath)
  if not bOk then bOk, sFE = vol:rmdir(sPath) end
  vol:unmount(); tPD._close()
  if bOk then ok("Removed " .. sPath) else die(sFE) end

elseif cmd == "stat" then
  local sDev, sPart, sPath = args[2], args[3], args[4]
  if not sDev or not sPart or not sPath then die("Usage: axfs stat <dev> <part#> <path>"); return end
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local t, sFE = vol:stat(sPath); vol:unmount(); tPD._close()
  if not t then die(sFE); return end
  local tN = {[0]="free",[1]="file",[2]="dir",[3]="symlink"}
  print(C.C .. "Inode " .. t.inode .. C.R)
  print("  Type:     " .. (tN[t.iType] or "?"))
  print("  Mode:     " .. string.format("%03o", t.mode))
  print("  Size:     " .. t.size .. " bytes")
  print("  Links:    " .. t.links)
  print("  Blocks:   " .. t.nBlk)
  print("  UID/GID:  " .. t.uid .. "/" .. t.gid)
  print("  Created:  " .. t.ctime)
  print("  Modified: " .. t.mtime)

elseif cmd == "import" then
  local sDev, sPart, sSrc, sDst = args[2], args[3], args[4], args[5]
  if not sDev or not sPart or not sSrc or not sDst then
    die("Usage: axfs import <dev> <part#> <vfs_src> <axfs_dst>"); return
  end
  -- Read from managed FS
  local hSrc = fs.open(sSrc, "r")
  if not hSrc then die("Cannot open " .. sSrc); return end
  local tChunks = {}
  while true do
    local s = fs.read(hSrc, math.huge); if not s then break end
    tChunks[#tChunks+1] = s
  end
  fs.close(hSrc)
  local sData = table.concat(tChunks)
  -- Write to AXFS
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local bOk, sFE = vol:writeFile(sDst, sData); vol:unmount(); tPD._close()
  if bOk then ok("Imported " .. fmtSz(#sData) .. " from " .. sSrc .. " → " .. sDst)
  else die(sFE) end

elseif cmd == "export" then
  local sDev, sPart, sSrc, sDst = args[2], args[3], args[4], args[5]
  if not sDev or not sPart or not sSrc or not sDst then
    die("Usage: axfs export <dev> <part#> <axfs_src> <vfs_dst>"); return
  end
  local tPD, _, sE = openPart(sDev, sPart); if not tPD then die(sE); return end
  local vol, sVE = AX.mount(tPD); if not vol then tPD._close(); die(sVE); return end
  local sData, sFE = vol:readFile(sSrc); vol:unmount(); tPD._close()
  if not sData then die(sFE); return end
  local hDst = fs.open(sDst, "w")
  if not hDst then die("Cannot write " .. sDst); return end
  fs.write(hDst, sData); fs.close(hDst)
  ok("Exported " .. fmtSz(#sData) .. " from " .. sSrc .. " → " .. sDst)

else
  die("Unknown command: " .. cmd .. "  (try: axfs help)")
end
```


axis-os\src\kernel\usr\commands\cat.lua
```
-- cat.lua (fixed argument parsing)
local fs = require("filesystem")
local tArgs = env.ARGS

if not tArgs or #tArgs == 0 then
  print("Usage: cat <filename> [...]")
  return
end

for _, sArg in ipairs(tArgs) do
  if sArg:sub(1, 1) == "-" then
    print("cat: unknown option -- '" .. sArg:sub(2) .. "'")
    return
  end

  local sPath = sArg
  if sPath:sub(1,1) ~= "/" then
    sPath = (env.PWD or "/") .. (env.PWD == "/" and "" or "/") .. sPath
  end
  sPath = sPath:gsub("//", "/")

  local hFile = fs.open(sPath, "r")
  if hFile then
    local sData = fs.read(hFile, math.huge)
    if sData then io.write(sData) end
    fs.close(hFile)
  else
    print("cat: " .. sPath .. ": No such file or directory")
  end
end
```


axis-os\src\kernel\usr\commands\chmod.lua
```
-- chmod - change file mode bits
local fs = require("filesystem")
local tArgs = env.ARGS

if not tArgs or #tArgs < 2 then
  print("Usage: chmod <mode> <file>")
  print("Example: chmod 755 /bin/sh.lua")
  return
end

local sModeStr = tArgs[1]
local sPath = tArgs[2]

-- resolve path
if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. sPath end
sPath = sPath:gsub("//", "/")

-- convert "755" (string) to 755 (number)
-- we treat it as decimal here because our DB stores it as decimal representation of octal
-- (it's weird but easier than bitwise math in lua 5.2 without libs)
local nMode = tonumber(sModeStr)

if not nMode then
  print("chmod: invalid mode: " .. sModeStr)
  return
end

local bOk, sErr = fs.chmod(sPath, nMode)

if bOk then
  -- silent success is the unix way
else
  print("chmod: " .. tostring(sErr))
end
```


axis-os\src\kernel\usr\commands\clear.lua
```
-- clear.lua
io.write("\f")
```


axis-os\src\kernel\usr\commands\cp.lua
```
-- cp - copy files
local fs = require("filesystem")
local tArgs = env.ARGS or {}
if #tArgs < 2 then print("Usage: cp <source> <dest>"); return end

local sSrc, sDst = tArgs[1], tArgs[2]
if sSrc:sub(1,1) ~= "/" then sSrc = (env.PWD or "/") .. "/" .. sSrc end
if sDst:sub(1,1) ~= "/" then sDst = (env.PWD or "/") .. "/" .. sDst end
sSrc = sSrc:gsub("//", "/")
sDst = sDst:gsub("//", "/")

local hIn = fs.open(sSrc, "r")
if not hIn then print("cp: " .. sSrc .. ": No such file"); return end
local sData = fs.read(hIn, math.huge) or ""
fs.close(hIn)

local hOut = fs.open(sDst, "w")
if not hOut then print("cp: cannot create " .. sDst); return end
fs.write(hOut, sData)
fs.close(hOut)
```


axis-os\src\kernel\usr\commands\curl.lua
```
--
-- /usr/commands/curl.lua
-- HTTP client tool
--
-- Usage:
--   curl <url>                     GET request
--   curl -X POST -d 'data' <url>  POST with body
--   curl -H "Key: Val" <url>      Custom header
--   curl -v <url>                 Verbose (show headers)
--   curl -o file.txt <url>        Save to file
--   curl -s <url>                 Silent (body only)
--   curl -I <url>                 Headers only (HEAD)
--

local http = require("http")
local fs   = require("filesystem")
local tArgs = env.ARGS or {}

local C = {
  R = "\27[37m", GRN = "\27[32m", RED = "\27[31m",
  YLW = "\27[33m", CYN = "\27[36m", GRY = "\27[90m", MAG = "\27[35m",
}

-- parse args
local sUrl      = nil
local sMethod   = "GET"
local sBody     = nil
local tHeaders  = {}
local sOutFile  = nil
local bVerbose  = false
local bSilent   = false
local bHeadOnly = false

local i = 1
while i <= #tArgs do
  local a = tArgs[i]
  if a == "-X" then
    i = i + 1; sMethod = (tArgs[i] or "GET"):upper()
  elseif a == "-d" or a == "--data" then
    i = i + 1; sBody = tArgs[i]
    if sMethod == "GET" then sMethod = "POST" end
  elseif a == "-H" or a == "--header" then
    i = i + 1
    local sHdr = tArgs[i]
    if sHdr then
      local nColon = sHdr:find(":")
      if nColon then
        local k = sHdr:sub(1, nColon - 1)
        local v = sHdr:sub(nColon + 1):match("^%s*(.-)%s*$")
        tHeaders[k] = v
      end
    end
  elseif a == "-o" then
    i = i + 1; sOutFile = tArgs[i]
  elseif a == "-v" or a == "--verbose" then
    bVerbose = true
  elseif a == "-s" or a == "--silent" then
    bSilent = true
  elseif a == "-I" or a == "--head" then
    bHeadOnly = true; sMethod = "HEAD"
  elseif a == "-h" or a == "--help" then
    print(C.CYN .. "curl" .. C.R .. " - HTTP client")
    print("Usage: curl [opts] <url>")
    print("  -X METHOD   HTTP method (GET, POST, PUT)")
    print("  -d DATA     Request body")
    print("  -H HDR      Header (\"Key: Value\")")
    print("  -o FILE     Save body to file")
    print("  -v          Verbose (show request/response headers)")
    print("  -s          Silent (body only, no status)")
    print("  -I          HEAD request (headers only)")
    return
  elseif a:sub(1, 1) ~= "-" then
    sUrl = a
  end
  i = i + 1
end

if not sUrl then
  print("Usage: curl <url>")
  return
end

-- resolve output path
if sOutFile and sOutFile:sub(1, 1) ~= "/" then
  sOutFile = (env.PWD or "/") .. "/" .. sOutFile
  sOutFile = sOutFile:gsub("//", "/")
end

-- verbose: show request
if bVerbose then
  print(C.CYN .. "> " .. C.R .. sMethod .. " " .. sUrl)
  for k, v in pairs(tHeaders) do
    print(C.CYN .. "> " .. C.R .. k .. ": " .. v)
  end
  if sBody then print(C.CYN .. "> " .. C.GRY .. "[body: " .. #sBody .. " bytes]" .. C.R) end
  print("")
end

-- make request
local tHdrs = next(tHeaders) and tHeaders or nil
local stream, sErr = http.open(sUrl, sMethod, sBody, tHdrs)

if not stream then
  if not bSilent then
    print(C.RED .. "Error: " .. C.R .. tostring(sErr))
  end
  return
end

-- show response headers
if not bSilent then
  local sCodeColor = C.GRN
  if stream.code >= 400 then sCodeColor = C.RED
  elseif stream.code >= 300 then sCodeColor = C.YLW end

  if bVerbose or bHeadOnly then
    print(string.format("%s< %sHTTP %d %s%s  (%d ms)",
          C.MAG, sCodeColor, stream.code, stream.message, C.R, stream.connectMs))
    if stream.headers then
      for k, v in pairs(stream.headers) do
        print(C.MAG .. "< " .. C.R .. tostring(k) .. ": " .. tostring(v))
      end
    end
    print("")
  else
    io.write(string.format("%sHTTP %d%s (%d ms) ",
             sCodeColor, stream.code, C.R, stream.connectMs))
  end
end

-- read body
if not bHeadOnly then
  local hOut = nil
  if sOutFile then
    hOut = fs.open(sOutFile, "w")
    if not hOut then
      print(C.RED .. "Cannot open: " .. C.R .. sOutFile)
      stream:close()
      return
    end
  end

  local nTotal = 0
  while true do
    local sChunk = stream:read(2048)
    if not sChunk then break end
    nTotal = nTotal + #sChunk
    if hOut then
      fs.write(hOut, sChunk)
      if not bSilent then
        io.write(string.format("\r%s%d bytes%s downloaded",
                 C.GRY, nTotal, C.R))
      end
    else
      io.write(sChunk)
    end
  end

  if hOut then
    fs.close(hOut)
    if not bSilent then
      print(string.format("\n%sSaved to %s%s (%d bytes)",
            C.GRN, sOutFile, C.R, nTotal))
    end
  elseif not bSilent and not bVerbose then
    -- newline after body if it didn't end with one
    print("")
  end
end

stream:close()
```


axis-os\src\kernel\usr\commands\echo.lua
```
-- echo - display a line of text
local tArgs = env.ARGS or {}
print(table.concat(tArgs, " "))
```


axis-os\src\kernel\usr\commands\free.lua
```
-- free - show memory usage
local nTotal = computer.totalMemory()
local nFree = computer.freeMemory()
local nUsed = nTotal - nFree
local function fmt(n) return string.format("%.1f KB", n / 1024) end

print(string.format("%-8s %10s %10s %10s", "", "total", "used", "free"))
print(string.format("%-8s %10s %10s %10s", "Mem:", fmt(nTotal), fmt(nUsed), fmt(nFree)))
print(string.format("%-8s %s", "Usage:", string.format("%.1f%%", (nUsed / nTotal) * 100)))
```


axis-os\src\kernel\usr\commands\grep.lua
```
-- grep - search for text in files
local fs = require("filesystem")
local tArgs = env.ARGS or {}
if #tArgs < 2 then print("Usage: grep <text> <file> [...]"); return end

local sNeedle = tArgs[1]
local C_R = "\27[37m"
local C_M = "\27[31m"
local bMulti = (#tArgs > 2)

for i = 2, #tArgs do
  local sPath = tArgs[i]
  if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. "/" .. sPath end
  sPath = sPath:gsub("//", "/")

  local h = fs.open(sPath, "r")
  if not h then print("grep: " .. tArgs[i] .. ": No such file"); goto next end
  local sData = fs.read(h, math.huge) or ""
  fs.close(h)

  for sLine in (sData .. "\n"):gmatch("([^\n]*)\n") do
    if sLine:find(sNeedle, 1, true) then
      local sPrefix = bMulti and (C_M .. tArgs[i] .. C_R .. ":") or ""
      -- highlight matches
      local sOut, nPos = "", 1
      while nPos <= #sLine do
        local nS, nE = sLine:find(sNeedle, nPos, true)
        if not nS then sOut = sOut .. sLine:sub(nPos); break end
        sOut = sOut .. sLine:sub(nPos, nS - 1) .. C_M .. sLine:sub(nS, nE) .. C_R
        nPos = nE + 1
      end
      print(sPrefix .. sOut)
    end
  end
  ::next::
end
```


axis-os\src\kernel\usr\commands\head.lua
```
-- head - show first N lines of a file
local fs = require("filesystem")
local tArgs = env.ARGS or {}
local nLines = 10
local sPath = nil
for _, a in ipairs(tArgs) do
  local n = a:match("^%-n(%d+)$") or a:match("^%-(%d+)$")
  if n then nLines = tonumber(n)
  elseif a:sub(1,1) ~= "-" then sPath = a end
end
if not sPath then print("Usage: head [-n N] <file>"); return end
if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. "/" .. sPath end
sPath = sPath:gsub("//", "/")

local h = fs.open(sPath, "r")
if not h then print("head: " .. sPath .. ": No such file"); return end
local sData = fs.read(h, math.huge) or ""
fs.close(h)

local nCount = 0
for sLine in (sData .. "\n"):gmatch("([^\n]*)\n") do
  nCount = nCount + 1
  if nCount > nLines then break end
  print(sLine)
end
```


axis-os\src\kernel\usr\commands\id.lua
```
-- /usr/commands/id.lua
print(string.format("uid=%s(%s) ring=%s",
    tostring(env.UID or "?"),
    tostring(env.USER or "?"),
    tostring(syscall("process_get_ring"))))
```


axis-os\src\kernel\usr\commands\insmod.lua
```
--
-- /usr/commands/insmod.lua
-- AxisOS Driver Insertion Tool v2
-- "insmod - because hot-plugging drivers at runtime is totally safe"
--
-- Usage:
--   insmod <path>              Load a driver from explicit path
--   insmod -s <component>      Scan and load driver for component type
--   insmod -v <path>           Verbose mode (extra debug output)
--   insmod -i <path>           Info-only mode (inspect without loading)
--

local fs = require("filesystem")
local sys = require("syscall")

local tArgs = env.ARGS or {}

-- =============================================
-- OUTPUT HELPERS
-- =============================================

local C_RESET  = "\27[37m"
local C_RED    = "\27[31m"
local C_GREEN  = "\27[32m"
local C_YELLOW = "\27[33m"
local C_BLUE   = "\27[34m"
local C_CYAN   = "\27[36m"
local C_GRAY   = "\27[90m"

local bVerbose = false

local function log_info(sMsg)
  print(C_BLUE .. ":: " .. C_RESET .. sMsg)
end

local function log_ok(sMsg)
  print(C_GREEN .. "[  OK  ] " .. C_RESET .. sMsg)
end

local function log_fail(sMsg)
  print(C_RED .. "[ FAIL ] " .. C_RESET .. sMsg)
end

local function log_warn(sMsg)
  print(C_YELLOW .. "[ WARN ] " .. C_RESET .. sMsg)
end

local function log_verbose(sMsg)
  if bVerbose then
    print(C_GRAY .. "  [dbg] " .. sMsg .. C_RESET)
  end
end

local function log_step(nStep, nTotal, sMsg)
  local sPrefix = string.format(C_CYAN .. "[%d/%d]" .. C_RESET, nStep, nTotal)
  print(sPrefix .. " " .. sMsg)
end

-- =============================================
-- USAGE
-- =============================================

local function print_usage()
  print(C_CYAN .. "insmod" .. C_RESET .. " - AxisOS Driver Insertion Tool v2")
  print("")
  print("Usage:")
  print("  insmod <path>            Load driver from path")
  print("  insmod -s <component>    Auto-scan and load for component type")
  print("  insmod -v <path>         Verbose mode")
  print("  insmod -i <path>         Inspect driver without loading")
  print("")
  print("Examples:")
  print("  insmod /drivers/iter.sys.lua")
  print("  insmod -s iter")
  print("  insmod -v /drivers/ringfs.sys.lua")
  print("  insmod -i /drivers/gpu.sys.lua")
end

-- =============================================
-- PATH RESOLUTION
-- =============================================

local function resolve_path(sInput)
  -- If it's already an absolute path, use it
  if sInput:sub(1, 1) == "/" then
    return sInput
  end

  -- Try as relative path
  local sRelative = (env.PWD or "/") .. "/" .. sInput
  sRelative = sRelative:gsub("//", "/")

  -- Try the standard driver directory
  local tCandidates = {
    sRelative,
    "/drivers/" .. sInput,
    "/drivers/" .. sInput .. ".sys.lua",
    "/drivers/" .. sInput .. ".lua",
  }

  for _, sCandidate in ipairs(tCandidates) do
    local h = fs.open(sCandidate, "r")
    if h then
      fs.close(h)
      return sCandidate
    end
  end

  return nil
end

-- =============================================
-- DRIVER FILE VALIDATION
-- =============================================

local function validate_driver_file(sPath)
  log_verbose("Opening file: " .. sPath)

  -- Read-only validation — we never write to the driver file
  local hFile = fs.open(sPath, "r")
  if not hFile then
    return nil, "File not found or permission denied: " .. sPath
  end

  local sCode = fs.read(hFile, math.huge)
  fs.close(hFile)

  if not sCode or #sCode == 0 then
    return nil, "File is empty or unreadable: " .. sPath
  end

  log_verbose("File size: " .. #sCode .. " bytes")
  log_verbose("Read-only validation (no system state modified)")

  -- Check for required globals
  local bHasDriverInfo = false
  local bHasDriverEntry = false
  local bHasMainLoop = false

  -- Simple text scanning (no regex, as requested)
  -- Look for g_tDriverInfo
  if sCode:find("g_tDriverInfo") then
    bHasDriverInfo = true
    log_verbose("Found g_tDriverInfo declaration")
  end

  -- Look for DriverEntry or UMDriverEntry
  if sCode:find("function DriverEntry") or sCode:find("function UMDriverEntry") then
    bHasDriverEntry = true
    log_verbose("Found DriverEntry function")
  end

  -- Look for main loop
  if sCode:find("while true") then
    bHasMainLoop = true
    log_verbose("Found main event loop")
  end

  local tWarnings = {}

  if not bHasDriverInfo then
    return nil, "Missing g_tDriverInfo table. This is not a valid AxisOS driver."
  end

  if not bHasDriverEntry then
    table.insert(tWarnings, "No DriverEntry function found. Driver may not initialize properly.")
  end

  if not bHasMainLoop then
    table.insert(tWarnings, "No main loop detected. Driver may exit immediately after init.")
  end

  -- Extract driver info from the file text
  local tInfo = {}

  -- Find sDriverName
  local nNameStart = sCode:find("sDriverName")
  if nNameStart then
    -- Walk forward to find the string value
    local nQuoteStart = sCode:find('"', nNameStart)
    if nQuoteStart then
      local nQuoteEnd = sCode:find('"', nQuoteStart + 1)
      if nQuoteEnd then
        tInfo.sDriverName = sCode:sub(nQuoteStart + 1, nQuoteEnd - 1)
      end
    end
  end

  -- Find sDriverType
  local nTypeStart = sCode:find("sDriverType")
  if nTypeStart then
    -- Check for known types
    if sCode:find("DRIVER_TYPE_KMD", nTypeStart) then
      tInfo.sDriverType = "KernelModeDriver"
    elseif sCode:find("DRIVER_TYPE_CMD", nTypeStart) then
      tInfo.sDriverType = "ComponentModeDriver"
    elseif sCode:find("DRIVER_TYPE_UMD", nTypeStart) then
      tInfo.sDriverType = "UserModeDriver"
    end
  end

  -- Find nLoadPriority
  local nPrioStart = sCode:find("nLoadPriority")
  if nPrioStart then
    -- Walk forward to find the number
    local nEqSign = sCode:find("=", nPrioStart)
    if nEqSign then
      local sRest = sCode:sub(nEqSign + 1, nEqSign + 10)
      -- Extract digits
      local sNum = ""
      for i = 1, #sRest do
        local c = sRest:sub(i, i)
        if c == "0" or c == "1" or c == "2" or c == "3" or c == "4" or
           c == "5" or c == "6" or c == "7" or c == "8" or c == "9" then
          sNum = sNum .. c
        elseif #sNum > 0 then
          break
        end
      end
      if #sNum > 0 then
        tInfo.nLoadPriority = tonumber(sNum)
      end
    end
  end

  -- Find sVersion
  local nVerStart = sCode:find("sVersion")
  if nVerStart then
    local nQuoteStart = sCode:find('"', nVerStart)
    if nQuoteStart then
      local nQuoteEnd = sCode:find('"', nQuoteStart + 1)
      if nQuoteEnd then
        tInfo.sVersion = sCode:sub(nQuoteStart + 1, nQuoteEnd - 1)
      end
    end
  end

  -- Find sSupportedComponent
  local nCompStart = sCode:find("sSupportedComponent")
  if nCompStart then
    local nQuoteStart = sCode:find('"', nCompStart)
    if nQuoteStart then
      local nQuoteEnd = sCode:find('"', nQuoteStart + 1)
      if nQuoteEnd then
        tInfo.sSupportedComponent = sCode:sub(nQuoteStart + 1, nQuoteEnd - 1)
      end
    end
  end

  tInfo.nFileSize = #sCode
  tInfo.tWarnings = tWarnings

  return tInfo
end

-- =============================================
-- DRIVER TYPE DISPLAY
-- =============================================

local function format_driver_type(sType)
  if sType == "KernelModeDriver" then
    return C_RED .. "KMD (Ring 2)" .. C_RESET
  elseif sType == "ComponentModeDriver" then
    return C_YELLOW .. "CMD (Ring 2, Hardware-Bound)" .. C_RESET
  elseif sType == "UserModeDriver" then
    return C_GREEN .. "UMD (Ring 3, Sandboxed)" .. C_RESET
  end
  return C_GRAY .. tostring(sType) .. C_RESET
end

-- =============================================
-- INFO DISPLAY
-- =============================================

local function display_driver_info(sPath, tInfo)
  print("")
  print(C_CYAN .. "  Driver Information" .. C_RESET)
  print(C_GRAY .. "  " .. string.rep("-", 40) .. C_RESET)
  print("  Name:       " .. C_GREEN .. (tInfo.sDriverName or "Unknown") .. C_RESET)
  print("  Type:       " .. format_driver_type(tInfo.sDriverType))
  print("  Priority:   " .. tostring(tInfo.nLoadPriority or "N/A"))
  print("  Version:    " .. (tInfo.sVersion or "N/A"))
  print("  File:       " .. sPath)
  print("  Size:       " .. tostring(tInfo.nFileSize) .. " bytes")

  if tInfo.sSupportedComponent then
    print("  Component:  " .. C_YELLOW .. tInfo.sSupportedComponent .. C_RESET)
  end

  if tInfo.tWarnings and #tInfo.tWarnings > 0 then
    print("")
    for _, sWarn in ipairs(tInfo.tWarnings) do
      log_warn(sWarn)
    end
  end

  print(C_GRAY .. "  " .. string.rep("-", 40) .. C_RESET)
  print("")
end

-- =============================================
-- SECURITY CHECK
-- =============================================

local function check_permissions()
  local nRing = syscall("process_get_ring")
  local nUid = env.UID

  log_verbose("Current ring level: " .. tostring(nRing))
  log_verbose("Current UID: " .. tostring(nUid))

  -- UID 0 (root) can always load drivers regardless of ring
  if nUid and tonumber(nUid) == 0 then
    log_verbose("Running as root (UID 0). Access granted.")
    return true
  end

  -- Non-root users cannot load drivers at any ring
  log_fail("Permission denied: only root (UID 0) can load drivers.")
  print("  Your UID: " .. tostring(nUid or "unknown"))
  print("  Required: UID 0 (root)")
  print("")
  print("  To elevate, run: " .. C_CYAN .. "su" .. C_RESET)
  return false
end

-- =============================================
-- LOAD DRIVER
-- =============================================

local function load_driver(sPath)
  local nTotalSteps = 5

  -- Step 1: Resolve path
  log_step(1, nTotalSteps, "Resolving driver path...")
  local sResolvedPath = resolve_path(sPath)

  if not sResolvedPath then
    log_fail("Could not find driver file.")
    log_verbose("Tried paths based on: " .. sPath)
    print("  Searched:")
    print("    " .. C_GRAY .. sPath .. C_RESET)
    print("    " .. C_GRAY .. "/drivers/" .. sPath .. C_RESET)
    print("    " .. C_GRAY .. "/drivers/" .. sPath .. ".sys.lua" .. C_RESET)
    return false
  end

  log_ok("Resolved to: " .. sResolvedPath)

  -- Step 2: Validate driver file
  log_step(2, nTotalSteps, "Validating driver file...")
  local tInfo, sValidateErr = validate_driver_file(sResolvedPath)

  if not tInfo then
    log_fail("Validation failed: " .. sValidateErr)
    return false
  end

  log_ok("Validation passed for '" .. (tInfo.sDriverName or "Unknown") .. "'")
  display_driver_info(sResolvedPath, tInfo)

  -- Step 3: Security check
  log_step(3, nTotalSteps, "Checking security permissions...")

  if not check_permissions() then
    return false
  end

  log_ok("Security check passed.")

  -- Step 4: Check for CMD component availability
  if tInfo.sDriverType == "ComponentModeDriver" and tInfo.sSupportedComponent then
    log_step(4, nTotalSteps, "Scanning for '" .. tInfo.sSupportedComponent .. "' hardware...")
    log_verbose("Driver is a CMD. DKMS will auto-discover components.")
    log_verbose("Supported component type: " .. tInfo.sSupportedComponent)
    log_ok("DKMS will handle hardware binding during load.")
  else
    log_step(4, nTotalSteps, "Preparing for load...")
    if tInfo.sDriverType == "KernelModeDriver" then
      log_verbose("Driver is KMD. Will run at Ring 2.")
    elseif tInfo.sDriverType == "UserModeDriver" then
      log_verbose("Driver is UMD. Will run at Ring 3 inside a driver host.")
    end
    log_ok("Ready.")
  end

  -- Step 5: Actually load via syscall
-- Step 5: Actually load via syscall
  log_step(5, nTotalSteps, "Sending load request to Pipeline Manager...")
  log_verbose("Issuing syscall('driver_load', '" .. sResolvedPath .. "')")
  log_verbose("PM will validate, DKMS will spawn, driver will init.")

  -- syscall returns: (ipc_ok, pm_result, pm_message)
  local bIpcOk, bPmResult, sPmMessage = syscall("driver_load", sResolvedPath)

  if not bIpcOk then
    log_fail("IPC failure communicating with Pipeline Manager!")
    print("  " .. C_RED .. "The syscall itself failed. Kernel issue?" .. C_RESET)
    return false
  end

  if bPmResult then
    log_ok("Driver loaded successfully!")
    print("")
    print("  " .. C_GREEN .. tostring(sPmMessage) .. C_RESET)
    print("")

    -- Verify the driver appeared in /dev
    if tInfo.sSupportedComponent then
      log_verbose("Checking /dev for new device entries...")
      local tDevList = fs.list("/dev")
      if tDevList then
        local tNewDevs = {}
        for _, sName in ipairs(tDevList) do
          -- Check if device name contains the component type
          local sClean = sName
          if sClean:sub(-1) == "/" then sClean = sClean:sub(1, -2) end
          -- Simple string search
          local bMatch = false
          local sComp = tInfo.sSupportedComponent
          if #sClean >= #sComp then
            for i = 1, #sClean - #sComp + 1 do
              if sClean:sub(i, i + #sComp - 1) == sComp then
                bMatch = true
                break
              end
            end
          end
          if bMatch then
            table.insert(tNewDevs, sClean)
          end
        end

        if #tNewDevs > 0 then
          print("  New device(s) in /dev:")
          for _, sDev in ipairs(tNewDevs) do
            print("    " .. C_YELLOW .. "/dev/" .. sDev .. C_RESET)
          end
          print("")
        end
      end
    end

    return true
  else
    log_fail("Driver load failed!")
    print("")
    print("  " .. C_RED .. "Error: " .. C_RESET .. tostring(sPmMessage))
    print("")

    -- Diagnostics
    print("  " .. C_CYAN .. "Troubleshooting:" .. C_RESET)

    if tInfo.sDriverType == "ComponentModeDriver" then
      print("    - Is the required hardware component present?")
      print("    - Run: " .. C_GRAY .. "ls /dev" .. C_RESET .. " to check existing devices")
      print("    - The component type '" .. (tInfo.sSupportedComponent or "?") .. "' may not be connected")
    end

    if tostring(sResult):find("SECURITY") or tostring(sResult):find("denied") then
      print("    - Driver signature or security check failed")
      print("    - Ensure the driver file is not corrupted")
    end

    if tostring(sResult):find("STATUS_DRIVER_INIT_FAILED") or tostring(sResult):find("404") then
      print("    - DriverEntry returned an error status")
      print("    - Check " .. C_GRAY .. "logread" .. C_RESET .. " for detailed DKMS logs")
    end

    print("")
    return false
  end
end

-- =============================================
-- SCAN MODE (-s)
-- =============================================

local function scan_and_load(sComponentType)
  log_info("Scanning for component type: " .. C_YELLOW .. sComponentType .. C_RESET)
  log_verbose("Looking for driver at /drivers/" .. sComponentType .. ".sys.lua")

  local sDriverPath = "/drivers/" .. sComponentType .. ".sys.lua"

  -- Check if driver file exists
  local hCheck = fs.open(sDriverPath, "r")
  if not hCheck then
    log_fail("No driver file found for component type '" .. sComponentType .. "'")
    print("")
    print("  Expected driver at: " .. C_GRAY .. sDriverPath .. C_RESET)
    print("  Install it with:    " .. C_CYAN .. "pkgman -S " .. sComponentType .. " driver" .. C_RESET)
    return false
  end
  fs.close(hCheck)

  log_ok("Found driver file: " .. sDriverPath)
  return load_driver(sDriverPath)
end

-- =============================================
-- INSPECT MODE (-i)
-- =============================================

local function inspect_driver(sPath)
  log_info("Inspecting driver (no load)...")

  local sResolvedPath = resolve_path(sPath)
  if not sResolvedPath then
    log_fail("Could not find driver file: " .. sPath)
    return false
  end

  local tInfo, sErr = validate_driver_file(sResolvedPath)
  if not tInfo then
    log_fail("Validation failed: " .. sErr)
    return false
  end

  display_driver_info(sResolvedPath, tInfo)
  log_ok("Inspection complete. No changes made.")
  return true
end

-- =============================================
-- MAIN
-- =============================================

if #tArgs < 1 then
  print_usage()
  return
end

-- Parse flags
local sMode = "load"
local sTarget = nil

local i = 1
while i <= #tArgs do
  local sArg = tArgs[i]

  if sArg == "-v" or sArg == "--verbose" then
    bVerbose = true
    log_verbose("Verbose mode enabled")

  elseif sArg == "-s" or sArg == "--scan" then
    sMode = "scan"
    i = i + 1
    if i <= #tArgs then
      sTarget = tArgs[i]
    else
      log_fail("Missing component type after -s flag")
      print("  Usage: insmod -s <component_type>")
      return
    end

  elseif sArg == "-i" or sArg == "--info" then
    sMode = "inspect"
    i = i + 1
    if i <= #tArgs then
      sTarget = tArgs[i]
    else
      log_fail("Missing path after -i flag")
      print("  Usage: insmod -i <driver_path>")
      return
    end

  elseif sArg == "-h" or sArg == "--help" then
    print_usage()
    return

  elseif sArg:sub(1, 1) == "-" then
    log_fail("Unknown flag: " .. sArg)
    print("  Use " .. C_CYAN .. "insmod -h" .. C_RESET .. " for help.")
    return

  else
    if not sTarget then
      sTarget = sArg
    else
      log_fail("Too many arguments. Did you mean to use quotes?")
      return
    end
  end

  i = i + 1
end

if not sTarget then
  log_fail("No target specified.")
  print_usage()
  return
end

-- Header
print("")
print(C_CYAN .. "insmod" .. C_RESET .. " - AxisOS Driver Insertion Tool")
print(C_GRAY .. string.rep("-", 50) .. C_RESET)
print("")

-- Dispatch
if sMode == "load" then
  local bSuccess = load_driver(sTarget)
  if bSuccess then
    print(C_GREEN .. "Operation completed successfully." .. C_RESET)
  else
    print(C_RED .. "Operation failed. See errors above." .. C_RESET)
  end

elseif sMode == "scan" then
  local bSuccess = scan_and_load(sTarget)
  if bSuccess then
    print(C_GREEN .. "Scan and load completed successfully." .. C_RESET)
  else
    print(C_RED .. "Scan and load failed. See errors above." .. C_RESET)
  end

elseif sMode == "inspect" then
  inspect_driver(sTarget)
end

```


axis-os\src\kernel\usr\commands\ipc_test.lua
```
--
-- /usr/commands/ipc_test.lua — Full IPC subsystem test suite
--

local thread   = require("thread")
local sync     = require("sync")
local pipe     = require("pipe")
local signal   = require("signal_lib")
local ipc      = require("ipc")
local computer = require("computer")

local C = {
    R="\27[37m", GRN="\27[32m", RED="\27[31m",
    YLW="\27[33m", CYN="\27[36m", GRY="\27[90m",
}
local nP, nF, nW = 0, 0, 0
local function pass(s) nP=nP+1; print(C.GRN.."  [PASS] "..C.R..s) end
local function fail(s) nF=nF+1; print(C.RED.."  [FAIL] "..C.R..s) end
local function warn(s) nW=nW+1; print(C.YLW.."  [WARN] "..C.R..s) end
local function info(s) print(C.CYN.."  [INFO] "..C.R..s) end
local function banner(s) print("\n"..C.CYN.."  === "..s.." ==="..C.R) end

local function sleep(n)
    local d = computer.uptime() + n
    while computer.uptime() < d do syscall("process_yield") end
end

print(C.CYN.."\n  IPC Subsystem Test Suite"..C.R)
print(C.GRY.."  "..string.rep("=",50)..C.R)

-- =============================================
-- TEST 1: Events
-- =============================================
banner("TEST 1: Events")
do
    local hEvt = sync.createEvent(false, false) -- auto-reset, not signaled
    if hEvt then pass("Event created") else fail("Event creation failed"); goto t2 end

    local bSeen = false
    local t = thread.create(function()
        sync.wait(hEvt)
        bSeen = true
    end)
    sleep(0.1)
    if bSeen then fail("Thread woke before event set") else pass("Thread blocked on event") end

    sync.setEvent(hEvt)
    sleep(0.2)
    if t then t:join() end
    if bSeen then pass("Thread woke after event set") else fail("Thread never woke") end

    -- Manual reset event
    local hM = sync.createEvent(true, false)
    sync.setEvent(hM)
    local r1 = sync.wait(hM, 100)
    local r2 = sync.wait(hM, 100)
    if r1 == 0 and r2 == 0 then
        pass("Manual-reset event stays signaled for multiple waits")
    else
        fail("Manual-reset behavior wrong: "..tostring(r1).." "..tostring(r2))
    end
    sync.resetEvent(hM)
    local r3 = sync.wait(hM, 50)
    if r3 == 258 then pass("Reset event blocks → timeout") else warn("Expected timeout, got "..tostring(r3)) end
end
::t2::

-- =============================================
-- TEST 2: Mutexes
-- =============================================
banner("TEST 2: Mutexes")
do
    local hMtx = sync.createMutex(false)
    if hMtx then pass("Mutex created") else fail("Mutex creation failed"); goto t3 end

    local nShared = 0
    local N = 500

    local function worker()
        for i = 1, N do
            sync.wait(hMtx)
            nShared = nShared + 1
            sync.releaseMutex(hMtx)
        end
    end

    local t1 = thread.create(worker)
    local t2 = thread.create(worker)
    if t1 then t1:join() end
    if t2 then t2:join() end

    info("Expected: " .. (N * 2) .. "  Got: " .. nShared)
    if nShared == N * 2 then
        pass("Mutex protected shared counter perfectly")
    else
        fail("Race condition! Expected ".. (N * 2) .." got "..nShared)
    end
end
::t3::

-- =============================================
-- TEST 3: Semaphores
-- =============================================
banner("TEST 3: Semaphores")
do
    local hSem = sync.createSemaphore(2, 5) -- 2 initial, 5 max
    if hSem then pass("Semaphore created (2/5)") else fail("Semaphore creation failed"); goto t4 end

    local r1 = sync.wait(hSem, 50)
    local r2 = sync.wait(hSem, 50)
    if r1 == 0 and r2 == 0 then pass("Acquired 2 permits (count→0)") end

    local r3 = sync.wait(hSem, 50)
    if r3 == 258 then pass("3rd acquire timed out (count=0)") else fail("Expected timeout") end

    sync.releaseSemaphore(hSem, 1)
    local r4 = sync.wait(hSem, 50)
    if r4 == 0 then pass("Acquire after release works") else fail("Post-release acquire failed") end
end
::t4::

-- =============================================
-- TEST 4: Pipes
-- =============================================
banner("TEST 4: Pipes")
do
    local p = pipe.create(256)
    if p then pass("Pipe created (256B buffer)") else fail("Pipe creation failed"); goto t5 end

    local sReceived = nil
    local t = thread.create(function()
        local ok, data = pipe.read(p.read, 1024)
        sReceived = data
    end)

    sleep(0.1)
    pipe.write(p.write, "Hello, Pipe!")
    pipe.closeWrite(p.write)
    if t then t:join() end

    if sReceived == "Hello, Pipe!" then
        pass("Pipe transferred data: '"..sReceived.."'")
    else
        fail("Pipe data mismatch: '"..tostring(sReceived).."'")
    end

    -- Blocking write test (fill the buffer)
    local p2 = pipe.create(32)
    if p2 then
        local bWriteDone = false
        local tW = thread.create(function()
            pipe.write(p2.write, string.rep("X", 64)) -- exceeds 32B buffer
            bWriteDone = true
        end)
        sleep(0.1)
        if not bWriteDone then pass("Write blocked on full pipe") else warn("Write didn't block") end
        local _, chunk = pipe.read(p2.read, 32)
        sleep(0.2)
        if tW then tW:join() end
        if bWriteDone then pass("Write completed after read freed space") end
    end
end
::t5::

-- =============================================
-- TEST 5: Shared Memory
-- =============================================
banner("TEST 5: Shared Memory Sections")
do
    local hSec = ipc.createSection("test_shm", 4096)
    if hSec then pass("Section 'test_shm' created") else fail("Section creation failed"); goto t6 end

    local tView = ipc.mapSection(hSec)
    if tView then pass("Section mapped") else fail("Map failed"); goto t6 end

    tView.counter = 0
    tView.message = "init"

    local tDone = {false, false}
    local hMtx = sync.createMutex(false)

    for i = 1, 2 do
        local idx = i
        thread.create(function()
            local hS2 = ipc.openSection("test_shm")
            local tV2 = ipc.mapSection(hS2)
            for j = 1, 100 do
                sync.wait(hMtx)
                tV2.counter = tV2.counter + 1
                sync.releaseMutex(hMtx)
            end
            tDone[idx] = true
        end)
    end

    while not (tDone[1] and tDone[2]) do sleep(0.05) end
    info("Shared counter: " .. tostring(tView.counter))
    if tView.counter == 200 then
        pass("Two threads incremented shared memory to 200")
    else
        fail("Expected 200, got "..tostring(tView.counter))
    end
end
::t6::

-- =============================================
-- TEST 6: Message Queues
-- =============================================
banner("TEST 6: Message Queues")
do
    local hQ = ipc.createMqueue("test_mq", 16, 256)
    if hQ then pass("MQueue 'test_mq' created") else fail("MQueue creation failed"); goto t7 end

    ipc.mqSend(hQ, "low_priority", 1)
    ipc.mqSend(hQ, "high_priority", 10)
    ipc.mqSend(hQ, "med_priority", 5)

    local m1 = ipc.mqReceive(hQ, 100)
    local m2 = ipc.mqReceive(hQ, 100)
    local m3 = ipc.mqReceive(hQ, 100)

    if m1 == "high_priority" then pass("Highest priority first: '"..m1.."'") else fail("Order wrong: "..tostring(m1)) end
    if m2 == "med_priority" then pass("Medium priority second") end
    if m3 == "low_priority" then pass("Low priority last") end

    -- Blocking receive
    local sGot = nil
    local tR = thread.create(function()
        sGot = ipc.mqReceive(hQ, 2000)
    end)
    sleep(0.1)
    if sGot then fail("Receiver should be blocked") else pass("Receiver blocked on empty queue") end
    local hQ2 = ipc.openMqueue("test_mq")
    ipc.mqSend(hQ2, "delayed_msg", 0)
    sleep(0.2)
    if tR then tR:join() end
    if sGot == "delayed_msg" then
        pass("Blocking receive got message: '"..sGot.."'")
    else
        fail("Expected 'delayed_msg', got: "..tostring(sGot))
    end
end
::t7::

-- =============================================
-- TEST 7: Signals
-- =============================================
banner("TEST 7: Signals")
do
    local bCaught = false
    local nCaughtSig = 0

    signal.handle(signal.SIGUSR1, function(sig)
        bCaught = true
        nCaughtSig = sig
    end)

    local nMyPid = syscall("process_get_pid")
    signal.send(nMyPid, signal.SIGUSR1)
    -- Signal is delivered at next __pc() or syscall
    syscall("process_yield")
    sleep(0.1)

    if bCaught then
        pass("SIGUSR1 caught by handler (sig="..nCaughtSig..")")
    else
        fail("Signal handler was not called")
    end

    -- SIGCHLD test
    local bChildDied = false
    signal.handle(signal.SIGCHLD, function()
        bChildDied = true
    end)

    local tChild = thread.create(function()
        -- do nothing, just exit
    end)
    if tChild then tChild:join() end
    sleep(0.2)
    syscall("process_yield")

    if bChildDied then
        pass("SIGCHLD received on child death")
    else
        warn("SIGCHLD not received (delivery may be delayed)")
    end

    signal.handle(signal.SIGUSR1, nil)  -- reset to default
    signal.handle(signal.SIGCHLD, nil)
end

-- =============================================
-- TEST 8: WaitForMultipleObjects
-- =============================================
banner("TEST 8: WaitForMultipleObjects")
do
    local hE1 = sync.createEvent(false, false)
    local hE2 = sync.createEvent(false, false)
    local hE3 = sync.createEvent(false, false)
    if not hE1 then fail("Couldn't create events"); goto t9 end

    -- WaitAny
    local nResult = -1
    local tW = thread.create(function()
        nResult = sync.waitMultiple({hE1, hE2, hE3}, false, 2000)
    end)
    sleep(0.1)
    sync.setEvent(hE2) -- signal second event
    sleep(0.2)
    if tW then tW:join() end

    if nResult == 1 then -- WAIT_OBJECT_0 + 1 (index of hE2)
        pass("WaitAny returned index 1 (second object signaled)")
    else
        fail("WaitAny returned "..tostring(nResult).." expected 1")
    end

    -- WaitAll
    local hA = sync.createEvent(true, false)
    local hB = sync.createEvent(true, false)
    local nAllResult = -1
    local tA = thread.create(function()
        nAllResult = sync.waitMultiple({hA, hB}, true, 2000)
    end)
    sleep(0.1)
    sync.setEvent(hA)
    sleep(0.1)
    if nAllResult >= 0 then fail("WaitAll woke with only one event") end
    sync.setEvent(hB)
    sleep(0.2)
    if tA then tA:join() end
    if nAllResult == 0 then
        pass("WaitAll woke when both events signaled")
    else
        fail("WaitAll returned "..tostring(nAllResult))
    end

    -- Timeout
    local hNever = sync.createEvent(false, false)
    local rTimeout = sync.wait(hNever, 100)
    if rTimeout == 258 then
        pass("Wait timed out correctly (100ms)")
    else
        fail("Expected timeout(258), got "..tostring(rTimeout))
    end
end
::t9::

-- =============================================
-- TEST 9: Process Groups
-- =============================================
banner("TEST 9: Process Groups")
do
    local nMyPid = syscall("process_get_pid")
    local nPgid = signal.getpgid()
    info("My PID=" .. tostring(nMyPid) .. " PGID=" .. tostring(nPgid))

    local nGroupHits = 0
    signal.handle(signal.SIGUSR2, function()
        nGroupHits = nGroupHits + 1
    end)

    -- The main thread's pgid IS nMyPid, so sending to group sends to us
    signal.sendGroup(nPgid, signal.SIGUSR2)
    syscall("process_yield")
    sleep(0.1)

    if nGroupHits > 0 then
        pass("Group signal delivered ("..nGroupHits.." hits)")
    else
        warn("Group signal not yet delivered")
    end

    signal.handle(signal.SIGUSR2, nil)
end

-- =============================================
-- TEST 10: IPC Statistics
-- =============================================
banner("TEST 10: IPC Statistics")
do
    local t = syscall("ke_ipc_stats")
    if t then
        pass("Stats retrieved")
        info(string.format("Pipes=%d  Events=%d  Mutexes=%d  Signals=%d",
            t.nPipeCreated, t.nEventCreated, t.nMutexCreated, t.nSignalsSent))
        info(string.format("Waits issued=%d  satisfied=%d  timed_out=%d",
            t.nWaitsIssued, t.nWaitsSatisfied, t.nWaitsTimedOut))
        info(string.format("DPCs=%d  Timers=%d  Pipe bytes=%d",
            t.nDpcsProcessed, t.nTimersFired, t.nPipeBytes))
    else
        fail("Stats unavailable")
    end
end

-- =============================================
-- SUMMARY
-- =============================================
banner("SUMMARY")
print(string.format("\n  %sPassed:%s %d", C.GRN, C.R, nP))
print(string.format("  %sFailed:%s %d", C.RED, C.R, nF))
print(string.format("  %sWarned:%s %d", C.YLW, C.R, nW))
if nF == 0 then
    print(C.GRN.."\n  IPC SUBSYSTEM: ALL TESTS PASSED"..C.R)
else
    print(C.RED.."\n  IPC SUBSYSTEM: "..nF.." FAILURE(S)"..C.R)
end
print("")
```


axis-os\src\kernel\usr\commands\ipcs.lua
```
--
-- /usr/commands/ipcs.lua — IPC status display
--

local tArgs = env.ARGS or {}
local C = {
    R="\27[37m", CYN="\27[36m", GRN="\27[32m",
    YLW="\27[33m", RED="\27[31m", GRY="\27[90m", MAG="\27[35m",
}

local tStats = syscall("ke_ipc_stats")
if not tStats then print("ipcs: IPC subsystem not available"); return end

print(C.CYN .. "AxisOS IPC Status" .. C.R)
print(C.GRY .. string.rep("-", 50) .. C.R)

print(C.YLW .. "\n  Synchronization Objects" .. C.R)
print(string.format("    Events created:      %s%d%s", C.GRN, tStats.nEventCreated or 0, C.R))
print(string.format("    Mutexes created:     %s%d%s", C.GRN, tStats.nMutexCreated or 0, C.R))
print(string.format("    Semaphores created:  %s%d%s", C.GRN, tStats.nSemCreated or 0, C.R))

print(C.YLW .. "\n  Pipes" .. C.R)
print(string.format("    Pipes created:       %s%d%s", C.GRN, tStats.nPipeCreated or 0, C.R))
print(string.format("    Named pipes active:  %s%d%s", C.GRN, tStats.nNamedPipes or 0, C.R))
print(string.format("    Bytes transferred:   %s%d%s", C.GRN, tStats.nPipeBytes or 0, C.R))

print(C.YLW .. "\n  Shared Memory" .. C.R)
print(string.format("    Sections created:    %s%d%s", C.GRN, tStats.nSectionCreated or 0, C.R))
print(string.format("    Active sections:     %s%d%s", C.GRN, tStats.nSections or 0, C.R))

print(C.YLW .. "\n  Message Queues" .. C.R)
print(string.format("    Queues created:      %s%d%s", C.GRN, tStats.nMqCreated or 0, C.R))
print(string.format("    Active queues:       %s%d%s", C.GRN, tStats.nMQueues or 0, C.R))

print(C.YLW .. "\n  Signals" .. C.R)
print(string.format("    Signals sent:        %s%d%s", C.GRN, tStats.nSignalsSent or 0, C.R))
print(string.format("    Signals delivered:   %s%d%s", C.GRN, tStats.nSignalsDelivered or 0, C.R))
print(string.format("    Process groups:      %s%d%s", C.GRN, tStats.nProcGroups or 0, C.R))

print(C.YLW .. "\n  Wait System" .. C.R)
print(string.format("    Waits issued:        %s%d%s", C.GRN, tStats.nWaitsIssued or 0, C.R))
print(string.format("    Waits satisfied:     %s%d%s", C.GRN, tStats.nWaitsSatisfied or 0, C.R))
print(string.format("    Waits timed out:     %s%d%s", C.YLW, tStats.nWaitsTimedOut or 0, C.R))

print(C.YLW .. "\n  DPC & Timers" .. C.R)
print(string.format("    DPCs processed:      %s%d%s", C.GRN, tStats.nDpcsProcessed or 0, C.R))
print(string.format("    DPCs pending:        %s%d%s", C.GRN, tStats.nActiveDpcs or 0, C.R))
print(string.format("    Timers fired:        %s%d%s", C.GRN, tStats.nTimersFired or 0, C.R))
print(string.format("    Timers active:       %s%d%s", C.GRN, tStats.nActiveTimers or 0, C.R))
print("")
```


axis-os\src\kernel\usr\commands\kill.lua
```
-- /usr/commands/kill.lua
local tArgs = env.ARGS or {}
if #tArgs < 1 then print("Usage: kill <pid>"); return end

local nTarget = tonumber(tArgs[1])
if not nTarget then print("kill: not a number: " .. tArgs[1]); return end

local bOk, sErr = syscall("process_kill", nTarget)
if bOk then
    print("Killed PID " .. nTarget)
else
    print("kill: " .. tostring(sErr))
end
```


axis-os\src\kernel\usr\commands\logread.lua
```
local fs = require("filesystem")

local hLog = fs.open("/dev/ringlog", "r")
if not hLog then
  print("Error: Could not open /dev/ringlog")
  return
end

local sData = fs.read(hLog, math.huge)
fs.close(hLog)

if sData then
  print(sData)
else
  print("Log is empty.")
end
```


axis-os\src\kernel\usr\commands\ls.lua
```
-- ls - list directory (Pro Edition)
-- now with colors, -l and -a support.

local fs = require("filesystem")
local tArgs = env.ARGS or {}

-- ANSI Colors
local C_RESET  = "\27[37m"
local C_DIR    = "\27[34m"
local C_DEV    = "\27[33m"
local C_EXEC   = "\27[32m"
local C_FILE   = "\27[37m"
local C_GRAY   = "\27[90m"

-- Parse arguments: flags start with -, everything else is the path
local bLongMode = false
local bShowAll  = false
local sPath = nil

for _, sArg in ipairs(tArgs) do
  if sArg:sub(1, 1) == "-" then
    -- walk each flag character after the dash
    for i = 2, #sArg do
      local c = sArg:sub(i, i)
      if c == "l" then
        bLongMode = true
      elseif c == "a" then
        bShowAll = true
      else
        print("ls: unknown option -- '" .. c .. "'")
        print("Usage: ls [-la] [directory]")
        return
      end
    end
  elseif not sPath then
    sPath = sArg
  else
    print("ls: too many arguments")
    print("Usage: ls [-la] [directory]")
    return
  end
end

local sPwd = env.PWD or "/"
local sTargetDir = sPath or sPwd

-- Resolve relative paths
if sTargetDir:sub(1,1) ~= "/" then
  sTargetDir = sPwd .. (sPwd == "/" and "" or "/") .. sTargetDir
end
sTargetDir = sTargetDir:gsub("//", "/")

-- Get file list
local tList, sErr = fs.list(sTargetDir)
if not tList or type(tList) ~= "table" then
  print("ls: cannot access '" .. sTargetDir .. "': " .. tostring(sErr or "No such file or directory"))
  return
end

table.sort(tList)

-- Load permissions DB for -l mode
local tPermsDb = {}
if bLongMode then
  local hPerms = fs.open("/etc/perms.lua", "r")
  if hPerms then
    local sData = fs.read(hPerms, math.huge)
    fs.close(hPerms)
    if sData then
       local f = load(sData, "perms", "t", {})
       if f then tPermsDb = f() end
    end
  end
end

local function format_mode(nMode)
  if not nMode then return "rwxr-xr-x" end
  local sM = string.format("%03d", nMode)
  local sRes = ""
  local tMaps = { [7]="rwx", [6]="rw-", [5]="r-x", [4]="r--", [0]="---" }
  for i=1, 3 do
    local c = tonumber(sM:sub(i,i))
    sRes = sRes .. (tMaps[c] or "???")
  end
  return sRes
end

local tBuffer = {}

for _, sName in ipairs(tList) do
  local bIsDir = (sName:sub(-1) == "/")
  local sCleanName = bIsDir and sName:sub(1, -2) or sName

  -- skip dotfiles unless -a
  if not bShowAll and sCleanName:sub(1, 1) == "." then
    goto continue
  end

  local sFullPath = sTargetDir .. (sTargetDir == "/" and "" or "/") .. sCleanName

  local sColor = C_FILE
  local sTypeChar = "-"

  if bIsDir then
    sColor = C_DIR
    sTypeChar = "d"
  elseif sTargetDir:sub(1, 5) == "/dev/" or sTargetDir == "/dev" then
    sColor = C_DEV
    sTypeChar = "c"
  elseif sName:sub(-4) == ".lua" then
    sColor = C_EXEC
  end

  if bLongMode then
    local tP = tPermsDb[sFullPath]
    local sModeStr = format_mode(tP and tP.mode)
    local nUid = tP and tP.uid or 0
    local sOwner = (nUid == 0) and "root" or tostring(nUid)
    if #sOwner < 5 then sOwner = sOwner .. string.rep(" ", 5 - #sOwner) end

    local sLine = string.format("%s%s%s %s %s%s%s",
      C_GRAY, sTypeChar .. sModeStr, C_RESET,
      sOwner,
      sColor, sName, C_RESET
    )
    table.insert(tBuffer, sLine)
  else
    table.insert(tBuffer, sColor .. sName .. C_RESET)
  end

  ::continue::
end

if #tBuffer > 0 then
  io.write(table.concat(tBuffer, "\n") .. "\n")
end
```


axis-os\src\kernel\usr\commands\manifest.lua
```
-- /usr/commands/manifest.lua
-- Generate and verify signed boot manifests
--
-- A manifest is a signed list of (path, sha256_hash) pairs
-- for every critical system file. The EEPROM stores the
-- manifest's own hash, and the kernel verifies it at boot.
--
-- Usage:
--   manifest --generate     Create and sign manifest
--   manifest --verify       Verify current system against manifest
--   manifest --show         Display manifest contents
--

local fs = require("filesystem")
local crypto = require("crypto")
local tArgs = env.ARGS or {}

local C = {
  R="\27[37m", GRN="\27[32m", RED="\27[31m",
  CYN="\27[36m", YLW="\27[33m", GRY="\27[90m"
}

local MANIFEST_PATH = "/boot/manifest.sig"
local MANIFEST_PATHS = {
    -- Critical boot chain
    "/kernel.lua",
    "/lib/pipeline_manager.lua",
    "/system/dkms.lua",
    "/system/driverdispatch.lua",
    
    -- Security infrastructure
    "/lib/ob_manager.lua",
    "/lib/ke_ipc.lua",
    "/lib/preempt.lua",
    "/lib/registry.lua",
    "/lib/crypto.lua",
    "/lib/pki_client.lua",
    "/sys/security/dkms_sec.lua",
    
    -- Driver kit
    "/system/lib/dk/shared_structs.lua",
    "/system/lib/dk/kmd_api.lua",
    "/system/lib/dk/common_api.lua",
    
    -- Core drivers
    "/drivers/tty.sys.lua",
    "/drivers/gpu.sys.lua",
    
    -- Init
    "/bin/init.lua",
    "/bin/sh.lua",
    
    -- Config (integrity-sensitive)
    "/etc/passwd.lua",
    "/etc/perms.lua",
    "/etc/pki.cfg",
}

local bOk, nTier = crypto.Init()
if not bOk then
    print(C.RED .. "No data card." .. C.R)
    return
end

local function hashFile(sPath)
    local h = fs.open(sPath, "r")
    if not h then return nil end
    local chunks = {}
    while true do
        local d = fs.read(h, 8192)
        if not d then break end
        chunks[#chunks+1] = d
    end
    fs.close(h)
    local sData = table.concat(chunks)
    local sHash = crypto.SHA256(sData)
    return crypto.Encode64(sHash), #sData
end

-- === GENERATE ===
if tArgs[1] == "--generate" or tArgs[1] == "-g" then
    print(C.CYN .. "Generating boot manifest..." .. C.R)
    print("")
    
    local tEntries = {}
    local nTotal = 0
    local nMissing = 0
    
    for _, sPath in ipairs(MANIFEST_PATHS) do
        local sHash, nSize = hashFile(sPath)
        if sHash then
            tEntries[#tEntries+1] = {
                path = sPath,
                hash = sHash,
                size = nSize
            }
            nTotal = nTotal + 1
            print(C.GRN .. "  ✓ " .. C.R .. sPath)
        else
            nMissing = nMissing + 1
            print(C.YLW .. "  ? " .. C.R .. sPath .. C.GRY .. " (missing)" .. C.R)
        end
    end
    
    -- Build manifest document
    local tLines = {}
    tLines[1] = "-- AxisOS Boot Manifest"
    tLines[2] = "-- Generated: " .. os.date("%Y-%m-%d %H:%M:%S")
    tLines[3] = "-- Files: " .. nTotal
    tLines[4] = "return {"
    
    for _, e in ipairs(tEntries) do
        tLines[#tLines+1] = string.format(
            '  {path="%s", hash="%s", size=%d},',
            e.path, e.hash, e.size)
    end
    tLines[#tLines+1] = "}"
    
    local sManifest = table.concat(tLines, "\n")
    
    -- Sign manifest if Tier 3
    local sSigBlock = ""
    if nTier >= 3 then
        local hPriv = fs.open("/etc/signing/private.key", "r")
        if hPriv then
            local sPrivB64 = fs.read(hPriv, math.huge)
            fs.close(hPriv)
            local oPrivKey = crypto.DeserializeKey(sPrivB64, "ec-private")
            if oPrivKey then
                local sSig = crypto.Sign(sManifest, oPrivKey)
                local sSigB64 = crypto.Encode64(sSig)
                
                -- Get signer fingerprint
                local hPub = fs.open("/etc/signing/public.key", "r")
                local sPub = hPub and fs.read(hPub, math.huge) or ""
                if hPub then fs.close(hPub) end
                local sFp = crypto.Encode64(crypto.SHA256(sPub))
                
                sSigBlock = "\n--@MANIFEST_SIG:" .. sSigB64 ..
                            "\n--@MANIFEST_SIGNER:" .. sFp
                print("")
                print(C.GRN .. "  Manifest SIGNED" .. C.R)
            end
        else
            print(C.YLW .. "  No signing key. Manifest unsigned." .. C.R)
        end
    end
    
    -- Write
    fs.mkdir("/boot")
    local hOut = fs.open(MANIFEST_PATH, "w")
    if hOut then
        fs.write(hOut, sManifest .. sSigBlock .. "\n")
        fs.close(hOut)
        print("")
        print(C.GRN .. "Manifest written to " .. MANIFEST_PATH .. C.R)
        print("  Files: " .. nTotal .. "  Missing: " .. nMissing)
    else
        print(C.RED .. "Cannot write manifest!" .. C.R)
    end
    return
end

-- === VERIFY ===
if tArgs[1] == "--verify" or tArgs[1] == "-v" then
    print(C.CYN .. "Verifying system against manifest..." .. C.R)
    print("")
    
    local hMan = fs.open(MANIFEST_PATH, "r")
    if not hMan then
        print(C.RED .. "No manifest found at " .. MANIFEST_PATH .. C.R)
        return
    end
    local sManifest = fs.read(hMan, math.huge)
    fs.close(hMan)
    
    -- Extract data portion (before signature block)
    local sData = sManifest:match("^(.-)%-%-@MANIFEST_SIG") or sManifest
    sData = sData:gsub("%s+$", "")  -- trim trailing whitespace
    
    -- Parse
    local fParse = load(sData, "manifest", "t", {})
    if not fParse then
        print(C.RED .. "Manifest parse error" .. C.R)
        return
    end
    local tManifest = fParse()
    
    local nOk, nFail, nMissing = 0, 0, 0
    
    for _, entry in ipairs(tManifest) do
        local sCurrentHash = hashFile(entry.path)
        if not sCurrentHash then
            nMissing = nMissing + 1
            print(C.YLW .. "  MISSING  " .. C.R .. entry.path)
        elseif sCurrentHash == entry.hash then
            nOk = nOk + 1
            print(C.GRN .. "  OK       " .. C.R .. entry.path)
        else
            nFail = nFail + 1
            print(C.RED .. "  MODIFIED " .. C.R .. entry.path)
            print(C.GRY .. "           Expected: " .. entry.hash:sub(1,16) .. "..." .. C.R)
            print(C.GRY .. "           Actual:   " .. sCurrentHash:sub(1,16) .. "..." .. C.R)
        end
    end
    
    print("")
    print(string.format("  %sOK: %d%s  |  %sMODIFIED: %d%s  |  %sMISSING: %d%s",
        C.GRN, nOk, C.R,
        nFail > 0 and C.RED or C.GRN, nFail, C.R,
        nMissing > 0 and C.YLW or C.GRN, nMissing, C.R))
    
    if nFail > 0 then
        print("")
        print(C.RED .. "  ⚠  INTEGRITY VIOLATION DETECTED" .. C.R)
        print(C.RED .. "  System files have been modified since manifest was generated." .. C.R)
    elseif nMissing > 0 then
        print(C.YLW .. "  Some files missing but no tampering detected." .. C.R)
    else
        print(C.GRN .. "  ✓ ALL FILES VERIFIED" .. C.R)
    end
    return
end

-- === SHOW ===
if tArgs[1] == "--show" or tArgs[1] == "-s" then
    local hMan = fs.open(MANIFEST_PATH, "r")
    if not hMan then print("No manifest."); return end
    print(fs.read(hMan, math.huge))
    fs.close(hMan)
    return
end

-- === HELP ===
print(C.CYN .. "manifest" .. C.R .. " - Boot integrity manifest tool")
print("  manifest -g    Generate signed manifest")
print("  manifest -v    Verify system files against manifest")
print("  manifest -s    Show manifest contents")
```


axis-os\src\kernel\usr\commands\mkdir.lua
```
-- mkdir - create directories
local fs = require("filesystem")
local tArgs = env.ARGS or {}
if #tArgs == 0 then print("Usage: mkdir <dir> [...]"); return end

for _, sArg in ipairs(tArgs) do
  local sPath = sArg
  if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. "/" .. sPath end
  sPath = sPath:gsub("//", "/")
  local bOk = fs.mkdir(sPath)
  if not bOk then print("mkdir: cannot create '" .. sArg .. "'") end
end
```


axis-os\src\kernel\usr\commands\mv.lua
```
-- mv - move/rename files
local fs = require("filesystem")
local tArgs = env.ARGS or {}
if #tArgs < 2 then print("Usage: mv <source> <dest>"); return end

local sSrc, sDst = tArgs[1], tArgs[2]
if sSrc:sub(1,1) ~= "/" then sSrc = (env.PWD or "/") .. "/" .. sSrc end
if sDst:sub(1,1) ~= "/" then sDst = (env.PWD or "/") .. "/" .. sDst end
sSrc = sSrc:gsub("//", "/")
sDst = sDst:gsub("//", "/")

local hIn = fs.open(sSrc, "r")
if not hIn then print("mv: " .. sSrc .. ": No such file"); return end
local sData = fs.read(hIn, math.huge) or ""
fs.close(hIn)

local hOut = fs.open(sDst, "w")
if not hOut then print("mv: cannot create " .. sDst); return end
fs.write(hOut, sData)
fs.close(hOut)
fs.remove(sSrc)
```


axis-os\src\kernel\usr\commands\netstat.lua
```

```


axis-os\src\kernel\usr\commands\nfw.lua
```
--
-- /usr/commands/nfw.lua
-- AxisOS Network Firewall Manager
-- (name inspired by ufw — "netfilter wrapper")
--
-- Usage:
--   nfw status               Show firewall status
--   nfw rules                List active rules
--   nfw hosts                List hosts file entries
--   nfw audit [count]        Show recent audit log
--   nfw stats                Per-process connection stats
--   nfw reload               Reload rules from disk
--   nfw enable / disable     Toggle firewall
--   nfw limit <n>            Set per-UID connection limit
--   nfw test <url>           Test if a URL would be allowed
--

local fs  = require("filesystem")
local tArgs = env.ARGS or {}

local C = {
  R = "\27[37m", GRN = "\27[32m", RED = "\27[31m",
  YLW = "\27[33m", CYN = "\27[36m", GRY = "\27[90m", MAG = "\27[35m",
}

local function netctl(sMethod, tMethodArgs)
  local hNet = fs.open("/dev/net", "r")
  if not hNet then return nil, "Cannot open /dev/net" end
  local bOk, tResult = fs.deviceControl(hNet, sMethod, tMethodArgs or {})
  fs.close(hNet)
  return bOk, tResult
end

local function cmd_status()
  print(C.CYN .. "AxisOS Network Firewall Status" .. C.R)
  print(C.GRY .. string.rep("-", 40) .. C.R)

  local bOk, tInfo = netctl("info", {})
  if bOk and tInfo then
    print("  Online:     " .. (tInfo.bOnline and (C.GRN .. "Yes") or (C.RED .. "No")) .. C.R)
    print("  HTTP:       " .. (tInfo.bHttpEnabled and (C.GRN .. "Yes") or (C.RED .. "No")) .. C.R)
    print("  TCP:        " .. (tInfo.bTcpEnabled and (C.GRN .. "Yes") or (C.RED .. "No")) .. C.R)
    print("  Sessions:   " .. tostring(tInfo.nActiveSessions) .. "/" .. tostring(tInfo.nMaxSessions))
  end

  -- Check if netfilter is loaded by trying to get rules
  local bRulesOk, tRules = netctl("nf_rules", {})
  if bRulesOk and tRules then
    print("  Firewall:   " .. C.GRN .. "Active" .. C.R)
    print("  Rules:      " .. #tRules)
  else
    print("  Firewall:   " .. C.YLW .. "Not loaded" .. C.R)
  end
end

local function cmd_rules()
  local bOk, tRules = netctl("nf_rules", {})
  if not bOk or not tRules then
    print(C.YLW .. "Firewall rules not available" .. C.R)
    return
  end

  print(C.CYN .. "Active Network Policy Rules" .. C.R)
  print(C.GRY .. string.rep("-", 70) .. C.R)
  print(string.format("  %s%-3s %-6s %-5s %-24s %-6s %-4s %s%s",
        C.GRY, "#", "ACTION", "PROTO", "HOST", "PORT", "RING", "COMMENT", C.R))

  for i, tRule in ipairs(tRules) do
    local sAC = C.GRN
    if tRule.action == "deny" then sAC = C.RED
    elseif tRule.action == "log" then sAC = C.YLW end

    local sHost = tostring(tRule.host or "*")
    if #sHost > 22 then sHost = sHost:sub(1, 19) .. "..." end

    print(string.format("  %-3d %s%-6s%s %-5s %-24s %-6s %-4s %s",
          i,
          sAC, tRule.action or "?", C.R,
          tRule.proto or "*",
          sHost,
          tostring(tRule.port or "*"),
          tostring(tRule.ring or "*"),
          C.GRY .. (tRule.comment or "") .. C.R))
  end
end

local function cmd_hosts()
  local bOk, tHosts = netctl("nf_hosts", {})
  if not bOk or not tHosts then
    print(C.YLW .. "Hosts file not loaded" .. C.R)
    return
  end

  print(C.CYN .. "Hosts Entries (/etc/hosts)" .. C.R)
  print(C.GRY .. string.rep("-", 50) .. C.R)

  local nCount = 0
  for sHost, sTarget in pairs(tHosts) do
    local sColor = C.GRN
    if sTarget == "0.0.0.0" or sTarget == "127.0.0.1" then
      sColor = C.RED
    end
    print(string.format("  %-30s -> %s%s%s", sHost, sColor, sTarget, C.R))
    nCount = nCount + 1
  end
  if nCount == 0 then print(C.GRY .. "  (empty)" .. C.R) end
end

local function cmd_audit(nMax)
  nMax = tonumber(nMax) or 20
  local bOk, tLog = netctl("nf_audit", {})
  if not bOk or not tLog then
    print(C.YLW .. "No audit log available" .. C.R)
    return
  end

  print(C.CYN .. "Network Audit Log (last " .. math.min(nMax, #tLog) .. ")" .. C.R)
  print(C.GRY .. string.rep("-", 70) .. C.R)

  local nStart = math.max(1, #tLog - nMax + 1)
  for i = nStart, #tLog do
    local e = tLog[i]
    local sAC = C.GRN
    if e.sAction:find("DENY") then sAC = C.RED
    elseif e.sAction:find("LOG") then sAC = C.YLW end

    print(string.format("  %s%.1f%s %s%-10s%s %-4s %-20s:%-5d PID=%-3d UID=%-3d %s",
          C.GRY, e.nTime, C.R,
          sAC, e.sAction, C.R,
          e.sProto,
          e.sHost, e.nPort,
          e.nPid, e.nUid,
          C.GRY .. e.sComment .. C.R))
  end
end

local function cmd_stats()
  local bOk, tStats = netctl("nf_stats", {})
  if not bOk or not tStats then
    print(C.YLW .. "No connection stats available" .. C.R)
    return
  end

  print(C.CYN .. "Per-Process Connection Statistics" .. C.R)
  print(C.GRY .. string.rep("-", 45) .. C.R)
  print(string.format("  %s%-5s %-5s %-8s %-12s%s",
        C.GRY, "PID", "UID", "ACTIVE", "TOTAL BYTES", C.R))

  for _, s in ipairs(tStats) do
    local sBytes
    if s.nBytes > 1048576 then
      sBytes = string.format("%.1f MB", s.nBytes / 1048576)
    elseif s.nBytes > 1024 then
      sBytes = string.format("%.1f KB", s.nBytes / 1024)
    else
      sBytes = s.nBytes .. " B"
    end
    print(string.format("  %-5d %-5d %-8d %-12s",
          s.nPid, s.nUid, s.nActive, sBytes))
  end
end

local function cmd_test(sUrl)
  if not sUrl then print("Usage: nfw test <url>"); return end
  print(C.CYN .. "Testing: " .. C.R .. sUrl)

  -- Extract host/port
  local sHost = sUrl:match("^https?://([^/:]+)") or sUrl:match("^([^/:]+)") or sUrl
  local nPort = tonumber(sUrl:match("^https?://[^/:]+:(%d+)")) or 80
  if sUrl:sub(1, 5) == "https" then nPort = 443 end

  print("  Host: " .. sHost)
  print("  Port: " .. nPort)

  -- We can't directly call the policy engine from userspace,
  -- but we can try a dry-run by checking hosts rewriting
  local bHostsOk, tHosts = netctl("nf_hosts", {})
  if bHostsOk and tHosts then
    local sTarget = tHosts[sHost]
    if sTarget then
      if sTarget == "0.0.0.0" or sTarget == "127.0.0.1" then
        print(C.RED .. "  BLOCKED by /etc/hosts" .. C.R)
        return
      else
        print(C.YLW .. "  Rewrites to: " .. sTarget .. C.R)
      end
    end
  end

  print(C.GRN .. "  Would be allowed (based on hosts file)" .. C.R)
  print(C.GRY .. "  Note: full policy check happens at connection time" .. C.R)
end

-- =============================================
-- DISPATCH
-- =============================================

if #tArgs < 1 then cmd_status(); return end

local sCmd = tArgs[1]

if sCmd == "status" then cmd_status()
elseif sCmd == "rules" then cmd_rules()
elseif sCmd == "hosts" then cmd_hosts()
elseif sCmd == "audit" then cmd_audit(tArgs[2])
elseif sCmd == "stats" then cmd_stats()
elseif sCmd == "test" then cmd_test(tArgs[2])

elseif sCmd == "reload" then
  local bOk, sMsg = netctl("nf_reload", {})
  if bOk then print(C.GRN .. "Rules and hosts reloaded" .. C.R)
  else print(C.RED .. "Reload failed" .. C.R) end

elseif sCmd == "enable" then
  netctl("nf_enable", {true})
  print(C.GRN .. "Firewall enabled" .. C.R)

elseif sCmd == "disable" then
  netctl("nf_enable", {false})
  print(C.YLW .. "Firewall disabled" .. C.R)

elseif sCmd == "limit" then
  local n = tonumber(tArgs[2])
  if n then
    netctl("nf_set_limit", {n})
    print("Connection limit set to " .. n .. " per UID")
  else
    print("Usage: nfw limit <number>")
  end

elseif sCmd == "-h" or sCmd == "--help" then
  print(C.CYN .. "nfw" .. C.R .. " - AxisOS Network Firewall Manager")
  print("")
  print("  nfw status             Firewall status")
  print("  nfw rules              List policy rules")
  print("  nfw hosts              List hosts entries")
  print("  nfw audit [n]          Recent audit log")
  print("  nfw stats              Per-process connection stats")
  print("  nfw reload             Reload rules from disk")
  print("  nfw enable/disable     Toggle firewall")
  print("  nfw limit <n>          Per-UID connection limit")
  print("  nfw test <url>         Test URL against policy")

else
  print(C.RED .. "Unknown command: " .. sCmd .. C.R)
  print("Use 'nfw --help' for usage")
end
```


axis-os\src\kernel\usr\commands\ping.lua
```
--
-- /usr/commands/ping.lua
-- TCP-based ping (ICMP not available in OpenComputers)
--
-- Usage: ping [-c count] [-p port] [-t timeout] <host>
--

local net = require("net")
local tArgs = env.ARGS or {}

local C = {
  R = "\27[37m", GRN = "\27[32m", RED = "\27[31m",
  YLW = "\27[33m", CYN = "\27[36m", GRY = "\27[90m",
}

-- parse args
local sHost    = nil
local nCount   = 4
local nPort    = 80
local nTimeout = 5

local i = 1
while i <= #tArgs do
  local a = tArgs[i]
  if a == "-c" then
    i = i + 1; nCount = tonumber(tArgs[i]) or 4
  elseif a == "-p" then
    i = i + 1; nPort = tonumber(tArgs[i]) or 80
  elseif a == "-t" then
    i = i + 1; nTimeout = tonumber(tArgs[i]) or 5
  elseif a == "-h" or a == "--help" then
    print("Usage: ping [-c count] [-p port] [-t timeout] <host>")
    print("  Simulates ICMP ping via TCP connect timing.")
    return
  elseif a:sub(1, 1) ~= "-" then
    sHost = a
  end
  i = i + 1
end

if not sHost then
  print("Usage: ping <host>")
  return
end

print(string.format("%sPING%s %s via TCP port %d (%d probes, %ds timeout)",
      C.CYN, C.R, sHost, nPort, nCount, nTimeout))
print("")

local tResult, sErr = net.ping(sHost, nPort, nCount, nTimeout)

if not tResult then
  print(C.RED .. "Error: " .. C.R .. tostring(sErr))
  return
end

-- individual results
for _, tProbe in ipairs(tResult.tResults or {}) do
  if tProbe.sStatus == "ok" then
    print(string.format("  seq=%d  %s%d ms%s  port=%d",
          tProbe.nSeq, C.GRN, tProbe.nMs, C.R, nPort))
  elseif tProbe.sStatus == "timeout" then
    print(string.format("  seq=%d  %s* timeout *%s  (%d ms)",
          tProbe.nSeq, C.YLW, C.R, tProbe.nMs or 0))
  else
    print(string.format("  seq=%d  %s! error: %s%s",
          tProbe.nSeq, C.RED, tostring(tProbe.sError), C.R))
  end
end

-- summary
print("")
print(string.format("--- %s ping statistics ---", sHost))
print(string.format("%d probes sent, %d received, %s%d%% loss%s",
      tResult.nSent, tResult.nRecv,
      tResult.nLoss > 0 and C.RED or C.GRN,
      tResult.nLoss, C.R))

if tResult.nRecv > 0 then
  print(string.format("rtt min/avg/max = %s%d/%d/%d ms%s",
        C.CYN, tResult.nMinMs, tResult.nAvgMs, tResult.nMaxMs, C.R))
end
```


axis-os\src\kernel\usr\commands\preempt_test.lua
```
--
-- /usr/commands/preempt_test.lua
-- AxisOS Preemptive Multitasking Verification Suite
--
-- Proves that the scheduler provides time-sliced preemption
--
-- Five tests:
--   1. Starvation prevention  — two tight busy loops, NO manual yields
--   2. Three-way fairness     — three identical hog threads
--   3. Main-thread liveness   — CPU hog vs. responsive main loop
--   4. Parallel wall-clock    — 3×0.5 s tasks sequential vs. parallel
--   5. Scheduler statistics   — confirms __pc() preemptions occurred
--
-- Usage:
--   preempt_test              Run full suite
--   preempt_test -v           Verbose (per-iteration detail)
--   preempt_test -h           Help
--

local thread   = require("thread")
local computer = require("computer")
local tArgs    = env.ARGS or {}

-- =============================================
-- ANSI PALETTE
-- =============================================
local C = {
    R   = "\27[37m",  CYN = "\27[36m",  GRN = "\27[32m",
    YLW = "\27[33m",  RED = "\27[31m",   GRY = "\27[90m",
    MAG = "\27[35m",  BLU = "\27[34m",
}

-- =============================================
-- FLAGS
-- =============================================
local bVerbose = false
for _, a in ipairs(tArgs) do
    if a == "-v" or a == "--verbose" then bVerbose = true end
    if a == "-h" or a == "--help" then
        print(C.CYN .. "preempt_test" .. C.R ..
              " — Preemptive multitasking verification suite")
        print("")
        print("  preempt_test        Run all 5 tests")
        print("  preempt_test -v     Verbose output")
        print("  preempt_test -h     This help")
        print("")
        print("Tests:")
        print("  1  Starvation prevention (two busy loops, no yields)")
        print("  2  Three-way CPU fairness")
        print("  3  Main-thread responsiveness under hog load")
        print("  4  Parallel speedup (wall-clock bounded tasks)")
        print("  5  Scheduler statistics delta")
        return
    end
end

-- =============================================
-- RESULT TRACKING
-- =============================================
local nPass, nFail, nWarn = 0, 0, 0

local function pass(s) nPass = nPass + 1; print(C.GRN .. "  [PASS] " .. C.R .. s) end
local function fail(s) nFail = nFail + 1; print(C.RED .. "  [FAIL] " .. C.R .. s) end
local function warn(s) nWarn = nWarn + 1; print(C.YLW .. "  [WARN] " .. C.R .. s) end
local function info(s) print(C.BLU .. "  [INFO] " .. C.R .. s) end
local function verb(s)
    if bVerbose then print(C.GRY .. "  [VERB] " .. s .. C.R) end
end

local function banner(sTitle)
    print("")
    print(C.CYN .. "  " .. string.rep("=", 56) .. C.R)
    print(C.CYN .. "  " .. sTitle .. C.R)
    print(C.CYN .. "  " .. string.rep("=", 56) .. C.R)
end

-- =============================================
-- HELPERS
-- =============================================

-- Wall-clock yield-sleep  (does NOT busy-burn — yields to scheduler)
local function sleep(nSec)
    local nDeadline = computer.uptime() + nSec
    while computer.uptime() < nDeadline do
        syscall("process_yield")
    end
end

-- Wall-clock busy-burn  (DOES consume CPU — used to measure throughput)
local function busyWork(nSeconds)
    local nDeadline = computer.uptime() + nSeconds
    local nCount = 0
    while computer.uptime() < nDeadline do
        nCount = nCount + 1
    end
    return nCount
end

-- =============================================
-- HEADER
-- =============================================

print("")
print(C.CYN .. "  ╔════════════════════════════════════════════════════╗" .. C.R)
print(C.CYN .. "  ║   AxisOS Preemptive Multitasking Test Suite       ║" .. C.R)
print(C.CYN .. "  ║   Method: source instrumentation (__pc)           ║" .. C.R)
print(C.CYN .. "  ║   NO debug.sethook                                ║" .. C.R)
print(C.CYN .. "  ╚════════════════════════════════════════════════════╝" .. C.R)

local nSuiteStart = computer.uptime()

-- =============================================
-- BASELINE SCHEDULER STATS
-- =============================================

local tStatsBefore = syscall("sched_get_stats") or {}
verb("Baseline preemptions: " .. tostring(tStatsBefore.nPreemptions or 0))
verb("Baseline resumes:     " .. tostring(tStatsBefore.nTotalResumes or 0))

-- =============================================================
-- TEST 1 — STARVATION PREVENTION
--
-- Two threads run tight busy loops with NO manual yield calls.
-- In a cooperative-only system thread A would monopolise the
-- CPU and thread B would never execute (or OC would crash the
-- machine with "too long without yielding").
-- With preemption, __pc() yields them both and both counters
-- advance.
-- =============================================================

banner("TEST 1: STARVATION PREVENTION")
info("Two threads with tight busy loops — ZERO manual yields.")
info("Without preemption: one thread starves (or OC crashes).")
info("With preemption:    both threads increment their counters.")
info("Running for 2 seconds...")
print("")

do
    local nCountA = 0
    local nCountB = 0
    local bStop   = false

    local tA = thread.create(function()
        while not bStop do
            nCountA = nCountA + 1
        end
    end)

    local tB = thread.create(function()
        while not bStop do
            nCountB = nCountB + 1
        end
    end)

    sleep(2)
    bStop = true

    if tA then tA:join() end
    if tB then tB:join() end

    verb(string.format("Thread A counted to %d", nCountA))
    verb(string.format("Thread B counted to %d", nCountB))

    if nCountA > 0 and nCountB > 0 then
        pass(string.format(
            "Both threads ran!  A = %d   B = %d", nCountA, nCountB))

        local nHi = math.max(nCountA, nCountB)
        local nLo = math.max(1, math.min(nCountA, nCountB))
        local nRatio = nHi / nLo

        if nRatio < 5 then
            pass(string.format("Fairness ratio %.1f:1  (< 5:1 — good)", nRatio))
        else
            warn(string.format(
                "Fairness ratio %.1f:1  (high, but neither thread starved)", nRatio))
        end
    elseif nCountA > 0 and nCountB == 0 then
        fail("Thread B STARVED (count = 0).  Preemption is NOT working!")
    elseif nCountB > 0 and nCountA == 0 then
        fail("Thread A STARVED (count = 0).  Preemption is NOT working!")
    else
        fail("Both threads stuck at 0.  Something is seriously wrong.")
    end
end

-- =============================================================
-- TEST 2 — THREE-WAY FAIRNESS
--
-- Three identical busy-loop threads.  We check that all three
-- make progress and that the fastest isn't more than ~10x the
-- slowest (a single core can't be perfectly fair but 10:1 is
-- generous).
-- =============================================================

banner("TEST 2: THREE-WAY FAIRNESS")
info("Three identical busy-loop threads competing for one CPU.")
info("Running for 2 seconds...")
print("")

do
    local tCounts = {0, 0, 0}
    local bStop   = false

    local tThreads = {}
    for i = 1, 3 do
        local nIdx = i                       -- capture loop variable
        tThreads[i] = thread.create(function()
            while not bStop do
                tCounts[nIdx] = tCounts[nIdx] + 1
            end
        end)
    end

    sleep(2)
    bStop = true

    for _, t in ipairs(tThreads) do
        if t then t:join() end
    end

    local nMin, nMax, nTotal = math.huge, 0, 0
    local nAlive = 0
    for i = 1, 3 do
        verb(string.format("  Thread %d:  %d iterations", i, tCounts[i]))
        if tCounts[i] > 0 then nAlive = nAlive + 1 end
        if tCounts[i] < nMin then nMin = tCounts[i] end
        if tCounts[i] > nMax then nMax = tCounts[i] end
        nTotal = nTotal + tCounts[i]
    end

    if nAlive == 3 then
        pass(string.format("All 3 threads ran  (total %d iterations)", nTotal))
        local nRatio = nMax / math.max(1, nMin)
        info(string.format("Min = %d   Max = %d   Ratio = %.1f:1",
                           nMin, nMax, nRatio))
        if nRatio < 3 then
            pass("Excellent fairness  (< 3:1)")
        elseif nRatio < 10 then
            pass("Acceptable fairness (< 10:1)")
        else
            warn(string.format(
                "Uneven distribution (%.1f:1) — but all three ran", nRatio))
        end
    else
        fail(nAlive .. "/3 threads ran.  Starvation detected!")
    end
end

-- =============================================================
-- TEST 3 — MAIN-THREAD RESPONSIVENESS
--
-- Spawn a CPU-hog thread and verify the main thread can still
-- execute code (read the clock, increment a counter, yield)
-- while the hog is running.
-- =============================================================

banner("TEST 3: MAIN-THREAD RESPONSIVENESS")
info("Starting a CPU hog, then checking if the main thread")
info("can still execute code alongside it.")
info("Running for 2 seconds...")
print("")

do
    local nHogCount   = 0
    local bStop       = false
    local nMainChecks = 0
    local nStartTime  = computer.uptime()

    local tHog = thread.create(function()
        while not bStop do
            nHogCount = nHogCount + 1
        end
    end)

    local nDeadline = computer.uptime() + 2

    -- Main thread: yield-sleep in a loop, counting how many
    -- times we regain control.  In a cooperative system with
    -- a tight hog, we'd get 0 or 1 check.
    while computer.uptime() < nDeadline do
        nMainChecks = nMainChecks + 1
        local nElapsed = computer.uptime() - nStartTime
        verb(string.format(
            "  Main check #%d  at %.2fs   (hog = %d)",
            nMainChecks, nElapsed, nHogCount))
        syscall("process_yield")
    end

    bStop = true
    if tHog then tHog:join() end

    local nElapsed = computer.uptime() - nStartTime
    info(string.format("Main thread executed %d checks in %.2fs",
                       nMainChecks, nElapsed))
    info(string.format("Hog thread counted to %d", nHogCount))

    if nMainChecks >= 10 then
        pass("Main thread highly responsive  (" ..
             nMainChecks .. " checks)")
    elseif nMainChecks >= 3 then
        pass("Main thread responsive  (" .. nMainChecks .. " checks)")
    elseif nMainChecks >= 1 then
        warn("Main thread sluggish  (" .. nMainChecks .. " checks)")
    else
        fail("Main thread got ZERO checks — hog monopolised CPU!")
    end

    if nHogCount > 0 then
        pass("Hog thread also made progress  (" ..
             nHogCount .. " iterations)")
    else
        warn("Hog thread didn't count at all  (scheduling anomaly)")
    end
end

-- =============================================================
-- TEST 4 — PARALLEL WALL-CLOCK SPEEDUP
--
-- Sequential:  run 3 × busyWork(0.5 s)  one after another.
-- Parallel:    run 3 × busyWork(0.5 s)  as threads.
--
-- busyWork counts iterations until a wall-clock deadline.
-- Since the wall clock advances for ALL threads even when they
-- are preempted out, parallel threads all finish at roughly
-- the same wall-clock moment.
--
-- Expected:
--   Sequential  ≈ 1.5 s
--   Parallel    ≈ 0.5 s   →  ~3× speedup
--
-- This speedup is ONLY possible with preemption; without it
-- each thread would run to completion one at a time and the
-- parallel time would also be ≈ 1.5 s.
-- =============================================================

banner("TEST 4: PARALLEL WALL-CLOCK SPEEDUP")
info("Sequential: 3 tasks × 0.5 s each → expect ~1.5 s")
info("Parallel:   3 tasks × 0.5 s each → expect ~0.5 s (preemptive)")
print("")

do
    -- ---- Sequential ----
    local nSeqStart = computer.uptime()
    local nSeqTotal = 0
    for i = 1, 3 do
        nSeqTotal = nSeqTotal + busyWork(0.5)
    end
    local nSeqTime = computer.uptime() - nSeqStart

    -- ---- Parallel ----
    local tParCounts = {0, 0, 0}
    local nParStart  = computer.uptime()

    local tParThreads = {}
    for i = 1, 3 do
        local nIdx = i
        tParThreads[i] = thread.create(function()
            tParCounts[nIdx] = busyWork(0.5)
        end)
    end
    for _, t in ipairs(tParThreads) do
        if t then t:join() end
    end

    local nParTime  = computer.uptime() - nParStart
    local nParTotal = 0
    for i = 1, 3 do nParTotal = nParTotal + tParCounts[i] end

    -- ---- Results ----
    info(string.format("Sequential : %.2f s   (%d iterations total)",
                       nSeqTime, nSeqTotal))
    info(string.format("Parallel   : %.2f s   (%d iterations total)",
                       nParTime, nParTotal))

    verb(string.format("  Thread 1: %d", tParCounts[1]))
    verb(string.format("  Thread 2: %d", tParCounts[2]))
    verb(string.format("  Thread 3: %d", tParCounts[3]))

    local nSpeedup = nSeqTime / math.max(0.001, nParTime)
    info(string.format("Speedup    : %.2f×", nSpeedup))

    if nSpeedup >= 2.0 then
        pass(string.format(
            "%.1f× speedup — threads ran concurrently!  Preemption confirmed.",
            nSpeedup))
    elseif nSpeedup >= 1.3 then
        pass(string.format(
            "%.1f× speedup — measurable concurrency benefit",
            nSpeedup))
    elseif nSpeedup >= 1.05 then
        warn(string.format(
            "Marginal speedup (%.2f×) — preemption present but high overhead",
            nSpeedup))
    else
        fail(string.format(
            "No speedup (%.2f×) — threads appear serialised",
            nSpeedup))
    end

    -- Extra check: in purely sequential execution the parallel
    -- time would be >= sequential time.  Any significant reduction
    -- proves interleaved execution.
    if nParTime < nSeqTime * 0.7 then
        pass(string.format(
            "Parallel time (%.2fs) is < 70%% of sequential (%.2fs)",
            nParTime, nSeqTime))
    end
end

-- =============================================================
-- TEST 5 — SCHEDULER STATISTICS
--
-- Query the kernel's scheduler counters and verify that
-- preemptive yields (__pc-driven) actually occurred during
-- the tests above.
-- =============================================================

banner("TEST 5: SCHEDULER STATISTICS")
print("")

do
    local tStatsAfter = syscall("sched_get_stats") or {}

    local nPreemptDelta = (tStatsAfter.nPreemptions    or 0)
                        - (tStatsBefore.nPreemptions    or 0)
    local nResumeDelta  = (tStatsAfter.nTotalResumes   or 0)
                        - (tStatsBefore.nTotalResumes   or 0)
    local nWdWarnings   = tStatsAfter.nWatchdogWarnings or 0
    local nWdKills      = tStatsAfter.nWatchdogKills    or 0
    local nMaxSlice     = tStatsAfter.nMaxSliceMs       or 0

    info(string.format("Scheduler resumes during test : %d", nResumeDelta))
    info(string.format("Preemptive yields (__pc)      : %d", nPreemptDelta))
    info(string.format("Watchdog warnings             : %d", nWdWarnings))
    info(string.format("Watchdog kills                : %d", nWdKills))
    info(string.format("Max single slice              : %.2f ms", nMaxSlice))

    if tStatsAfter.nInstrumentedFiles then
        print("")
        info(string.format("Source files instrumented      : %d",
             tStatsAfter.nInstrumentedFiles))
        info(string.format("__pc() checkpoints injected    : %d",
             tStatsAfter.nInjectedCheckpoints or 0))
        info(string.format("Quantum setting                : %d ms",
             tStatsAfter.nQuantumMs or 50))
        info(string.format("Check interval                 : %d calls",
             tStatsAfter.nCheckInterval or 256))
    end

    -- ---- Verdicts ----
    print("")

    if nPreemptDelta > 100 then
        pass(string.format(
            "%d preemptive yields — heavy time-slicing confirmed!", nPreemptDelta))
    elseif nPreemptDelta > 0 then
        pass(string.format(
            "%d preemptive yields — scheduler IS preempting.", nPreemptDelta))
    else
        fail("Zero preemptive yields detected.  Scheduler is cooperative-only!")
    end

    if nResumeDelta > 50 then
        pass(string.format(
            "%d total resumes — scheduler actively multiplexing", nResumeDelta))
    end

    if nWdKills == 0 then
        pass("No watchdog kills — all processes yielded within limits")
    else
        warn(nWdKills .. " process(es) killed by watchdog")
    end

    if nMaxSlice < 200 then
        pass(string.format(
            "Max slice %.1f ms — well within OC's 5 s hard limit", nMaxSlice))
    elseif nMaxSlice < 2000 then
        warn(string.format("Max slice %.1f ms — a bit high", nMaxSlice))
    else
        fail(string.format(
            "Max slice %.1f ms — dangerously close to OC timeout!", nMaxSlice))
    end

    -- Per-process CPU stats for our own PID
    local nMyPid = syscall("process_get_pid")
    local tMyCpu = syscall("process_cpu_stats", nMyPid)
    if tMyCpu and bVerbose then
        print("")
        verb(string.format("Our PID:           %d", nMyPid))
        verb(string.format("Our CPU time:      %.3f s", tMyCpu.nCpuTime or 0))
        verb(string.format("Our preempt count: %d", tMyCpu.nPreemptCount or 0))
        verb(string.format("Our max slice:     %.2f ms",
             (tMyCpu.nMaxSlice or 0) * 1000))
        verb(string.format("Our watchdog hits: %d", tMyCpu.nWatchdogStrikes or 0))
    end
end

-- =============================================================
-- SUMMARY
-- =============================================================

local nSuiteTime = computer.uptime() - nSuiteStart

banner("SUMMARY")
print("")
print(string.format("  %sPassed :%s  %d",   C.GRN, C.R, nPass))
print(string.format("  %sFailed :%s  %d",   C.RED, C.R, nFail))
print(string.format("  %sWarned :%s  %d",   C.YLW, C.R, nWarn))
print(string.format("  %sTime   :%s  %.2f s", C.GRY, C.R, nSuiteTime))
print("")

if nFail == 0 then
    print(C.GRN .. "  ╔══════════════════════════════════════════════════╗" .. C.R)
    print(C.GRN .. "  ║                                                  ║" .. C.R)
    print(C.GRN .. "  ║   PREEMPTIVE MULTITASKING: VERIFIED              ║" .. C.R)
    print(C.GRN .. "  ║                                                  ║" .. C.R)
    print(C.GRN .. "  ║   Method : source-code instrumentation (__pc)    ║" .. C.R)
    print(C.GRN .. "  ║   Safety : server-safe, no debug library abuse   ║" .. C.R)
    print(C.GRN .. "  ║                                                  ║" .. C.R)
    print(C.GRN .. "  ╚══════════════════════════════════════════════════╝" .. C.R)
elseif nFail <= 2 then
    print(C.YLW .. "  ╔══════════════════════════════════════════════════╗" .. C.R)
    print(C.YLW .. "  ║   PREEMPTIVE MULTITASKING: PARTIAL               ║" .. C.R)
    print(C.YLW .. "  ║   Some tests failed — review output above.       ║" .. C.R)
    print(C.YLW .. "  ╚══════════════════════════════════════════════════╝" .. C.R)
else
    print(C.RED .. "  ╔══════════════════════════════════════════════════╗" .. C.R)
    print(C.RED .. "  ║   PREEMPTIVE MULTITASKING: NOT WORKING           ║" .. C.R)
    print(C.RED .. "  ║   Multiple failures — check kernel/preempt.lua   ║" .. C.R)
    print(C.RED .. "  ╚══════════════════════════════════════════════════╝" .. C.R)
end

print("")
```


axis-os\src\kernel\usr\commands\printenv.lua
```
-- printenv - show environment variables
if not env then print("(no environment)"); return end
local tKeys = {}
for k in pairs(env) do
  if type(env[k]) ~= "table" and type(env[k]) ~= "function" then
    table.insert(tKeys, k)
  end
end
table.sort(tKeys)
for _, k in ipairs(tKeys) do
  print("\27[33m" .. k .. "\27[37m=" .. tostring(env[k]))
end
```


axis-os\src\kernel\usr\commands\provision.lua
```
-- /usr/commands/provision.lua
-- AxisOS Secure Boot Provisioning Tool
--
-- This tool:
--   1. Generates or imports Platform Key
--   2. Computes machine binding
--   3. Hashes the current kernel
--   4. Writes EEPROM boot code with embedded constants
--   5. Optionally SEALS the EEPROM (PERMANENT, IRREVERSIBLE)
--
-- Usage:
--   provision                 Interactive provisioning
--   provision --status        Show current security state
--   provision --seal          Seal after provisioning (PERMANENT)
--   provision --update-hash   Update kernel hash only (before sealing)
--

local fs = require("filesystem")
local crypto = require("crypto")
local sys = require("syscall")
local tArgs = env.ARGS or {}

local C = {
  R="\27[37m", GRN="\27[32m", RED="\27[31m",
  CYN="\27[36m", YLW="\27[33m", GRY="\27[90m",
  MAG="\27[35m", BLU="\27[34m"
}

-- =============================================
-- DETECT HARDWARE
-- =============================================

local function getComponentProxy(sType)
    local tList = {}
    local bOk, _ = pcall(function()
        for addr in component.list(sType) do tList[addr] = true end
    end)
    if not bOk then
        pcall(function()
            for addr in raw_component.list(sType) do tList[addr] = true end
        end)
    end
    for addr in pairs(tList) do
        local p
        pcall(function() p = component.proxy(addr) end)
        if not p then pcall(function() p = raw_component.proxy(addr) end) end
        if p then return p, addr end
    end
    return nil
end

local oEeprom, sEepromAddr = getComponentProxy("eeprom")
local oData, sDataAddr = getComponentProxy("data")
local oFs, sFsAddr = getComponentProxy("filesystem")

local function to_hex(s)
    if not s then return "nil" end
    local t = {}
    for i = 1, math.min(#s, 64) do
        t[i] = string.format("%02x", s:byte(i))
    end
    return table.concat(t)
end

-- =============================================
-- STATUS CHECK
-- =============================================

if tArgs[1] == "--status" then
    print(C.CYN .. "=== AxisOS Secure Boot Status ===" .. C.R)
    print("")
    
    -- EEPROM
    if oEeprom then
        local sLabel = oEeprom.getLabel() or "(unlabeled)"
        local bReadonly = false
        -- There's no direct "isReadonly" check, but we can try writing
        -- Actually, we should NOT try writing. Check the data area instead.
        local sData = oEeprom.getData()
        print("  EEPROM:     " .. C.GRN .. "Present" .. C.R .. " [" .. sLabel .. "]")
        print("  EEPROM Addr: " .. C.GRY .. sEepromAddr .. C.R)
        
        if sData and #sData >= 64 then
            print("  Data Area:  " .. C.GRN .. #sData .. " bytes populated" .. C.R)
            print("  Binding:    " .. C.MAG .. to_hex(sData:sub(1,32)):sub(1,16) .. "..." .. C.R)
        else
            print("  Data Area:  " .. C.YLW .. "Empty (not provisioned)" .. C.R)
        end
    else
        print("  EEPROM:     " .. C.RED .. "NOT FOUND" .. C.R)
    end
    
    -- Data Card
    if oData then
        local nTier = 1
        if oData.ecdsa then nTier = 3 elseif oData.encrypt then nTier = 2 end
        print("  Data Card:  " .. C.GRN .. "Tier " .. nTier .. C.R)
        print("  Card Addr:  " .. C.GRY .. sDataAddr .. C.R)
    else
        print("  Data Card:  " .. C.RED .. "NOT FOUND (security degraded)" .. C.R)
    end
    
    -- Filesystem
    if oFs then
        print("  Root FS:    " .. C.GRN .. "Present" .. C.R)
        print("  FS Addr:    " .. C.GRY .. sFsAddr .. C.R)
    end
    
    -- Kernel hash
    if oFs and oData then
        local kh = oFs.open("/kernel.lua", "r")
        if kh then
            local chunks = {}
            while true do
                local chunk = oFs.read(kh, 8192)
                if not chunk then break end
                chunks[#chunks+1] = chunk
            end
            oFs.close(kh)
            local hash = to_hex(oData.sha256(table.concat(chunks)))
            print("  Kernel Hash: " .. C.CYN .. hash:sub(1,32) .. "..." .. C.R)
        end
    end
    
    -- Boot manifest
    if oFs then
        local mh = oFs.open("/boot/manifest.sig", "r")
        if mh then
            oFs.close(mh)
            print("  Manifest:   " .. C.GRN .. "Present" .. C.R)
        else
            print("  Manifest:   " .. C.YLW .. "Missing" .. C.R)
        end
    end
    
    print("")
    return
end

-- =============================================
-- PROVISION
-- =============================================

print("")
print(C.CYN .. "╔══════════════════════════════════════════════╗" .. C.R)
print(C.CYN .. "║  AxisOS Secure Boot Provisioning Tool        ║" .. C.R)
print(C.CYN .. "╚══════════════════════════════════════════════╝" .. C.R)
print("")

-- Checks
if not oEeprom then
    print(C.RED .. "FATAL: No EEPROM component found." .. C.R)
    return
end
if not oData then
    print(C.RED .. "FATAL: No Data Card found. Tier 3 required for full security." .. C.R)
    return
end
if not oFs then
    print(C.RED .. "FATAL: No filesystem." .. C.R)
    return
end

local nTier = 1
if oData.ecdsa then nTier = 3 elseif oData.encrypt then nTier = 2 end
if nTier < 3 then
    print(C.YLW .. "WARNING: Data Card is Tier " .. nTier ..
          ". Tier 3 required for ECDSA signatures." .. C.R)
    print(C.YLW .. "Proceeding with hash-only verification." .. C.R)
end

print(C.GRN .. "[1/5]" .. C.R .. " Computing machine binding...")
local machine_binding = to_hex(oData.sha256(
    sDataAddr .. sEepromAddr .. sFsAddr
))
print("  Binding: " .. C.MAG .. machine_binding:sub(1,16) .. "..." .. C.R)

print(C.GRN .. "[2/5]" .. C.R .. " Hashing kernel...")
local kh = fs.open("/kernel.lua", "r")
if not kh then print(C.RED .. "FATAL: /kernel.lua not found" .. C.R); return end
local chunks = {}
while true do
    local chunk = fs.read(kh, 8192)
    if not chunk then break end
    chunks[#chunks+1] = chunk
end
fs.close(kh)
local kernel_hash = to_hex(oData.sha256(table.concat(chunks)))
print("  Kernel: " .. C.CYN .. kernel_hash:sub(1,16) .. "..." .. C.R)

print(C.GRN .. "[3/5]" .. C.R .. " Platform Key...")
local pk_fp = "NONE"
if nTier >= 3 then
    -- Check for existing PK
    local pkFile = oFs.open("/etc/signing/platform.pub", "r")
    if pkFile then
        local pkData = ""
        while true do
            local c = oFs.read(pkFile, 4096)
            if not c then break end
            pkData = pkData .. c
        end
        oFs.close(pkFile)
        pk_fp = to_hex(oData.sha256(pkData))
        print("  PK Fingerprint: " .. C.MAG .. pk_fp:sub(1,16) .. "..." .. C.R)
    else
        print("  " .. C.YLW .. "No platform key found. Generate with: sign -g" .. C.R)
    end
end

print(C.GRN .. "[4/5]" .. C.R .. " Boot manifest hash...")
local manifest_hash = "NONE"
local mh = oFs.open("/boot/manifest.sig", "r")
if mh then
    local mdata = ""
    while true do
        local c = oFs.read(mh, 8192)
        if not c then break end
        mdata = mdata .. c
    end
    oFs.close(mh)
    manifest_hash = to_hex(oData.sha256(mdata))
    print("  Manifest: " .. C.CYN .. manifest_hash:sub(1,16) .. "..." .. C.R)
else
    print("  " .. C.YLW .. "No manifest. Create with: manifest --generate" .. C.R)
end

-- Read the EEPROM boot template
print(C.GRN .. "[5/5]" .. C.R .. " Reading boot ROM template...")
local bh = oFs.open("/boot/eeprom_template.lua", "r")
if not bh then
    print(C.RED .. "FATAL: /boot/eeprom_template.lua not found" .. C.R)
    print("  Place the sealed EEPROM boot code template at this path.")
    return
end
local boot_template = ""
while true do
    local c = oFs.read(bh, 4096)
    if not c then break end
    boot_template = boot_template .. c
end
oFs.close(bh)

-- Replace placeholders
local boot_code = boot_template
boot_code = boot_code:gsub("%%%%PK_FP%%%%", pk_fp)
boot_code = boot_code:gsub("%%%%KERN_H%%%%", kernel_hash)
boot_code = boot_code:gsub("%%%%MACH_B%%%%", machine_binding)
boot_code = boot_code:gsub("%%%%MANIF_H%%%%", manifest_hash)

if #boot_code > 4096 then
    print(C.RED .. "FATAL: Boot code too large (" .. #boot_code ..
          " bytes, max 4096)" .. C.R)
    return
end

print("")
print(C.YLW .. "  Boot code size: " .. #boot_code .. " / 4096 bytes" .. C.R)
print("")
print(C.CYN .. "╔══════════════════════════════════════════════╗" .. C.R)
print(C.CYN .. "║  PROVISIONING SUMMARY                        ║" .. C.R)
print(C.CYN .. "╠══════════════════════════════════════════════╣" .. C.R)
print(C.CYN .. "║" .. C.R .. "  Machine Binding: " ..
      C.MAG .. machine_binding:sub(1,24) .. "..." .. C.CYN .. "  ║" .. C.R)
print(C.CYN .. "║" .. C.R .. "  Kernel Hash:     " ..
      C.GRN .. kernel_hash:sub(1,24) .. "..." .. C.CYN .. "  ║" .. C.R)
print(C.CYN .. "║" .. C.R .. "  Platform Key:    " ..
      (pk_fp ~= "NONE" and (C.GRN .. pk_fp:sub(1,24) .. "...") or (C.YLW .. "NONE")) ..
      C.CYN .. "  ║" .. C.R)
print(C.CYN .. "╚══════════════════════════════════════════════╝" .. C.R)

print("")
print(C.RED .. "  WARNING: This will overwrite the EEPROM." .. C.R)
print(C.RED .. "  Type 'PROVISION' to confirm:" .. C.R)
io.write("  > ")
local confirm = io.read()
if confirm ~= "PROVISION" then
    print(C.YLW .. "Aborted." .. C.R)
    return
end

-- Write EEPROM
print("")
print("  Writing EEPROM code...")
oEeprom.set(boot_code)

-- Write EEPROM data area (binary packed binding info)
local eeprom_data = machine_binding:sub(1,64)  -- 64 hex chars = 32 bytes binding
-- Pad to use data area efficiently
while #eeprom_data < 256 do
    eeprom_data = eeprom_data .. "\0"
end
oEeprom.setData(eeprom_data)

oEeprom.setLabel("AxisOS SecureBoot v1.0")

print(C.GRN .. "  EEPROM written successfully." .. C.R)

-- === SEAL ===
if tArgs[1] == "--seal" then
    print("")
    print(C.RED .. "  ╔═══════════════════════════════════════╗" .. C.R)
    print(C.RED .. "  ║  SEALING EEPROM                       ║" .. C.R)
    print(C.RED .. "  ║  THIS IS PERMANENT AND IRREVERSIBLE   ║" .. C.R)
    print(C.RED .. "  ║                                       ║" .. C.R)
    print(C.RED .. "  ║  The EEPROM can NEVER be modified     ║" .. C.R)
    print(C.RED .. "  ║  again on this hardware.              ║" .. C.R)
    print(C.RED .. "  ╚═══════════════════════════════════════╝" .. C.R)
    print("")
    print(C.RED .. "  Type 'SEAL' to make EEPROM read-only:" .. C.R)
    io.write("  > ")
    local seal_confirm = io.read()
    
    if seal_confirm == "SEAL" then
        -- Compute checksum for makeReadonly
        local checksum = oData.sha256(boot_code)
        local bOk, sErr = pcall(function()
            oEeprom.makeReadonly(checksum)
        end)
        
        if bOk then
            print(C.GRN .. "" .. C.R)
            print(C.GRN .. "  EEPROM SEALED SUCCESSFULLY" .. C.R)
            print(C.GRN .. "  This machine now has an immutable root of trust." .. C.R)
            print(C.GRN .. "" .. C.R)
        else
            print(C.RED .. "  Seal failed: " .. tostring(sErr) .. C.R)
        end
    else
        print(C.YLW .. "  Seal cancelled. EEPROM is written but NOT sealed." .. C.R)
        print(C.YLW .. "  Run 'provision --seal' when ready." .. C.R)
    end
else
    print("")
    print(C.YLW .. "  EEPROM is writable (not sealed)." .. C.R)
    print(C.YLW .. "  To seal permanently: provision --seal" .. C.R)
end

print("")
```


axis-os\src\kernel\usr\commands\ps.lua
```
local tProcs = syscall("process_list")
if not tProcs then print("ps: failed"); return end

print(string.format("%-5s %-5s %-6s %-10s %s", "PID", "PPID", "RING", "STATUS", "IMAGE"))
for _, p in ipairs(tProcs) do
    print(string.format("%-5d %-5d %-6s %-10s %s",
        p.pid, p.parent, tostring(p.ring), p.status, p.image))
end
```


axis-os\src\kernel\usr\commands\reboot.lua
```
local sys = require("syscall")
local ring = syscall("process_get_ring")

if ring == 2.5 or ring == 0 then
  sys.write("Rebooting...\n")
  sys.reboot()
else
  sys.write("reboot: Permission denied (must be root)\n")
end

```


axis-os\src\kernel\usr\commands\reg.lua
```
--
-- /usr/commands/reg.lua
-- AxisOS Registry CLI — query, set, delete, tree
--
-- Usage:
--   reg query <path>             List subkeys and values
--   reg get <path> <name>        Get a specific value
--   reg set <path> <name> <val>  Set a value (Ring 2+ only)
--   reg tree [path]              Print full tree
--   reg info <path>              Key metadata
--   reg find <search>            Search key names
--

local tArgs = env.ARGS or {}

local C = {
  R = "\27[37m", RED = "\27[31m", GRN = "\27[32m", YLW = "\27[33m",
  BLU = "\27[34m", CYN = "\27[36m", GRY = "\27[90m", MAG = "\27[35m",
}

local function usage()
  print(C.CYN .. "reg" .. C.R .. " - AxisOS Virtual Registry Tool")
  print("")
  print("Usage:")
  print("  reg query <path>             List subkeys and values")
  print("  reg get <path> <name>        Get a specific value")
  print("  reg set <path> <name> <val>  Set a value")
  print("  reg tree [path] [depth]      Print tree")
  print("  reg info <path>              Key metadata")
  print("  reg find <term>              Search key names")
  print("")
  print("Paths start with @VT\\  e.g. @VT\\DEV  @VT\\DRV\\AxisTTY")
end

local function typeColor(sType)
  if sType == "STR" then return C.GRN
  elseif sType == "NUM" then return C.YLW
  elseif sType == "BOOL" then return C.MAG
  else return C.GRY end
end

local function formatValue(v)
  if type(v) == "table" then return "{...}" end
  return tostring(v)
end

local function cmd_query(sPath)
  if not sPath then print("reg query: missing path"); return end
  local bExists = syscall("reg_key_exists", sPath)
  if not bExists then
    print(C.RED .. "Key not found: " .. C.R .. sPath)
    return
  end

  print(C.CYN .. "Key: " .. C.R .. sPath)
  print("")

  -- subkeys
  local tKeys = syscall("reg_enum_keys", sPath)
  if tKeys and #tKeys > 0 then
    print(C.GRY .. "  Subkeys:" .. C.R)
    for _, sKey in ipairs(tKeys) do
      print("    " .. C.BLU .. sKey .. C.R)
    end
    print("")
  end

  -- values
  local tVals = syscall("reg_enum_values", sPath)
  if tVals and #tVals > 0 then
    print(C.GRY .. "  Values:" .. C.R)
    print(string.format("    %-24s %-6s %s", C.GRY .. "Name" .. C.R,
          C.GRY .. "Type" .. C.R, C.GRY .. "Data" .. C.R))
    print("    " .. C.GRY .. string.rep("-", 55) .. C.R)
    for _, tVal in ipairs(tVals) do
      local sTC = typeColor(tVal.sType)
      local sValStr = formatValue(tVal.value)
      if #sValStr > 40 then sValStr = sValStr:sub(1, 37) .. "..." end
      print(string.format("    %-24s %s%-6s%s %s",
            tVal.sName, sTC, tVal.sType, C.R, sValStr))
    end
  end

  if (not tKeys or #tKeys == 0) and (not tVals or #tVals == 0) then
    print(C.GRY .. "  (empty key)" .. C.R)
  end
end

local function cmd_get(sPath, sName)
  if not sPath or not sName then print("reg get: missing path or name"); return end
  local vVal, sType = syscall("reg_get_value", sPath, sName)
  if vVal ~= nil then
    local sTC = typeColor(sType)
    print(string.format("%s%s%s = %s (%s%s%s)",
          C.CYN, sName, C.R, formatValue(vVal), sTC, sType, C.R))
  else
    print(C.RED .. "Value not found: " .. C.R .. sName .. " in " .. sPath)
  end
end

local function cmd_set(sPath, sName, sValue)
  if not sPath or not sName or not sValue then
    print("reg set: missing path, name, or value"); return
  end
  -- auto-detect type
  local vVal = sValue
  local sType = "STR"
  local nNum = tonumber(sValue)
  if nNum then vVal = nNum; sType = "NUM"
  elseif sValue == "true" then vVal = true; sType = "BOOL"
  elseif sValue == "false" then vVal = false; sType = "BOOL"
  end

  -- ensure key exists
  syscall("reg_create_key", sPath)
  local bOk = syscall("reg_set_value", sPath, sName, vVal, sType)
  if bOk then
    print(C.GRN .. "[OK]" .. C.R .. " " .. sName .. " = " .. formatValue(vVal))
  else
    print(C.RED .. "[FAIL]" .. C.R .. " Could not set value (access denied?)")
  end
end

local function cmd_tree(sPath, nMaxDepth)
  sPath = sPath or "@VT"
  nMaxDepth = tonumber(nMaxDepth) or 10
  local tTree = syscall("reg_dump_tree", sPath, nMaxDepth)
  if not tTree or #tTree == 0 then
    print(C.RED .. "Key not found or empty: " .. C.R .. sPath)
    return
  end

  print(C.CYN .. "Registry Tree: " .. C.R .. sPath)
  print("")

  for _, tNode in ipairs(tTree) do
    local sIndent = string.rep("  ", tNode.nDepth)
    local sIcon = tNode.nSubKeys > 0 and "+" or "-"
    local sExtra = ""
    if tNode.nValues > 0 then
      sExtra = C.GRY .. " (" .. tNode.nValues .. " values)" .. C.R
    end
    print(string.format("%s%s%s %s%s%s",
          sIndent, C.YLW, sIcon, C.BLU, tNode.sName, C.R) .. sExtra)
  end
end

local function cmd_info(sPath)
  if not sPath then print("reg info: missing path"); return end
  local tInfo = syscall("reg_query_info", sPath)
  if not tInfo then
    print(C.RED .. "Key not found: " .. C.R .. sPath)
    return
  end
  print(C.CYN .. "Key Info: " .. C.R .. sPath)
  print("  Name:       " .. tInfo.sName)
  print("  Subkeys:    " .. tInfo.nSubKeys)
  print("  Values:     " .. tInfo.nValues)
  print("  Created:    " .. string.format("%.4f", tInfo.nCreated or 0))
  print("  Modified:   " .. string.format("%.4f", tInfo.nModified or 0))
end

local function cmd_find(sTerm)
  if not sTerm then print("reg find: missing search term"); return end
  local sLower = sTerm:lower()
  local tTree = syscall("reg_dump_tree", "@VT", 20)
  local nFound = 0
  for _, tNode in ipairs(tTree) do
    if tNode.sName:lower():find(sLower, 1, true) or
       tNode.sPath:lower():find(sLower, 1, true) then
      print(C.GRN .. "  " .. tNode.sPath .. C.R)
      nFound = nFound + 1
    end
  end
  if nFound == 0 then
    print(C.GRY .. "  No matches for '" .. sTerm .. "'" .. C.R)
  else
    print(C.GRY .. "  " .. nFound .. " match(es)" .. C.R)
  end
end

-- =============================================
-- DISPATCH
-- =============================================

if #tArgs < 1 then usage(); return end

local sCmd = tArgs[1]

if sCmd == "query"    then cmd_query(tArgs[2])
elseif sCmd == "get"  then cmd_get(tArgs[2], tArgs[3])
elseif sCmd == "set"  then cmd_set(tArgs[2], tArgs[3], tArgs[4])
elseif sCmd == "tree" then cmd_tree(tArgs[2], tArgs[3])
elseif sCmd == "info" then cmd_info(tArgs[2])
elseif sCmd == "find" then cmd_find(tArgs[2])
elseif sCmd == "-h" or sCmd == "--help" then usage()
else
  print(C.RED .. "Unknown command: " .. C.R .. sCmd)
  usage()
end
```


axis-os\src\kernel\usr\commands\regedit.lua
```
--
-- /usr/commands/regedit.lua
-- AxisOS Visual Registry Editor v2
-- Batched rendering — single write per frame.
--
-- Controls:
--   Up/Down      Navigate
--   Right/Enter  Expand node
--   Left         Collapse / go to parent
--   Tab          Switch panel (Tree <-> Values)
--   R            Refresh
--   Q/Ctrl+C     Quit
--   /            Search (type then Enter)
--   F5           Force full refresh
--

local fs  = require("filesystem")
local sys = require("syscall")

-- =============================================
-- TERMINAL SETUP
-- =============================================

local hStdin  = fs.open("/dev/tty", "r")
local hStdout = fs.open("/dev/tty", "w")
if not hStdin or not hStdout then print("regedit: cannot open /dev/tty"); return end

local nWidth, nHeight = 80, 25
local bOkSize, tSize = fs.deviceControl(hStdin, "get_size", {})
if bOkSize and type(tSize) == "table" then
  nWidth  = tSize.w or 80
  nHeight = tSize.h or 25
end

fs.deviceControl(hStdin, "set_mode", {"raw"})

local function cleanup()
  fs.deviceControl(hStdin, "set_mode", {"cooked"})
  fs.write(hStdout, "\27[0m\27[2J\27[1;1H")
  fs.flush(hStdout)
  fs.close(hStdin)
  fs.close(hStdout)
end

-- =============================================
-- FRAME BUFFER
-- All rendering goes into this table.
-- One concat + one write at the end of each frame.
-- =============================================

local tFrameBuf = {}
local nFrameParts = 0

local function fbReset()
  tFrameBuf = {}
  nFrameParts = 0
end

local function fb(s)
  nFrameParts = nFrameParts + 1
  tFrameBuf[nFrameParts] = s
end

local function fbCursor(x, y)
  nFrameParts = nFrameParts + 1
  tFrameBuf[nFrameParts] = "\27[" .. y .. ";" .. x .. "H"
end

local function fbFlush()
  local sFrame = table.concat(tFrameBuf)
  fs.write(hStdout, sFrame)
  fs.flush(hStdout)
  fbReset()
end

-- =============================================
-- INPUT (non-blocking-ish via raw mode)
-- =============================================

local function readKey()
  return fs.read(hStdin)
end

-- =============================================
-- ANSI CONSTANTS
-- =============================================

local A = {
  RESET   = "\27[0m",
  R       = "\27[37m",
  RED     = "\27[31m",
  GRN     = "\27[32m",
  YLW     = "\27[33m",
  BLU     = "\27[34m",
  MAG     = "\27[35m",
  CYN     = "\27[36m",
  GRY     = "\27[90m",
  INV     = "\27[7m",
  NINV    = "\27[27m",
  CLR     = "\27[2J",
  HOME    = "\27[1;1H",
}

-- =============================================
-- STRING HELPERS
-- =============================================

local function padRight(s, n)
  local sLen = #s
  if sLen >= n then return s:sub(1, n) end
  return s .. string.rep(" ", n - sLen)
end

-- strip ANSI for length calculation
local function visLen(s)
  return #(s:gsub("\27%[[%d;]*[a-zA-Z]", ""))
end

-- pad a string that may contain ANSI codes
local function padRightAnsi(s, n)
  local nVis = visLen(s)
  if nVis >= n then return s end
  return s .. string.rep(" ", n - nVis)
end

-- =============================================
-- STATE
-- =============================================

local tExpanded   = { ["@VT"] = true }
local nTreeSel    = 1
local nTreeScroll = 0
local nValSel     = 1
local nValScroll  = 0
local bTreeFocus  = true
local bRunning    = true
local sSearchTerm = nil

-- =============================================
-- LAYOUT
-- =============================================

local HEADER_H = 2
local STATUS_H = 2
local TREE_W   = math.floor(nWidth * 0.38)
if TREE_W < 22 then TREE_W = 22 end
local VAL_X    = TREE_W + 2
local VAL_W    = nWidth - VAL_X + 1
if VAL_W < 20 then VAL_W = 20 end
local BODY_TOP = HEADER_H + 1
local BODY_H   = nHeight - HEADER_H - STATUS_H
local BODY_BOT = BODY_TOP + BODY_H - 1

-- =============================================
-- DATA MODEL
-- =============================================

local tVisibleTree   = {}
local tCurrentValues = {}

local function buildTree()
  tVisibleTree = {}

  local function walk(sPath, nDepth)
    local tKeys = syscall("reg_enum_keys", sPath)
    if not tKeys then return end
    for _, sKey in ipairs(tKeys) do
      local sChild = sPath .. "\\" .. sKey
      local tChildKeys = syscall("reg_enum_keys", sChild)
      local bHas = tChildKeys and #tChildKeys > 0
      local bExp = tExpanded[sChild] or false

      -- search filter
      local bShow = true
      if sSearchTerm then
        local sLower = sChild:lower()
        if not sLower:find(sSearchTerm, 1, true) then
          -- check if any descendant matches
          local tDesc = syscall("reg_dump_tree", sChild, 5)
          bShow = false
          if tDesc then
            for _, tN in ipairs(tDesc) do
              if tN.sPath:lower():find(sSearchTerm, 1, true) then
                bShow = true; break
              end
            end
          end
        end
      end

      if bShow then
        table.insert(tVisibleTree, {
          nDepth       = nDepth,
          sName        = sKey,
          sPath        = sChild,
          bExpanded    = bExp,
          bHasChildren = bHas,
        })
        if bExp then walk(sChild, nDepth + 1) end
      end
    end
  end

  local tRootKeys = syscall("reg_enum_keys", "@VT")
  table.insert(tVisibleTree, {
    nDepth       = 0,
    sName        = "@VT",
    sPath        = "@VT",
    bExpanded    = true,
    bHasChildren = tRootKeys and #tRootKeys > 0,
  })
  walk("@VT", 1)
end

local function loadValues()
  tCurrentValues = {}
  nValSel = 1
  nValScroll = 0
  if nTreeSel < 1 or nTreeSel > #tVisibleTree then return end
  local sPath = tVisibleTree[nTreeSel].sPath
  local tVals = syscall("reg_enum_values", sPath)
  if tVals then tCurrentValues = tVals end
end

-- =============================================
-- RENDERING (all into frame buffer)
-- =============================================

local function renderHeader()
  fbCursor(1, 1)
  fb(A.INV)
  local sTitle = "  AxisOS Registry Editor"
  local sPanel = bTreeFocus and " [Tree] " or " [Values] "
  local sSearch = sSearchTerm and (" Filter: " .. sSearchTerm .. " ") or ""
  local sLine = sTitle .. sPanel .. sSearch
  fb(padRight(sLine, nWidth))
  fb(A.NINV .. A.R)

  fbCursor(1, 2)
  local sPath = ""
  if nTreeSel >= 1 and nTreeSel <= #tVisibleTree then
    sPath = tVisibleTree[nTreeSel].sPath
  end
  local sInfo = ""
  if nTreeSel >= 1 and nTreeSel <= #tVisibleTree then
    local tI = syscall("reg_query_info", tVisibleTree[nTreeSel].sPath)
    if tI then
      sInfo = A.GRY .. " [" .. tI.nSubKeys .. " keys, " .. tI.nValues .. " vals]" .. A.R
    end
  end
  local sPathLine = A.GRY .. " " .. A.CYN .. sPath .. sInfo
  fb(padRightAnsi(sPathLine, nWidth))
end

local function renderTree()
  for screenRow = 1, BODY_H do
    local screenY = BODY_TOP + screenRow - 1
    fbCursor(1, screenY)

    local nIdx = screenRow + nTreeScroll
    if nIdx >= 1 and nIdx <= #tVisibleTree then
      local tNode = tVisibleTree[nIdx]
      local bSel = (nIdx == nTreeSel)

      -- build the line
      local sIndent = string.rep("  ", tNode.nDepth)
      local sIcon
      if not tNode.bHasChildren then
        sIcon = "-"
      elseif tNode.bExpanded then
        sIcon = "v"
      else
        sIcon = ">"
      end

      local sLabel = tNode.sName
      local nMax = TREE_W - #sIndent - 3
      if nMax < 4 then nMax = 4 end
      if #sLabel > nMax then sLabel = sLabel:sub(1, nMax - 2) .. ".." end

      -- colorize
      if bSel and bTreeFocus then
        -- selected + focused: yellow inverse-ish
        fb(A.YLW)
        fb(padRight(sIndent .. sIcon .. " " .. sLabel, TREE_W))
        fb(A.R)
      elseif bSel then
        -- selected but not focused: gray highlight
        fb(A.GRY)
        fb(padRight(sIndent .. sIcon .. " " .. sLabel, TREE_W))
        fb(A.R)
      else
        -- normal: icon gray, name blue
        fb(A.GRY .. sIndent .. sIcon .. " " .. A.BLU .. sLabel .. A.R)
        -- pad remainder
        local nUsed = #sIndent + 2 + #sLabel
        if nUsed < TREE_W then
          fb(string.rep(" ", TREE_W - nUsed))
        end
      end
    else
      fb(string.rep(" ", TREE_W))
    end
  end
end

local function renderDivider()
  for screenRow = 1, BODY_H do
    fbCursor(TREE_W + 1, BODY_TOP + screenRow - 1)
    fb(A.GRY .. "|" .. A.R)
  end
end

local function typeColor(sType)
  if sType == "NUM" then return A.YLW
  elseif sType == "BOOL" then return A.MAG
  elseif sType == "TAB" then return A.CYN
  else return A.GRN end
end

local function renderValues()
  -- column header
  fbCursor(VAL_X, BODY_TOP)
  local sHdr = A.GRY
  local sN = "Name"
  local sT = "Type"
  local sV = "Value"
  -- fixed column widths
  local COL_NAME = 22
  local COL_TYPE = 6
  local COL_VAL  = VAL_W - COL_NAME - COL_TYPE - 2

  sHdr = sHdr .. padRight(sN, COL_NAME) .. padRight(sT, COL_TYPE) .. sV
  fb(padRight(sHdr, VAL_W) .. A.R)

  fbCursor(VAL_X, BODY_TOP + 1)
  fb(A.GRY .. string.rep("-", VAL_W) .. A.R)

  local nDataTop = BODY_TOP + 2
  local nDataH   = BODY_BOT - nDataTop + 1
  if nDataH < 1 then nDataH = 1 end

  for i = 1, nDataH do
    local screenY = nDataTop + i - 1
    fbCursor(VAL_X, screenY)

    local nIdx = i + nValScroll
    if nIdx >= 1 and nIdx <= #tCurrentValues then
      local tVal = tCurrentValues[nIdx]
      local bSel = (nIdx == nValSel) and not bTreeFocus

      local sName = tVal.sName or "?"
      if #sName > COL_NAME - 1 then sName = sName:sub(1, COL_NAME - 4) .. "..." end

      local sType = tVal.sType or "?"
      local sTC   = typeColor(sType)

      local sValue = tostring(tVal.value or "")
      if type(tVal.value) == "table" then sValue = "{...}" end
      if COL_VAL > 0 and #sValue > COL_VAL then
        sValue = sValue:sub(1, COL_VAL - 3) .. "..."
      end

      if bSel then
        fb(A.YLW)
        fb(padRight(sName, COL_NAME))
        fb(padRight(sType, COL_TYPE))
        fb(padRight(sValue, math.max(0, COL_VAL)))
        fb(A.R)
      else
        fb(padRight(sName, COL_NAME))
        fb(sTC .. padRight(sType, COL_TYPE) .. A.R)
        fb(padRight(sValue, math.max(0, COL_VAL)))
      end
    else
      fb(string.rep(" ", VAL_W))
    end
  end
end

local function renderStatus()
  fbCursor(1, nHeight - 1)
  fb(A.GRY .. string.rep("-", nWidth) .. A.R)

  fbCursor(1, nHeight)
  fb(A.INV)

  local sHelp = " Up/Dn:Move L/R:Expand Tab:Panel /:Search R:Refresh Q:Quit"
  local sInfo = string.format(" %d/%d keys  %d vals ",
        nTreeSel, #tVisibleTree, #tCurrentValues)

  local nPad = nWidth - #sHelp - #sInfo
  if nPad < 0 then nPad = 0 end
  fb(sHelp .. string.rep(" ", nPad) .. sInfo)
  fb(A.NINV .. A.R)
end

local function render()
  fbReset()
  fb(A.RESET .. A.CLR .. A.HOME)
  renderHeader()
  renderTree()
  renderDivider()
  renderValues()
  renderStatus()
  fbFlush()
end

-- =============================================
-- SCROLL HELPERS
-- =============================================

local function ensureTreeVisible()
  if nTreeSel < nTreeScroll + 1 then
    nTreeScroll = nTreeSel - 1
  end
  if nTreeSel > nTreeScroll + BODY_H then
    nTreeScroll = nTreeSel - BODY_H
  end
  if nTreeScroll < 0 then nTreeScroll = 0 end
end

local function ensureValVisible()
  local nDataH = math.max(1, BODY_H - 2)
  if nValSel < nValScroll + 1 then
    nValScroll = nValSel - 1
  end
  if nValSel > nValScroll + nDataH then
    nValScroll = nValSel - nDataH
  end
  if nValScroll < 0 then nValScroll = 0 end
end

-- =============================================
-- SEARCH
-- =============================================

local function doSearch()
  -- show a prompt on the status bar
  fbReset()
  fbCursor(1, nHeight)
  fb(A.INV .. padRight(" Search: ", nWidth) .. A.NINV .. A.R)
  fbCursor(10, nHeight)
  fbFlush()

  -- switch back to cooked mode for line input
  fs.deviceControl(hStdin, "set_mode", {"cooked"})
  fs.deviceControl(hStdin, "set_buffer", {""})

  local sInput = fs.read(hStdin)

  -- back to raw mode
  fs.deviceControl(hStdin, "set_mode", {"raw"})

  if sInput then
    sInput = sInput:gsub("\n", ""):gsub("\r", "")
    if #sInput > 0 then
      sSearchTerm = sInput:lower()
    else
      sSearchTerm = nil
    end
  else
    sSearchTerm = nil
  end

  buildTree()
  nTreeSel = 1
  nTreeScroll = 0
  loadValues()
end

-- =============================================
-- INPUT
-- =============================================

local function handleInput(sKey)
  if not sKey then return end

  if sKey == "\3" or sKey == "q" or sKey == "Q" then
    bRunning = false; return
  end

  if sKey == "\t" then
    bTreeFocus = not bTreeFocus; return
  end

  if sKey == "r" or sKey == "R" or sKey == "\27[15~" then -- R or F5
    sSearchTerm = nil
    buildTree()
    if nTreeSel > #tVisibleTree then nTreeSel = #tVisibleTree end
    if nTreeSel < 1 then nTreeSel = 1 end
    loadValues()
    return
  end

  if sKey == "/" then
    doSearch(); return
  end

  if bTreeFocus then
    -- === TREE ===
    if sKey == "\27[A" then -- Up
      nTreeSel = math.max(1, nTreeSel - 1)
      ensureTreeVisible(); loadValues()

    elseif sKey == "\27[B" then -- Down
      nTreeSel = math.min(#tVisibleTree, nTreeSel + 1)
      ensureTreeVisible(); loadValues()

    elseif sKey == "\27[C" or sKey == "\n" then -- Right / Enter
      if nTreeSel >= 1 and nTreeSel <= #tVisibleTree then
        local tN = tVisibleTree[nTreeSel]
        if tN.bHasChildren and not tN.bExpanded then
          tExpanded[tN.sPath] = true
          buildTree(); loadValues()
        elseif not tN.bHasChildren then
          -- leaf: switch to values panel
          bTreeFocus = false
        end
      end

    elseif sKey == "\27[D" then -- Left
      if nTreeSel >= 1 and nTreeSel <= #tVisibleTree then
        local tN = tVisibleTree[nTreeSel]
        if tN.bExpanded then
          tExpanded[tN.sPath] = nil
          buildTree(); loadValues()
        elseif nTreeSel > 1 then
          local nD = tN.nDepth
          for i = nTreeSel - 1, 1, -1 do
            if tVisibleTree[i].nDepth < nD then
              nTreeSel = i
              ensureTreeVisible(); loadValues()
              break
            end
          end
        end
      end

    elseif sKey == "\27[5~" then -- PgUp
      nTreeSel = math.max(1, nTreeSel - BODY_H)
      ensureTreeVisible(); loadValues()

    elseif sKey == "\27[6~" then -- PgDn
      nTreeSel = math.min(#tVisibleTree, nTreeSel + BODY_H)
      ensureTreeVisible(); loadValues()

    elseif sKey == "\27[H" then -- Home
      nTreeSel = 1; nTreeScroll = 0; loadValues()

    elseif sKey == "\27[F" then -- End
      nTreeSel = #tVisibleTree; ensureTreeVisible(); loadValues()
    end

  else
    -- === VALUES ===
    if sKey == "\27[A" then
      nValSel = math.max(1, nValSel - 1); ensureValVisible()
    elseif sKey == "\27[B" then
      nValSel = math.min(#tCurrentValues, nValSel + 1); ensureValVisible()
    elseif sKey == "\27[5~" then
      nValSel = math.max(1, nValSel - math.max(1, BODY_H - 2)); ensureValVisible()
    elseif sKey == "\27[6~" then
      nValSel = math.min(#tCurrentValues, nValSel + math.max(1, BODY_H - 2)); ensureValVisible()
    elseif sKey == "\27[D" then -- Left: back to tree
      bTreeFocus = true
    end
  end
end

-- =============================================
-- MAIN
-- =============================================

local function main()
  -- auto-expand top-level hives
  tExpanded["@VT\\DEV"] = true
  tExpanded["@VT\\DRV"] = true
  tExpanded["@VT\\SYS"] = true
  buildTree()
  loadValues()

  while bRunning do
    render()
    local sKey = readKey()
    if sKey then
      handleInput(sKey)
    else
      bRunning = false
    end
  end
end

local bOk, sErr = pcall(main)
cleanup()
if not bOk then
  print("regedit crashed: " .. tostring(sErr))
end
```


axis-os\src\kernel\usr\commands\rm.lua
```
-- rm - remove files and directories
local fs = require("filesystem")
local tArgs = env.ARGS or {}
if #tArgs == 0 then print("Usage: rm [-r] <file> [...]"); return end

local bRecursive = false
local tFiles = {}
for _, a in ipairs(tArgs) do
  if a == "-r" or a == "-rf" or a == "-f" then bRecursive = true
  else table.insert(tFiles, a) end
end

for _, sArg in ipairs(tFiles) do
  local sPath = sArg
  if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. "/" .. sPath end
  sPath = sPath:gsub("//", "/")
  if sPath == "/" or sPath == "/dev" or sPath == "/etc" then
    print("rm: refusing to remove '" .. sPath .. "'"); goto next
  end
  local bOk = fs.remove(sPath)
  if not bOk then print("rm: cannot remove '" .. sArg .. "'") end
  ::next::
end
```


axis-os\src\kernel\usr\commands\sched.lua
```
--
-- /usr/commands/sched.lua
-- AxisOS Preemptive Scheduler Diagnostics
--
-- Usage:
--   sched              Show global scheduler stats
--   sched -p           Include per-process CPU stats
--   sched -v           Verbose (include instrumentation info)
--

local tArgs = env.ARGS or {}

local C = {
    R = "\27[37m", CYN = "\27[36m", GRN = "\27[32m",
    YLW = "\27[33m", RED = "\27[31m", GRY = "\27[90m",
}

local bProcs   = false
local bVerbose = false
for _, a in ipairs(tArgs) do
    if a == "-p" or a == "--procs"   then bProcs   = true end
    if a == "-v" or a == "--verbose" then bVerbose = true end
    if a == "-h" or a == "--help" then
        print(C.CYN .. "sched" .. C.R .. " — Preemptive scheduler diagnostics")
        print("  sched            Global stats")
        print("  sched -p         Per-process CPU stats")
        print("  sched -v         Include instrumentation info")
        return
    end
end

local tStats = syscall("sched_get_stats")
if not tStats then
    print("sched: could not retrieve scheduler stats")
    return
end

print(C.CYN .. "AxisOS Preemptive Scheduler" .. C.R)
print(C.GRY .. string.rep("-", 50) .. C.R)

print(string.format("  Total resumes:        %s%d%s",
    C.GRN, tStats.nTotalResumes or 0, C.R))
print(string.format("  Preemptive yields:    %s%d%s",
    C.YLW, tStats.nPreemptions or 0, C.R))
print(string.format("  Watchdog warnings:    %s%d%s",
    (tStats.nWatchdogWarnings or 0) > 0 and C.RED or C.GRN,
    tStats.nWatchdogWarnings or 0, C.R))
print(string.format("  Watchdog kills:       %s%d%s",
    (tStats.nWatchdogKills or 0) > 0 and C.RED or C.GRN,
    tStats.nWatchdogKills or 0, C.R))
print(string.format("  Max single slice:     %s%.2f ms%s",
    C.YLW, tStats.nMaxSliceMs or 0, C.R))

if bVerbose and tStats.nInstrumentedFiles then
    print("")
    print(C.CYN .. "Instrumentation" .. C.R)
    print(string.format("  Files instrumented:   %d", tStats.nInstrumentedFiles))
    print(string.format("  Checkpoints injected: %d", tStats.nInjectedCheckpoints or 0))
    print(string.format("  Quantum:              %d ms", tStats.nQuantumMs or 50))
    print(string.format("  Check interval:       %d calls", tStats.nCheckInterval or 256))
end

if bProcs then
    print("")
    print(C.CYN .. "Per-Process CPU Statistics" .. C.R)
    print(string.format("  %s%-5s %-8s %-8s %-10s %-8s %-4s  %s%s",
        C.GRY, "PID", "CPU(s)", "Preempt", "Last(ms)", "Max(ms)", "WD", "IMAGE", C.R))
    print("  " .. C.GRY .. string.rep("-", 65) .. C.R)

    local tProcs = syscall("process_list")
    if tProcs then
        for _, p in ipairs(tProcs) do
            local tCpu = syscall("process_cpu_stats", p.pid)
            if tCpu then
                local sWdColor = tCpu.nWatchdogStrikes > 0 and C.RED or C.GRN
                print(string.format(
                    "  %-5d %-8.3f %-8d %-10.2f %-8.2f %s%-4d%s  %s",
                    p.pid,
                    tCpu.nCpuTime or 0,
                    tCpu.nPreemptCount or 0,
                    (tCpu.nLastSlice or 0) * 1000,
                    (tCpu.nMaxSlice or 0) * 1000,
                    sWdColor, tCpu.nWatchdogStrikes or 0, C.R,
                    p.image or "?"))
            end
        end
    end
end

print("")
print(C.GRY .. "Usage: sched [-p] [-v]  |  sched -h for help" .. C.R)
```


axis-os\src\kernel\usr\commands\shutdown.lua
```
-- shutdown - halt the system
local sys = require("syscall")
print("System going down NOW!")
sys.shutdown()
```


axis-os\src\kernel\usr\commands\sign.lua
```
-- /usr/commands/sign.lua
-- Sign a driver file with your ECDSA private key
--
-- Usage:
--   sign <driver_path>                 Sign with default key
--   sign -g                            Generate new key pair
--   sign -r                            Register public key with cloud PKI
--   sign -k <keyfile> <driver_path>    Sign with specific key
--

local fs = require("filesystem")
local crypto = require("crypto")
local sys = require("syscall")
local tArgs = env.ARGS or {}

local C = {R="\27[37m", GRN="\27[32m", RED="\27[31m", CYN="\27[36m", YLW="\27[33m", GRY="\27[90m"}

local KEY_DIR = "/etc/signing"
local PRIV_KEY_FILE = KEY_DIR .. "/private.key"
local PUB_KEY_FILE = KEY_DIR .. "/public.key"

-- Init crypto
local bOk, nTier = crypto.Init()
if not bOk then
    print(C.RED .. "ERROR: Data card not found. Cannot sign." .. C.R)
    return
end
if nTier < 3 then
    print(C.RED .. "ERROR: Tier 3 data card required for signing. (Current: Tier " .. nTier .. ")" .. C.R)
    return
end

-- === GENERATE KEY PAIR ===
if tArgs[1] == "-g" or tArgs[1] == "--generate" then
    print(C.CYN .. "Generating ECDSA-384 key pair..." .. C.R)
    
    local oPub, oPriv = crypto.GenerateKeyPair(384)
    if not oPub or not oPriv then
        print(C.RED .. "Key generation failed!" .. C.R)
        return
    end
    
    -- Create directory
    fs.mkdir(KEY_DIR)
    
    -- Save private key
    local hPriv = fs.open(PRIV_KEY_FILE, "w")
    if hPriv then
        fs.write(hPriv, crypto.SerializeKey(oPriv))
        fs.close(hPriv)
        fs.chmod(PRIV_KEY_FILE, 600)  -- owner-only
        print(C.GRN .. "[OK]" .. C.R .. " Private key: " .. PRIV_KEY_FILE)
    end
    
    -- Save public key
    local sPubB64 = crypto.SerializeKey(oPub)
    local hPub = fs.open(PUB_KEY_FILE, "w")
    if hPub then
        fs.write(hPub, sPubB64)
        fs.close(hPub)
        print(C.GRN .. "[OK]" .. C.R .. " Public key:  " .. PUB_KEY_FILE)
    end
    
    -- Show fingerprint
    local sFp = crypto.Encode64(crypto.SHA256(sPubB64))
    print("")
    print(C.YLW .. "Fingerprint: " .. C.R .. sFp)
    print(C.GRY .. "Register this key: sign -r" .. C.R)
    return
end

-- === REGISTER KEY WITH CLOUD ===
if tArgs[1] == "-r" or tArgs[1] == "--register" then
    print(C.CYN .. "Registering public key with PKI..." .. C.R)
    
    local hPub = fs.open(PUB_KEY_FILE, "r")
    if not hPub then
        print(C.RED .. "No public key found. Run: sign -g" .. C.R)
        return
    end
    local sPubB64 = fs.read(hPub, math.huge)
    fs.close(hPub)
    
    local pki = require("pki_client")
    pki.LoadConfig()
    
    local bRegOk, sMsg = pki.RegisterKey(sPubB64, "ECDSA-384")
    if bRegOk then
        print(C.GRN .. "[OK]" .. C.R .. " Key submitted for approval")
        print(C.GRY .. "An admin must approve it on pki.axis-os.ru" .. C.R)
    else
        print(C.RED .. "[FAIL]" .. C.R .. " " .. tostring(sMsg))
    end
    return
end

-- === SIGN A DRIVER ===
local sDriverPath = tArgs[1]
if tArgs[1] == "-k" then
    PRIV_KEY_FILE = tArgs[2]
    PUB_KEY_FILE = tArgs[2]:gsub("private", "public") -- convention
    sDriverPath = tArgs[3]
end

if not sDriverPath then
    print(C.CYN .. "sign" .. C.R .. " - AxisOS Driver Signing Tool")
    print("  sign <driver>     Sign a driver file")
    print("  sign -g           Generate ECDSA key pair")
    print("  sign -r           Register key with cloud PKI")
    print("  sign -k <key> <driver>  Sign with specific key")
    return
end

-- Resolve path
if sDriverPath:sub(1,1) ~= "/" then
    sDriverPath = (env.PWD or "/") .. "/" .. sDriverPath
end

-- Read driver code
local hDrv = fs.open(sDriverPath, "r")
if not hDrv then
    print(C.RED .. "File not found: " .. sDriverPath .. C.R); return
end
local sCode = fs.read(hDrv, math.huge)
fs.close(hDrv)

-- Strip any existing signature block
local tLines = {}
for line in sCode:gmatch("[^\n]+") do
    if not line:match("^%-%-@SIGNATURE:") and
       not line:match("^%-%-@SIGNER:") and
       not line:match("^%-%-@HASH:") then
        tLines[#tLines + 1] = line
    end
end
local sCleanCode = table.concat(tLines, "\n")

-- Load private key
local hPriv = fs.open(PRIV_KEY_FILE, "r")
if not hPriv then
    print(C.RED .. "No private key. Run: sign -g" .. C.R); return
end
local sPrivB64 = fs.read(hPriv, math.huge)
fs.close(hPriv)
local oPrivKey = crypto.DeserializeKey(sPrivB64, "ec-private")

-- Load public key for fingerprint
local hPub = fs.open(PUB_KEY_FILE, "r")
local sPubB64 = hPub and fs.read(hPub, math.huge) or ""
if hPub then fs.close(hPub) end
local sFingerprint = crypto.Encode64(crypto.SHA256(sPubB64))

-- Compute hash and sign
local sHash = crypto.Encode64(crypto.SHA256(sCleanCode))
local sSig = crypto.Sign(sCleanCode, oPrivKey)
local sSigB64 = crypto.Encode64(sSig)

-- Write signed file
local hOut = fs.open(sDriverPath, "w")
if not hOut then
    print(C.RED .. "Cannot write to " .. sDriverPath .. C.R); return
end
fs.write(hOut, sCleanCode .. "\n")
fs.write(hOut, "--@HASH:" .. sHash .. "\n")
fs.write(hOut, "--@SIGNER:" .. sFingerprint .. "\n")
fs.write(hOut, "--@SIGNATURE:" .. sSigB64 .. "\n")
fs.close(hOut)

print(C.GRN .. "[SIGNED]" .. C.R .. " " .. sDriverPath)
print("  Hash:    " .. sHash:sub(1, 16) .. "...")
print("  Signer:  " .. sFingerprint:sub(1, 16) .. "...")
print("  Sig:     " .. sSigB64:sub(1, 16) .. "...")
```


axis-os\src\kernel\usr\commands\smltr_debug.lua
```
--
-- /usr/commands/smltr_debug.lua
-- sMLTR Verbose Debug Program for AxisOS
-- "Synapse Message Layer Token Randomization - trust no handle."
--
-- Usage:
--   smltr_debug              Full diagnostic suite
--   smltr_debug -t           Token info only
--   smltr_debug -h           Handle table only  (NOTE: -h is handles, --help for help)
--   smltr_debug -o           Object directory only
--   smltr_debug -r           Token rotation test
--   smltr_debug -v           Extra verbose
--   smltr_debug -a           All tests + stress
--   smltr_debug --help       Help
--

local fs   = require("filesystem")
local sys  = require("syscall")
local tArgs = env.ARGS or {}

-- =============================================
-- ANSI
-- =============================================

local C = {
  RESET   = "\27[37m",
  RED     = "\27[31m",
  GREEN   = "\27[32m",
  YELLOW  = "\27[33m",
  BLUE    = "\27[34m",
  MAGENTA = "\27[35m",
  CYAN    = "\27[36m",
  GRAY    = "\27[90m",
  WHITE   = "\27[37m",
}

-- =============================================
-- FLAGS
-- =============================================

local bTokenOnly    = false
local bHandleOnly   = false
local bObjectOnly   = false
local bRotateTest   = false
local bExtraVerbose = false
local bRunAll       = false
local bShowHelp     = false

for _, sArg in ipairs(tArgs) do
  if sArg == "-t" then bTokenOnly = true
  elseif sArg == "-h" then bHandleOnly = true
  elseif sArg == "-o" then bObjectOnly = true
  elseif sArg == "-r" then bRotateTest = true
  elseif sArg == "-v" then bExtraVerbose = true
  elseif sArg == "-a" then bRunAll = true; bExtraVerbose = true
  elseif sArg == "--help" then bShowHelp = true
  end
end

local bDefaultMode = not (bTokenOnly or bHandleOnly or bObjectOnly or bRotateTest or bRunAll)
if bDefaultMode then bRunAll = true end

-- =============================================
-- OUTPUT HELPERS  (all use io.write/print — unbuffered)
-- =============================================

local nTestsPassed = 0
local nTestsFailed = 0
local nTestsWarned = 0
local nTotalChecks = 0

local function hline(nWidth)
  return string.rep("-", nWidth or 58)
end

local function banner(sTitle)
  local sBar = hline(58)
  print("")
  print(C.CYAN .. "  " .. sBar .. C.RESET)
  print(C.CYAN .. "  " .. sTitle .. C.RESET)
  print(C.CYAN .. "  " .. sBar .. C.RESET)
end

local function section(sTitle)
  print("")
  print(C.YELLOW .. "  >> " .. sTitle .. C.RESET)
  print(C.GRAY .. "  " .. string.rep("-", 50) .. C.RESET)
end

local function field(sLabel, vValue, sColor)
  local sC = sColor or C.WHITE
  print(string.format("  %-22s %s%s%s",
    C.GRAY .. sLabel .. ":" .. C.RESET,
    sC, tostring(vValue or "nil"), C.RESET))
end

local function pass(sMsg)
  nTestsPassed = nTestsPassed + 1
  nTotalChecks = nTotalChecks + 1
  print(C.GREEN .. "  [PASS] " .. C.RESET .. sMsg)
end

local function fail(sMsg)
  nTestsFailed = nTestsFailed + 1
  nTotalChecks = nTotalChecks + 1
  print(C.RED .. "  [FAIL] " .. C.RESET .. sMsg)
end

local function warn(sMsg)
  nTestsWarned = nTestsWarned + 1
  nTotalChecks = nTotalChecks + 1
  print(C.YELLOW .. "  [WARN] " .. C.RESET .. sMsg)
end

local function info(sMsg)
  print(C.BLUE .. "  [INFO] " .. C.RESET .. sMsg)
end

local function verbose(sMsg)
  if bExtraVerbose then
    print(C.GRAY .. "  [VERB] " .. sMsg .. C.RESET)
  end
end

local function hex_dump_token(sToken)
  if not sToken or not bExtraVerbose then return end
  local tHex = {}
  local nMax = math.min(#sToken, 32)
  for i = 1, nMax do
    tHex[i] = string.format("%02X", string.byte(sToken, i))
  end
  verbose("Hex: " .. table.concat(tHex, " ") .. (#sToken > 32 and " ..." or ""))
end

-- =============================================
-- TIMING (safe — no require("computer") which may not exist)
-- =============================================

local function uptime()
  -- os.clock is always in the sandbox
  return os.clock()
end

-- =============================================
-- HELP
-- =============================================

local function print_help()
  print("")
  print(C.CYAN .. "smltr_debug" .. C.RESET .. " - sMLTR Verbose Debug Program")
  print(C.GRAY .. "Synapse Message Layer Token Randomization diagnostics" .. C.RESET)
  print("")
  print("Usage: smltr_debug [flags]")
  print("")
  print("  (no flags)    Run full diagnostic suite")
  print("  -t            Token inspection only")
  print("  -h            Handle table dump only")
  print("  -o            Object directory dump only")
  print("  -r            Token rotation test")
  print("  -v            Extra verbose (hex dumps)")
  print("  -a            All tests including stress tests")
  print("  --help        This help message")
  print("")
end

if bShowHelp then
  print_help()
  return
end

-- =============================================
-- 1. PROCESS CONTEXT & TOKEN INSPECTION
-- =============================================

local function test_token_inspection()
  banner("SECTION 1: PROCESS CONTEXT & TOKEN INSPECTION")

  section("1.1 Current Process Identity")

  local nPid = syscall("process_get_pid")
  local nRing = syscall("process_get_ring")

  field("PID", nPid, C.CYAN)
  field("Ring Level", nRing, (nRing and nRing <= 1) and C.RED or C.GREEN)
  field("User", env.USER or "(unknown)", C.GREEN)
  field("UID", env.UID, (env.UID and tonumber(env.UID) == 0) and C.RED or C.WHITE)
  field("Home", env.HOME or "(unknown)")
  field("Hostname", env.HOSTNAME or "(unknown)")
  field("PWD", env.PWD or "/")
  field("PATH", env.PATH or "(unset)")

  if nRing == 0 then
    warn("Running in Ring 0 (KERNEL MODE) - full sMLTR bypass!")
  elseif nRing == 1 then
    warn("Running in Ring 1 (PIPELINE) - sMLTR bypass for PID < 20")
  elseif nRing == 2 then
    info("Running in Ring 2 (DRIVER MODE)")
  elseif nRing == 2.5 then
    info("Running in Ring 2.5 (ELEVATED)")
  elseif nRing == 3 then
    pass("Running in Ring 3 (USER MODE) - full sMLTR enforcement")
  end

  section("1.2 Synapse Token Retrieval")

  local sToken = sys.getSynapseToken()

  if sToken then
    pass("Synapse token retrieved successfully")
    field("Token", sToken, C.MAGENTA)
    field("Token Length", #sToken)

    -- Parse: SYN-XXXX-XXXX-XXXX-XXXX
    local sPfx = sToken:sub(1, 4)
    if sPfx == "SYN-" then
      pass("Token has correct SYN- prefix")
      -- Count the segments
      local nDashes = 0
      for i = 1, #sToken do
        if sToken:sub(i, i) == "-" then nDashes = nDashes + 1 end
      end
      if nDashes == 4 then
        pass("Token format valid (4 dashes = 5 segments)")
      else
        warn("Unexpected dash count: " .. nDashes)
      end
    else
      fail("Token prefix INVALID - expected SYN-, got: " .. sPfx)
    end

    hex_dump_token(sToken)
  else
    fail("Failed to retrieve synapse token!")
    info("Kernel may not implement synapse_get_token")
  end

  section("1.3 Token Stability")
  info("Reading token multiple times...")

  local sToken2 = sys.getSynapseToken()
  local sToken3 = sys.getSynapseToken()

  if sToken and sToken2 and sToken3 then
    if sToken == sToken2 and sToken2 == sToken3 then
      pass("Token stable across repeated reads (no unintended rotation)")
    else
      fail("Token CHANGED between reads without rotation!")
      field("Read 1", sToken)
      field("Read 2", sToken2)
      field("Read 3", sToken3)
    end
  end

  section("1.4 sMLTR Bypass Eligibility")
  if nPid then
    if nPid < 20 then
      warn("PID " .. nPid .. " < 20: sMLTR validation BYPASSED")
    else
      pass("PID " .. nPid .. " >= 20: sMLTR validation ENFORCED")
    end
  end
end

-- =============================================
-- 2. HANDLE TABLE INSPECTION
-- =============================================

local function test_handle_table()
  banner("SECTION 2: HANDLE TABLE INSPECTION")

  section("2.1 Standard Handle Probes")
  info("Testing standard I/O handles (-10, -11, -12)...")

  -- Test stdout by writing zero-length string
  -- io.write goes directly to syscall, no pcall needed
  io.write("")  -- zero-length probe
  pass("stdout (-11) write chain functional (zero-length probe OK)")

  -- stdin can't be probed without blocking
  info("stdin (-10) cannot be probed without blocking")

  section("2.2 Handle Token Inspection")
  info("Opening test handles to inspect token structure...")

  local hProbe = fs.open("/dev/tty", "r")
  if hProbe then
    local sTok = hProbe._token
    if sTok then
      pass("Obtained handle token: " .. sTok:sub(1, 20) .. "...")
      local sPfx = sTok:sub(1, 2)
      if sPfx == "H-" then
        pass("Token has correct H- prefix (ObManager handle format)")
      else
        warn("Token prefix is not H-: " .. sPfx)
      end
      hex_dump_token(sTok)
    else
      warn("Handle object has no _token field")
    end
    fs.close(hProbe)
    pass("Handle closed successfully")
  else
    fail("Could not open /dev/tty for handle inspection")
  end

  section("2.3 Handle Collision Test")
  info("Opening multiple handles to check uniqueness...")

  local tTokensSeen = {}
  local nCollisions = 0
  local nHandlesToTest = 10

  for i = 1, nHandlesToTest do
    local hFile = fs.open("/dev/tty", "r")
    if hFile and hFile._token then
      if tTokensSeen[hFile._token] then
        nCollisions = nCollisions + 1
        fail("COLLISION! Token reused: " .. hFile._token:sub(1, 20))
      else
        tTokensSeen[hFile._token] = i
      end
      fs.close(hFile)
    end
  end

  if nCollisions == 0 then
    pass("No collisions across " .. nHandlesToTest .. " handle opens")
  else
    fail(nCollisions .. " collision(s) in " .. nHandlesToTest .. " opens!")
  end

  if bExtraVerbose then
    verbose("All tokens:")
    for sTok, nIdx in pairs(tTokensSeen) do
      verbose(string.format("  [%2d] %s", nIdx, sTok))
    end
  end

  section("2.4 Cross-Handle Isolation")
  info("Two simultaneous opens should produce different tokens...")

  local hA = fs.open("/dev/tty", "r")
  local hB = fs.open("/dev/tty", "r")

  if hA and hB then
    local sTokA = hA._token
    local sTokB = hB._token
    if sTokA and sTokB then
      if sTokA ~= sTokB then
        pass("Different opens produce different tokens")
        verbose("A: " .. sTokA:sub(1, 20))
        verbose("B: " .. sTokB:sub(1, 20))
      else
        fail("Two opens returned SAME token! Isolation failure!")
      end
    else
      warn("Missing _token on one or both handles")
    end
    fs.close(hA)
    fs.close(hB)
  else
    warn("Could not open two handles for isolation test")
  end

  section("2.5 Handle Lifecycle (Open -> Use -> Close -> Use-After-Close)")

  local hLife = fs.open("/dev/tty", "w")
  if hLife then
    local sSaved = hLife._token
    field("Handle", sSaved and (sSaved:sub(1, 20) .. "...") or "N/A")

    -- Write while open (use io.write to avoid buffer issues)
    pass("Handle opened")

    fs.close(hLife)
    pass("Handle closed")

    -- Attempt use-after-close via raw syscall with saved token
    if sSaved then
      local b1, b2, sErr = syscall("vfs_write", sSaved, "UAF_TEST")
      if b1 and b2 then
        fail("USE-AFTER-CLOSE SUCCEEDED! Critical vulnerability!")
      else
        pass("Use-after-close correctly rejected")
        verbose("Rejection: " .. tostring(b2 or sErr))
      end
    end
  else
    warn("Could not open handle for lifecycle test")
  end
end

-- =============================================
-- 3. OBJECT DIRECTORY
-- =============================================

local function test_object_directory()
  banner("SECTION 3: KERNEL OBJECT DIRECTORY")

  local nRing = syscall("process_get_ring")

  section("3.1 VFS /dev Enumeration")

  local tDevList = fs.list("/dev")
  if tDevList and type(tDevList) == "table" then
    pass("/dev listing: " .. #tDevList .. " entries")
    for _, sName in ipairs(tDevList) do
      local sClean = sName
      if sClean:sub(-1) == "/" then sClean = sClean:sub(1, -2) end
      print(string.format("  %s/dev/%-20s%s", C.YELLOW, sClean, C.RESET))
    end
  else
    warn("Could not list /dev")
  end

  section("3.2 Device Reachability")

  local tKnownDevices = { "/dev/tty", "/dev/ringlog", "/dev/gpu0", "/dev/net" }

  for _, sPath in ipairs(tKnownDevices) do
    local hDev = fs.open(sPath, "r")
    if hDev then
      pass(sPath .. " reachable (token: " ..
        (hDev._token and hDev._token:sub(1, 16) .. "..." or "N/A") .. ")")
      fs.close(hDev)
    else
      verbose(sPath .. " not reachable")
    end
  end

  section("3.3 Kernel Object Dump (Ring 0-1 only)")
  if nRing and nRing <= 1 then
    local tObjects = syscall("ob_dump_directory")
    if tObjects and type(tObjects) == "table" then
      pass("Object directory: " .. #tObjects .. " objects")
      print("")
      print(string.format("  %s%-34s %-18s %-5s %-5s%s",
        C.GRAY, "PATH", "TYPE", "REFS", "HNDL", C.RESET))
      print(C.GRAY .. "  " .. string.rep("-", 68) .. C.RESET)

      for _, tObj in ipairs(tObjects) do
        local sP = tObj.sPath or "(null)"
        if #sP > 32 then sP = sP:sub(1, 29) .. "..." end
        local sT = tObj.sType or "?"
        local sTC = C.WHITE
        if sT == "ObpDirectory" then sTC = C.BLUE
        elseif sT == "ObpSymbolicLink" then sTC = C.CYAN
        elseif sT == "IoDeviceObject" then sTC = C.YELLOW
        elseif sT == "IoFileObject" then sTC = C.GREEN
        end
        print(string.format("  %-34s %s%-18s%s %-5d %-5d",
          sP, sTC, sT, C.RESET, tObj.nRefCount or 0, tObj.nHandleCount or 0))
      end
    else
      warn("ob_dump_directory returned nil")
    end
  else
    info("Object dump requires Ring 0-1 (current: " .. tostring(nRing) .. ")")
    info("Log in as 'dev' (Ring 0) for full namespace dump")
  end
end

-- =============================================
-- 4. TOKEN ROTATION TEST
-- =============================================

local function test_token_rotation()
  banner("SECTION 4: sMLTR TOKEN ROTATION TEST")

  local nRing = syscall("process_get_ring")
  local nPid = syscall("process_get_pid")

  section("4.1 Pre-Rotation State")
  local sTokenBefore = sys.getSynapseToken()
  field("Current Token", sTokenBefore and (sTokenBefore:sub(1, 24) .. "...") or "nil", C.MAGENTA)

  if not sTokenBefore then
    fail("Cannot test rotation: no token")
    return
  end

  section("4.2 Rotation Attempt")

  if nRing and nRing <= 1 then
    local sNewToken = syscall("synapse_rotate", nPid)

    if sNewToken then
      pass("Token rotation succeeded")
      field("Old", sTokenBefore:sub(1, 24) .. "...", C.GRAY)
      field("New", sNewToken:sub(1, 24) .. "...", C.GREEN)

      if sNewToken ~= sTokenBefore then
        pass("New token differs from old (entropy confirmed)")
      else
        fail("New token IDENTICAL to old! Entropy failure!")
      end

      local sVerify = sys.getSynapseToken()
      if sVerify == sNewToken then
        pass("get_token returns the rotated token")
      else
        fail("get_token still returns old token!")
      end

      section("4.3 Post-Rotation Handle Test")
      local hPost = fs.open("/dev/tty", "r")
      if hPost then
        pass("New handle creation works after rotation")
        fs.close(hPost)
      else
        warn("Handle creation failed after rotation")
      end
    else
      fail("synapse_rotate returned nil")
    end
  else
    info("Rotation requires Ring 0-1 (current: " .. tostring(nRing) .. ")")
    info("Log in as 'dev' and run: smltr_debug -r -v")

    section("4.3 Token Validation Probe (Ring 0-2)")
    if nRing and nRing <= 2 then
      local sOurs = sys.getSynapseToken()
      local bSelf = syscall("synapse_validate", nPid, sOurs)
      if bSelf then
        pass("Self-validation: own PID + own token accepted")
      else
        fail("Self-validation FAILED!")
      end

      local bFake = syscall("synapse_validate", nPid, "SYN-dead-beef-cafe-babe")
      if not bFake then
        pass("Bogus token correctly rejected")
      else
        fail("Bogus token ACCEPTED! sMLTR is broken!")
      end
    else
      info("Validation probe requires Ring <= 2")
    end
  end
end

-- =============================================
-- 5. HANDLE I/O SECURITY
-- =============================================

local function test_handle_io_security()
  banner("SECTION 5: HANDLE I/O SECURITY TESTS")

  section("5.1 Device IOCTL via sMLTR")

  local hTty = fs.open("/dev/tty", "r")
  if hTty then
    local bOk1, vR1 = fs.deviceControl(hTty, "get_buffer", {})
    if bOk1 then
      pass("deviceControl(get_buffer) succeeded via sMLTR handle")
    else
      verbose("get_buffer: " .. tostring(vR1))
    end

    local bOk2, vR2 = fs.deviceControl(hTty, "get_cursor", {})
    if bOk2 then
      pass("deviceControl(get_cursor) succeeded")
      if type(vR2) == "table" then
        verbose("Cursor: x=" .. tostring(vR2.x) .. " y=" .. tostring(vR2.y))
      end
    end

    fs.close(hTty)
  else
    warn("Could not open /dev/tty for IOCTL test")
  end
end

-- =============================================
-- 6. PROCESS TABLE SURVEY
-- =============================================

local function test_process_enumeration()
  banner("SECTION 6: PROCESS TABLE & sMLTR COVERAGE")

  section("6.1 Active Process List")

  local tProcs = syscall("process_list")
  if not tProcs or type(tProcs) ~= "table" then
    fail("process_list returned nil")
    return
  end

  pass("Processes: " .. #tProcs)
  print("")
  print(string.format("  %s%-5s %-5s %-6s %-10s %-6s %s%s",
    C.GRAY, "PID", "PPID", "RING", "STATUS", "UID", "IMAGE", C.RESET))
  print(C.GRAY .. "  " .. string.rep("-", 60) .. C.RESET)

  local nR0, nR1, nR2, nR3 = 0, 0, 0, 0

  for _, p in ipairs(tProcs) do
    local nR = p.ring or -1
    local sRC = C.WHITE
    if nR == 0 then sRC = C.RED; nR0 = nR0 + 1
    elseif nR == 1 then sRC = C.YELLOW; nR1 = nR1 + 1
    elseif nR == 2 then sRC = C.CYAN; nR2 = nR2 + 1
    elseif nR == 3 then sRC = C.GREEN; nR3 = nR3 + 1
    end
    print(string.format("  %-5d %-5d %s%-6s%s %-10s %-6s %s",
      p.pid, p.parent, sRC, tostring(nR), C.RESET,
      p.status or "?", tostring(p.uid or "?"), p.image or "?"))
  end

  print("")
  section("6.2 Ring Distribution")
  field("Ring 0 (Kernel)", nR0, C.RED)
  field("Ring 1 (Pipeline)", nR1, C.YELLOW)
  field("Ring 2 (Driver)", nR2, C.CYAN)
  field("Ring 3 (User)", nR3, C.GREEN)

  section("6.3 sMLTR Coverage")
  local nBypass = 0
  local nEnforced = 0
  for _, p in ipairs(tProcs) do
    if p.pid < 20 then nBypass = nBypass + 1
    else nEnforced = nEnforced + 1 end
  end

  field("Bypass Eligible", nBypass .. " (PID < 20)", C.YELLOW)
  field("Enforced", nEnforced .. " (PID >= 20)", C.GREEN)

  local nCov = (#tProcs > 0) and math.floor((nEnforced / #tProcs) * 100) or 0
  field("Coverage", nCov .. "%", nCov >= 80 and C.GREEN or C.YELLOW)
end

-- =============================================
-- 7. STRESS TESTS
-- =============================================

local function test_stress()
  banner("SECTION 7: sMLTR STRESS TESTS")

  section("7.1 Rapid Handle Churn")
  info("50 open/close cycles...")

  local nCount = 50
  local nSuccess = 0
  local nFail = 0
  local tAllTokens = {}
  local nStart = uptime()

  for i = 1, nCount do
    local hFile = fs.open("/dev/tty", "r")
    if hFile then
      if hFile._token then
        if tAllTokens[hFile._token] then
          nFail = nFail + 1
        else
          tAllTokens[hFile._token] = true
          nSuccess = nSuccess + 1
        end
      end
      fs.close(hFile)
    else
      nFail = nFail + 1
    end
  end

  local nElapsed = uptime() - nStart

  field("Unique tokens", nSuccess, C.GREEN)
  field("Collisions/fails", nFail, nFail > 0 and C.RED or C.GREEN)
  field("Time", string.format("%.4fs", nElapsed))

  if nFail == 0 then
    pass("All " .. nCount .. " tokens unique")
  else
    fail(nFail .. " issues in " .. nCount .. " operations!")
  end

  section("7.2 Simultaneous Handles")
  info("Opening 20 handles at once...")

  local tOpen = {}
  local nMax = 20
  local nOpened = 0

  for i = 1, nMax do
    local h = fs.open("/dev/tty", "r")
    if h then
      table.insert(tOpen, h)
      nOpened = nOpened + 1
    else
      break
    end
  end

  field("Opened", nOpened .. "/" .. nMax, nOpened == nMax and C.GREEN or C.YELLOW)

  local tSeen = {}
  local nSimColl = 0
  for _, h in ipairs(tOpen) do
    if h._token then
      if tSeen[h._token] then nSimColl = nSimColl + 1 end
      tSeen[h._token] = true
    end
  end

  if nSimColl == 0 then
    pass("All simultaneous handles have unique tokens")
  else
    fail(nSimColl .. " collisions among simultaneous handles!")
  end

  for _, h in ipairs(tOpen) do fs.close(h) end
  pass("All handles closed")

  section("7.3 Token Entropy")

  -- Combine all tokens
  local tAllList = {}
  for sTok in pairs(tAllTokens) do table.insert(tAllList, sTok) end
  for sTok in pairs(tSeen) do table.insert(tAllList, sTok) end

  if #tAllList > 0 then
    local tFreq = {}
    local nTotal = 0
    for _, sTok in ipairs(tAllList) do
      local sHex = ""
      for i = 1, #sTok do
        local c = sTok:sub(i, i)
        -- check if hex char
        local b = string.byte(c)
        if (b >= 48 and b <= 57) or (b >= 97 and b <= 102) or (b >= 65 and b <= 70) then
          sHex = sHex .. c:lower()
        end
      end
      for i = 1, #sHex do
        local ch = sHex:sub(i, i)
        tFreq[ch] = (tFreq[ch] or 0) + 1
        nTotal = nTotal + 1
      end
    end

    local nUnique = 0
    local nMaxF, nMinF = 0, nTotal
    for _, n in pairs(tFreq) do
      nUnique = nUnique + 1
      if n > nMaxF then nMaxF = n end
      if n < nMinF then nMinF = n end
    end

    field("Tokens analyzed", #tAllList)
    field("Hex chars", nTotal)
    field("Unique hex digits", nUnique .. "/16")

    if nUnique >= 14 then
      pass("Good hex coverage (" .. nUnique .. "/16)")
    else
      warn("Low hex coverage: " .. nUnique .. "/16")
    end

    if bExtraVerbose then
      verbose("Frequency table:")
      local tSorted = {}
      for c, n in pairs(tFreq) do table.insert(tSorted, {c = c, n = n}) end
      table.sort(tSorted, function(a, b) return a.c < b.c end)
      for _, t in ipairs(tSorted) do
        local bar = string.rep("#", math.floor((t.n / nMaxF) * 20))
        verbose(string.format("  %s: %3d %s", t.c, t.n, bar))
      end
    end
  end
end

-- =============================================
-- SUMMARY
-- =============================================

local function print_summary()
  banner("sMLTR DIAGNOSTIC SUMMARY")

  print("")
  print(string.format("  %sPassed:%s  %d", C.GREEN, C.RESET, nTestsPassed))
  print(string.format("  %sFailed:%s  %d", C.RED, C.RESET, nTestsFailed))
  print(string.format("  %sWarned:%s  %d", C.YELLOW, C.RESET, nTestsWarned))
  print(string.format("  %sTotal:%s   %d", C.CYAN, C.RESET, nTotalChecks))
  print("")

  if nTestsFailed == 0 then
    print(C.GREEN .. "  ======================================" .. C.RESET)
    print(C.GREEN .. "  sMLTR SUBSYSTEM: ALL CHECKS PASSED" .. C.RESET)
    print(C.GREEN .. "  ======================================" .. C.RESET)
  elseif nTestsFailed <= 2 then
    print(C.YELLOW .. "  ======================================" .. C.RESET)
    print(C.YELLOW .. "  sMLTR SUBSYSTEM: MINOR ISSUES" .. C.RESET)
    print(C.YELLOW .. "  ======================================" .. C.RESET)
  else
    print(C.RED .. "  ======================================" .. C.RESET)
    print(C.RED .. "  sMLTR SUBSYSTEM: CRITICAL ISSUES" .. C.RESET)
    print(C.RED .. "  ======================================" .. C.RESET)
  end

  print("")
  field("Tool", "smltr_debug v1.1.0")
  field("OS", "AxisOS Xen XKA v0.32-alpha1")
  field("Security", "sMLTR + WDM ObManager handles")
  print("")
end

-- =============================================
-- MAIN
-- =============================================

print("")
print(C.CYAN .. "  ==========================================================" .. C.RESET)
print(C.CYAN .. "  sMLTR VERBOSE DEBUG PROGRAM v1.1.0" .. C.RESET)
print(C.CYAN .. "  Synapse Message Layer Token Randomization Diagnostics" .. C.RESET)
print(C.CYAN .. "  AxisOS Xen XKA v0.32-alpha1" .. C.RESET)
print(C.CYAN .. "  ==========================================================" .. C.RESET)

local nStartTime = uptime()

if bTokenOnly or bRunAll then test_token_inspection() end
if bHandleOnly or bRunAll then test_handle_table() end
if bObjectOnly or bRunAll then test_object_directory() end
if bRotateTest or bRunAll then test_token_rotation() end

if bRunAll then
  test_handle_io_security()
  test_process_enumeration()
  test_stress()
end

local nElapsed = uptime() - nStartTime
print("")
field("Runtime", string.format("%.4f seconds", nElapsed))

print_summary()
```


axis-os\src\kernel\usr\commands\su.lua
```
local fs = require("lib/filesystem")

local stdin = { fd = 0 }
local stdout = { fd = 1 }

local function hash(pass)
  return string.reverse(pass) .. "AURA_SALT"
end

local function load_passwd()
  local f = fs.open("/etc/passwd.lua", "r")
  local code = fs.read(f)
  fs.close(f)
  return load(code, "passwd", "t", {})()
end

fs.write(stdout, "Password for root: ")
local pass = fs.read(stdin) -- TODO: secret read

local passwd_db = load_passwd()
local root_hash = passwd_db.root.hash

if hash(pass) == root_hash then
  local ok, err = syscall("process_elevate", 2.5)
  if ok then
    fs.write(stdout, "Elevated to Ring 2.5\n")
    -- We need to re-execute the shell to get the new sandbox
    local ring = syscall("process_get_ring")
    syscall("process_spawn", "/bin/sh.lua", ring, {
      USER = "root",
      HOME = "/home/root",
      UID = 0,
    })
    -- After this, the current 'su' process will exit,
    -- and the parent shell will wait for the *new* shell.
  else
    fs.write(stdout, "Elevation failed: " .. err .. "\n")
  end
else
  fs.write(stdout, "su: Authentication failure\n")
end

```


axis-os\src\kernel\usr\commands\tail.lua
```
-- tail - show last N lines of a file
local fs = require("filesystem")
local tArgs = env.ARGS or {}
local nLines = 10
local sPath = nil
for _, a in ipairs(tArgs) do
  local n = a:match("^%-n(%d+)$") or a:match("^%-(%d+)$")
  if n then nLines = tonumber(n)
  elseif a:sub(1,1) ~= "-" then sPath = a end
end
if not sPath then print("Usage: tail [-n N] <file>"); return end
if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. "/" .. sPath end
sPath = sPath:gsub("//", "/")

local h = fs.open(sPath, "r")
if not h then print("tail: " .. sPath .. ": No such file"); return end
local sData = fs.read(h, math.huge) or ""
fs.close(h)

local tLines = {}
for sLine in (sData .. "\n"):gmatch("([^\n]*)\n") do
  table.insert(tLines, sLine)
end
local nStart = math.max(1, #tLines - nLines + 1)
for i = nStart, #tLines do print(tLines[i]) end
```


axis-os\src\kernel\usr\commands\touch.lua
```
-- touch - create empty file or update timestamp
local fs = require("filesystem")
local tArgs = env.ARGS or {}
if #tArgs == 0 then print("Usage: touch <file> [...]"); return end

for _, sArg in ipairs(tArgs) do
  local sPath = sArg
  if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. "/" .. sPath end
  sPath = sPath:gsub("//", "/")
  local h = fs.open(sPath, "a")
  if h then fs.close(h) else print("touch: cannot touch '" .. sArg .. "'") end
end
```


axis-os\src\kernel\usr\commands\uname.lua
```
local tArgs = env.ARGS or {}
local bAll = false
for _, a in ipairs(tArgs) do if a == "-a" then bAll = true end end

if bAll then
    print("AxisOS Xen XKA 0.3 " .. (env.HOSTNAME or "localhost") .. " Lua5.2 OpenComputers")
else
    print("AxisOS")
end
```


axis-os\src\kernel\usr\commands\uptime.lua
```
-- uptime - show system uptime
local n = computer.uptime()
print(string.format("up %d:%02d:%02d",
  math.floor(n / 3600),
  math.floor((n % 3600) / 60),
  math.floor(n % 60)))
```


axis-os\src\kernel\usr\commands\vi.lua
```
--
-- /usr/commands/vi.lua
-- xvi — AxisOS visual editor
-- Batch-rendered, alt-screen, diff-based updates.
--

local fs = require("filesystem")
local tArgs = env.ARGS or {}

local hIn  = fs.open("/dev/tty", "r")
local hOut = fs.open("/dev/tty", "w")
if not hIn or not hOut then print("vi: no tty"); return end

fs.deviceControl(hIn, "set_mode", {"raw"})
local bSzOk, tSz = fs.deviceControl(hIn, "get_size", {})
local W = (bSzOk and tSz and tSz.w) or 80
local H = (bSzOk and tSz and tSz.h) or 25

-- =============================================
-- SCREEN ABSTRACTION (batch + diff)
-- =============================================

local SCR = {
  prev = {},   -- [y] = change-detection key
  batch = {},  -- pending {x, y, text, fg, bg} ops
}

function SCR.init()
  fs.deviceControl(hIn, "enter_alt_screen", {})
  SCR.prev = {}
end

function SCR.done()
  fs.deviceControl(hIn, "leave_alt_screen", {})
end

function SCR.put(x, y, text, fg, bg)
  SCR.batch[#SCR.batch + 1] = {x, y, text, fg or 0xFFFFFF, bg or 0x000000}
end

-- Write a full row — skip if unchanged since last frame
function SCR.row(y, text, fg, bg)
  fg = fg or 0xFFFFFF; bg = bg or 0x000000
  if #text < W then text = text .. string.rep(" ", W - #text) end
  if #text > W then text = text:sub(1, W) end
  local sKey = text .. tostring(fg) .. tostring(bg)
  if SCR.prev[y] == sKey then return end
  SCR.prev[y] = sKey
  SCR.put(1, y, text, fg, bg)
end

-- Write a multi-segment row (e.g. line number + content)
function SCR.segs(y, tSegs)
  local tK = {}
  for _, s in ipairs(tSegs) do
    tK[#tK + 1] = s[1] .. tostring(s[2] or 0) .. tostring(s[3] or 0)
  end
  local sKey = table.concat(tK, "|")
  if SCR.prev[y] == sKey then return end
  SCR.prev[y] = sKey

  local nX = 1
  for _, s in ipairs(tSegs) do
    SCR.put(nX, y, s[1], s[2] or 0xFFFFFF, s[3] or 0x000000)
    nX = nX + #s[1]
  end
  if nX <= W then
    SCR.put(nX, y, string.rep(" ", W - nX + 1), 0xFFFFFF, 0x000000)
  end
end

function SCR.flush()
  if #SCR.batch > 0 then
    fs.deviceControl(hIn, "render_batch", SCR.batch)
    SCR.batch = {}
  end
end

function SCR.invalidate() SCR.prev = {} end

-- =============================================
-- EDITOR STATE
-- =============================================

local sFilePath  = nil
local tLines     = {""}
local bModified  = false
local sMode      = "normal"
local sMsg       = ""
local sCmdBuf    = ""
local sSearchBuf = ""
local sSearchTerm= ""
local sYankBuf   = ""
local bYankLine  = false

local nCL, nCC   = 1, 1
local nTop, nLeft = 1, 1
local bLineNum = false
local nNumW    = 0
local nViewH   = H - 2

local sPending = nil
local tUndo    = {}
local MAX_UNDO = 50

-- =============================================
-- SYNTAX HIGHLIGHTING
-- =============================================

local HL = nil
pcall(function() HL = require("vi/highlight") end)

local tLang      = nil   -- language definition
local tBlkState  = {}    -- [lineNum] = true if inside block comment
local bStateDirty = true -- recompute before next render

local function recomputeState()
  if HL and tLang then
    tBlkState = HL.computeState(tLines, tLang)
  end
  bStateDirty = false
end

local function markDirty()
  markDirty()
  bStateDirty = true
end

-- =============================================
-- UNDO
-- =============================================

local function pushUndo()
  local t = {}; for i,s in ipairs(tLines) do t[i]=s end
  table.insert(tUndo, {l=t, cl=nCL, cc=nCC})
  if #tUndo > MAX_UNDO then table.remove(tUndo, 1) end
end

local function popUndo()
  if #tUndo == 0 then sMsg="Already at oldest change"; return end
  local t = table.remove(tUndo)
  tLines=t.l; nCL=t.cl; nCC=t.cc; bModified=true
end

-- =============================================
-- FILE I/O (loop read for large files)
-- =============================================

local function loadFile(sPath)
  local h = fs.open(sPath, "r")
  if not h then return nil end
  local tChunks = {}
  while true do
    local s = fs.read(h, math.huge)
    if not s then break end
    tChunks[#tChunks + 1] = s
  end
  fs.close(h)
  local sAll = table.concat(tChunks)
  if #sAll == 0 then return {""} end
  local t = {}
  for sLine in (sAll .. "\n"):gmatch("([^\n]*)\n") do
    t[#t + 1] = sLine:gsub("\r", "")    -- strip CR from CRLF files
  end
  if #t > 1 and t[#t] == "" then t[#t] = nil end
  if #t == 0 then t[1] = "" end
  return t
end

local function saveFile(sPath)
  if not sPath then return false, "No filename" end
  local h = fs.open(sPath, "w")
  if not h then return false, "Cannot write: " .. sPath end
  fs.write(h, table.concat(tLines, "\n") .. "\n")
  fs.close(h)
  bModified = false; return true
end

if tArgs[1] then
  sFilePath = tArgs[1]
  if sFilePath:sub(1,1) ~= "/" then
    sFilePath = (env.PWD or "/") .. "/" .. sFilePath
  end
  sFilePath = sFilePath:gsub("//", "/")
  local t = loadFile(sFilePath)
  if t then tLines = t; sMsg = '"' .. sFilePath .. '" ' .. #tLines .. "L"
  else sMsg = '"' .. sFilePath .. '" [New]' end
end

-- Detect syntax from file extension
if HL then
  tLang = HL.detect(sFilePath)
  if tLang and tLang.name ~= "Text" then
    sMsg = sMsg .. " [" .. tLang.name .. "]"
  end
else
  tLang = nil
end
bStateDirty = true

-- =============================================
-- HELPERS
-- =============================================

local function clamp(n, lo, hi) return math.max(lo, math.min(hi, n)) end
local function curLine() return tLines[nCL] or "" end

local function fixCol()
  local nMax = #curLine()
  if sMode == "normal" then nMax = math.max(1, nMax) end
  if sMode == "insert" then nMax = nMax + 1 end
  nCC = clamp(nCC, 1, nMax)
end

local function ensureVisible()
  if nCL < nTop then nTop = nCL end
  if nCL >= nTop + nViewH then nTop = nCL - nViewH + 1 end
  local nTextW = W - nNumW
  if nCC < nLeft then nLeft = nCC end
  if nCC >= nLeft + nTextW then nLeft = nCC - nTextW + 1 end
end

local function updateLineNum() nNumW = bLineNum and 5 or 0 end

local function readKey() return fs.read(hIn) end

local function nextWord(s, c)
  while c <= #s and s:sub(c,c) ~= " " do c=c+1 end
  while c <= #s and s:sub(c,c) == " " do c=c+1 end; return c
end

local function prevWord(s, c)
  c = c - 1
  while c > 1 and s:sub(c,c) == " " do c=c-1 end
  while c > 1 and s:sub(c-1,c-1) ~= " " do c=c-1 end; return c
end

local function searchFwd(sTerm, nSL, nSC)
  if not sTerm or #sTerm == 0 then return nil end
  for i = nSL, #tLines do
    local nF = (i == nSL) and (nSC + 1) or 1
    local p = tLines[i]:find(sTerm, nF, true)
    if p then return i, p end
  end
  for i = 1, nSL do
    local p = tLines[i]:find(sTerm, 1, true)
    if p then return i, p end
  end
end

local function searchBwd(sTerm, nSL, nSC)
  if not sTerm or #sTerm == 0 then return nil end
  for i = nSL, 1, -1 do
    local s = tLines[i]; local nMax = (i == nSL) and (nSC - 1) or #s
    local nLast, nFrom = nil, 1
    while true do
      local p = s:find(sTerm, nFrom, true)
      if not p or p > nMax then break end
      nLast = p; nFrom = p + 1
    end
    if nLast then return i, nLast end
  end
end

-- =============================================
-- RENDERING (diff-based, one batch per frame)
-- =============================================

local nPrevCursorY = nil  -- track cursor row for invalidation

local function render()
  ensureVisible(); updateLineNum()
  local nTextW = W - nNumW

  -- Invalidate row where cursor WAS (so old cursor block is redrawn)
  if nPrevCursorY then SCR.prev[nPrevCursorY] = nil end

-- Recompute block comment state if file changed
  if bStateDirty then recomputeState() end

  -- Content rows
  for row = 1, nViewH do
    local nLine = nTop + row - 1
    if nLine <= #tLines then
      local tS = {}
      if bLineNum then
        local sN = tostring(nLine)
        tS[#tS + 1] = {string.rep(" ", nNumW - 1 - #sN) .. sN .. " ", 0x555555, 0x000000}
      end

      -- Syntax-highlighted segments for visible portion
      local sL = tLines[nLine]
      if HL and tLang then
        local bInBlk = tBlkState[nLine] or false
        local tHL = HL.segments(sL, nLeft, nTextW, tLang, bInBlk)
        for _, seg in ipairs(tHL) do
          tS[#tS + 1] = seg
        end
      else
        local sV = (#sL >= nLeft) and sL:sub(nLeft, nLeft + nTextW - 1) or ""
        if #sV < nTextW then sV = sV .. string.rep(" ", nTextW - #sV) end
        tS[#tS + 1] = {sV, 0xFFFFFF, 0x000000}
      end

      SCR.segs(row, tS)
    else
      local tS = {}
      if bLineNum then tS[#tS + 1] = {string.rep(" ", nNumW), 0x000000, 0x000000} end
      tS[#tS + 1] = {"~", 0x0000FF, 0x000000}
      tS[#tS + 1] = {string.rep(" ", math.max(0, nTextW - 1)), 0x000000, 0x000000}
      SCR.segs(row, tS)
    end
  end

  -- Status bar
  local sTag = ({normal=" NORMAL ", insert=" INSERT ",
                  command=" COMMAND ", search=" SEARCH "})[sMode] or " ? "
  local sN = sFilePath or "[No Name]"
  if #sN > 30 then sN = "..." .. sN:sub(-27) end
  local sLangTag = (tLang and tLang.name ~= "Text") and (" " .. tLang.name .. " ") or ""
  local sL = sTag .. " " .. sN .. (bModified and " [+]" or "") .. sLangTag
  local sR = string.format(" Ln %d/%d Col %d ", nCL, #tLines, nCC)
  local nMid = math.max(0, W - #sL - #sR)
  SCR.row(H - 1, sL .. string.rep(" ", nMid) .. sR, 0xFFFFFF, 0x0000AA)

  -- Message / command line
  local sCmd = ""
  if sMode == "command" then sCmd = ":" .. sCmdBuf
  elseif sMode == "search" then sCmd = "/" .. sSearchBuf
  else sCmd = sMsg; sMsg = "" end
  SCR.row(H, sCmd, 0xFFFFFF, 0x000000)

  -- Cursor (always sent — inverted block overlay)
  local nSY, nSX
  if sMode == "command" then     nSY = H; nSX = 2 + #sCmdBuf
  elseif sMode == "search" then  nSY = H; nSX = 2 + #sSearchBuf
  else nSY = nCL - nTop + 1; nSX = (nCC - nLeft + 1) + nNumW end

  if nSY >= 1 and nSY <= H and nSX >= 1 and nSX <= W then
    local sC = " "
    if sMode ~= "command" and sMode ~= "search" then
      local sL2 = tLines[nCL] or ""
      if nCC >= 1 and nCC <= #sL2 then sC = sL2:sub(nCC, nCC) end
    end
    SCR.put(nSX, nSY, sC, 0x000000, 0xFFFFFF)
    -- Invalidate cursor row so next frame redraws content under cursor
    SCR.prev[nSY] = nil
    nPrevCursorY = nSY
  end

  SCR.flush()
end

-- =============================================
-- NORMAL MODE
-- =============================================

local function handleNormal(k)
  if sPending == "g" then
    sPending = nil
    if k == "g" then nCL = 1; nCC = 1; fixCol() end; return
  end
  if sPending == "d" then
    sPending = nil
    if k == "d" then
      pushUndo(); sYankBuf = tLines[nCL]; bYankLine = true
      table.remove(tLines, nCL)
      if #tLines == 0 then tLines[1] = "" end
      nCL = clamp(nCL, 1, #tLines); fixCol(); markDirty()
      SCR.invalidate()  -- line removal changes all rows below
    end; return
  end
  if sPending == "y" then
    sPending = nil
    if k == "y" then sYankBuf = tLines[nCL]; bYankLine = true; sMsg = "1 line yanked" end
    return
  end

  if     k == "h" or k == "\27[D" then nCC = nCC - 1; fixCol()
  elseif k == "l" or k == "\27[C" then nCC = nCC + 1; fixCol()
  elseif k == "j" or k == "\27[B" then nCL = math.min(nCL + 1, #tLines); fixCol()
  elseif k == "k" or k == "\27[A" then nCL = math.max(nCL - 1, 1); fixCol()
  elseif k == "0" or k == "\27[H" then nCC = 1
  elseif k == "$" or k == "\27[F" then nCC = #curLine(); fixCol()
  elseif k == "w" then nCC = nextWord(curLine(), nCC); fixCol()
  elseif k == "b" then nCC = prevWord(curLine(), nCC); fixCol()
  elseif k == "G" then nCL = #tLines; fixCol()
  elseif k == "g" then sPending = "g"
  elseif k == "\27[5~" then nCL = math.max(1, nCL - nViewH); fixCol()
  elseif k == "\27[6~" then nCL = math.min(#tLines, nCL + nViewH); fixCol()
  elseif k == "i" then pushUndo(); sMode = "insert"
  elseif k == "a" then pushUndo(); sMode = "insert"; if #curLine() > 0 then nCC = nCC + 1 end
  elseif k == "A" then pushUndo(); sMode = "insert"; nCC = #curLine() + 1
  elseif k == "o" then
    pushUndo(); table.insert(tLines, nCL + 1, "")
    nCL = nCL + 1; nCC = 1; sMode = "insert"; markDirty(); SCR.invalidate()
  elseif k == "O" then
    pushUndo(); table.insert(tLines, nCL, "")
    nCC = 1; sMode = "insert"; markDirty(); SCR.invalidate()
  elseif k == "x" then
    local s = curLine()
    if #s > 0 and nCC <= #s then
      pushUndo(); tLines[nCL] = s:sub(1,nCC-1)..s:sub(nCC+1); fixCol(); markDirty()
    end
  elseif k == "X" then
    if nCC > 1 then
      pushUndo(); local s = curLine()
      tLines[nCL] = s:sub(1,nCC-2)..s:sub(nCC); nCC = nCC - 1; markDirty()
    end
  elseif k == "D" then
    pushUndo(); sYankBuf = curLine():sub(nCC); bYankLine = false
    tLines[nCL] = curLine():sub(1, nCC - 1); fixCol(); markDirty()
  elseif k == "d" then sPending = "d"
  elseif k == "y" then sPending = "y"
  elseif k == "p" then
    if #sYankBuf > 0 then
      pushUndo()
      if bYankLine then
        table.insert(tLines, nCL + 1, sYankBuf); nCL = nCL + 1; nCC = 1
        SCR.invalidate()
      else
        local s = curLine()
        tLines[nCL] = s:sub(1,nCC)..sYankBuf..s:sub(nCC+1); nCC = nCC + #sYankBuf
      end
      markDirty(); fixCol()
    end
  elseif k == "P" then
    if #sYankBuf > 0 then
      pushUndo()
      if bYankLine then
        table.insert(tLines, nCL, sYankBuf); nCC = 1; SCR.invalidate()
      else
        local s = curLine(); local n = math.max(nCC - 1, 0)
        tLines[nCL] = s:sub(1,n)..sYankBuf..s:sub(n+1); nCC = n + #sYankBuf + 1
      end
      markDirty(); fixCol()
    end
  elseif k == "J" then
    if nCL < #tLines then
      pushUndo(); local nOld = #curLine()
      tLines[nCL] = curLine().." "..tLines[nCL + 1]
      table.remove(tLines, nCL + 1); nCC = nOld + 1; markDirty()
      SCR.invalidate()
    end
  elseif k == "r" then
    local rk = readKey()
    if rk and #rk == 1 and rk:byte() >= 32 then
      local s = curLine()
      if nCC <= #s then
        pushUndo(); tLines[nCL] = s:sub(1,nCC-1)..rk..s:sub(nCC+1); markDirty()
      end
    end
  elseif k == "u" then popUndo(); SCR.invalidate()
  elseif k == "/" then sMode = "search"; sSearchBuf = ""
  elseif k == "n" then
    local nl, nc = searchFwd(sSearchTerm, nCL, nCC)
    if nl then nCL = nl; nCC = nc; fixCol() else sMsg = "Pattern not found" end
  elseif k == "N" then
    local nl, nc = searchBwd(sSearchTerm, nCL, nCC)
    if nl then nCL = nl; nCC = nc; fixCol() else sMsg = "Pattern not found" end
  elseif k == ":" then sMode = "command"; sCmdBuf = ""
  elseif k == "Z" then
    local k2 = readKey()
    if k2 == "Z" then
      if sFilePath then
        local bOk, sErr = saveFile(sFilePath)
        if bOk then return "quit" else sMsg = sErr end
      else sMsg = "No filename" end
    end
  elseif k == string.char(7) then
    sMsg = string.format('"%s" %s%dL',
      sFilePath or "[No Name]", bModified and "[+] " or "", #tLines)
  end
end

-- =============================================
-- INSERT MODE
-- =============================================

local function handleInsert(k)
  if k == "\27" then sMode = "normal"; nCC = math.max(1, nCC - 1); fixCol(); return end
  local s = curLine()
  if k == "\b" then
    if nCC > 1 then
      tLines[nCL] = s:sub(1,nCC-2)..s:sub(nCC); nCC = nCC - 1; markDirty()
    elseif nCL > 1 then
      local sPrev = tLines[nCL - 1]; nCC = #sPrev + 1
      tLines[nCL - 1] = sPrev..s; table.remove(tLines, nCL)
      nCL = nCL - 1; markDirty(); SCR.invalidate()
    end
  elseif k == "\n" then
    tLines[nCL] = s:sub(1, nCC - 1)
    table.insert(tLines, nCL + 1, s:sub(nCC))
    nCL = nCL + 1; nCC = 1; markDirty(); SCR.invalidate()
  elseif k == "\t" then
    tLines[nCL] = s:sub(1,nCC-1).."  "..s:sub(nCC); nCC = nCC + 2; markDirty()
  elseif k == "\27[A" then nCL = math.max(1, nCL - 1); fixCol()
  elseif k == "\27[B" then nCL = math.min(#tLines, nCL + 1); fixCol()
  elseif k == "\27[D" then nCC = math.max(1, nCC - 1)
  elseif k == "\27[C" then nCC = math.min(#s + 1, nCC + 1)
  elseif k == "\27[H" then nCC = 1
  elseif k == "\27[F" then nCC = #s + 1
  elseif k == "\27[5~" then nCL = math.max(1, nCL - nViewH); fixCol()
  elseif k == "\27[6~" then nCL = math.min(#tLines, nCL + nViewH); fixCol()
  elseif #k == 1 and k:byte() >= 32 then
    tLines[nCL] = s:sub(1,nCC-1)..k..s:sub(nCC); nCC = nCC + 1; markDirty()
  end
end

-- =============================================
-- COMMAND MODE
-- =============================================

local function handleCommand(k)
  if k == "\27" then sMode = "normal"; return end
  if k == "\n" then
    sMode = "normal"; local sCmd = sCmdBuf; sCmdBuf = ""
    local sC = sCmd:match("^(%S+)"); local sA = sCmd:match("^%S+%s+(.+)$")
    if sC == "w" or sC == "write" then
      local p = sA or sFilePath; if sA then sFilePath = sA end
      local bOk, sErr = saveFile(p)
      sMsg = bOk and ('"'..p..'" written') or sErr
    elseif sC == "q" or sC == "quit" then
      if bModified then sMsg = "No write since last change (use :q!)" else return "quit" end
    elseif sC == "q!" then return "quit"
    elseif sC == "wq" or sC == "x" then
      local p = sA or sFilePath; if sA then sFilePath = sA end
      local bOk, sErr = saveFile(p)
      if bOk then return "quit" else sMsg = sErr end
    elseif sC == "set" then
      if sArg == "number" or sArg == "nu" then
        bLineNum = true; SCR.invalidate()
      elseif sArg == "nonumber" or sArg == "nonu" then
        bLineNum = false; SCR.invalidate()
      elseif sArg and sArg:sub(1,7) == "syntax=" then
        local sLangName = sArg:sub(8)
        if sLangName == "off" or sLangName == "none" then
          tLang = HL and HL.UNIVERSAL or nil; sMsg = "Syntax: off"
        elseif HL then
          tLang = HL.loadLang(sLangName)
          sMsg = "Syntax: " .. (tLang.name or sLangName)
        end
        bStateDirty = true; SCR.invalidate()
      else sMsg = "Unknown: " .. tostring(sArg) end
    elseif tonumber(sC) then nCL = clamp(tonumber(sC), 1, #tLines); fixCol()
    else sMsg = "Unknown: " .. sCmd end
    return
  elseif k == "\b" then
    if #sCmdBuf > 0 then sCmdBuf = sCmdBuf:sub(1,-2) else sMode = "normal" end
  elseif #k == 1 and k:byte() >= 32 then sCmdBuf = sCmdBuf .. k end
end

-- =============================================
-- SEARCH MODE
-- =============================================

local function handleSearch(k)
  if k == "\27" then sMode = "normal"; return end
  if k == "\n" then
    sMode = "normal"; sSearchTerm = sSearchBuf; sSearchBuf = ""
    local nl, nc = searchFwd(sSearchTerm, nCL, nCC)
    if nl then nCL = nl; nCC = nc; fixCol() else sMsg = "Not found: " .. sSearchTerm end
    return
  elseif k == "\b" then
    if #sSearchBuf > 0 then sSearchBuf = sSearchBuf:sub(1,-2) else sMode = "normal" end
  elseif #k == 1 and k:byte() >= 32 then sSearchBuf = sSearchBuf .. k end
end

-- =============================================
-- MAIN LOOP
-- =============================================

local function main()
  SCR.init()

  while true do
    render()
    local k = readKey()
    if not k then break end

    if k == "\3" then
      if sMode ~= "normal" then sMode = "normal"; fixCol() end
    else
      local sR
      if sMode == "normal" then sR = handleNormal(k)
      elseif sMode == "insert" then handleInsert(k)
      elseif sMode == "command" then sR = handleCommand(k)
      elseif sMode == "search" then handleSearch(k) end
      if sR == "quit" then break end
    end
    if sMode ~= "normal" then sPending = nil end
  end
end

local bOk, sErr = pcall(main)
SCR.done()
fs.deviceControl(hIn, "set_mode", {"cooked"})
fs.close(hIn); fs.close(hOut)
if not bOk then print("vi: " .. tostring(sErr)) end
```


axis-os\src\kernel\usr\commands\wc.lua
```
-- wc - word, line, byte count
local fs = require("filesystem")
local tArgs = env.ARGS or {}
if #tArgs == 0 then print("Usage: wc <file> [...]"); return end

local nTL, nTW, nTB = 0, 0, 0
for _, sArg in ipairs(tArgs) do
  local sPath = sArg
  if sPath:sub(1,1) ~= "/" then sPath = (env.PWD or "/") .. "/" .. sPath end
  sPath = sPath:gsub("//", "/")
  local h = fs.open(sPath, "r")
  if not h then print("wc: " .. sArg .. ": No such file"); goto next end
  local sData = fs.read(h, math.huge) or ""
  fs.close(h)
  local nL = 0; for _ in sData:gmatch("\n") do nL = nL + 1 end
  local nW = 0; for _ in sData:gmatch("%S+") do nW = nW + 1 end
  local nB = #sData
  nTL = nTL + nL; nTW = nTW + nW; nTB = nTB + nB
  print(string.format("  %5d %5d %5d  %s", nL, nW, nB, sArg))
  ::next::
end
if #tArgs > 1 then print(string.format("  %5d %5d %5d  total", nTL, nTW, nTB)) end
```


axis-os\src\kernel\usr\commands\wget.lua
```
--
-- /usr/commands/wget.lua
-- Download files from the web (v2 — uses http library)
--

local http = require("http")
local tArgs = env.ARGS

if not tArgs or #tArgs < 1 then
  print("Usage: wget <url> [output_path]")
  return
end

local sUrl = tArgs[1]
local sOutPath = tArgs[2]

if not sOutPath then
  -- infer filename from URL
  sOutPath = sUrl:match(".*/([^/]+)$") or "downloaded_file"
  -- strip query string
  sOutPath = sOutPath:match("^([^?]+)") or sOutPath
end
if sOutPath:sub(1, 1) ~= "/" then
  sOutPath = (env.PWD or "/") .. "/" .. sOutPath
  sOutPath = sOutPath:gsub("//", "/")
end

print("\27[36m::\27[37m Connecting to " .. sUrl .. "...")

local nSpinIdx = 1
local sSpinners = {"|", "/", "-", "\\"}

local tInfo, sErr = http.download(sUrl, sOutPath, function(nBytes)
  local sSizeStr = string.format("%.2f KB", nBytes / 1024)
  io.write("\r\27[K\27[32m" .. sSpinners[nSpinIdx] ..
           "\27[37m Received: " .. sSizeStr)
  nSpinIdx = nSpinIdx + 1
  if nSpinIdx > 4 then nSpinIdx = 1 end
end)

if tInfo then
  print(string.format("\n\27[32m[OK]\27[37m Saved to %s (%d bytes, HTTP %d, %dms connect)",
        sOutPath, tInfo.nBytes, tInfo.code, tInfo.connectMs))
else
  print("\n\27[31mError:\27[37m " .. tostring(sErr))
end
```


axis-os\src\kernel\usr\commands\whoami.lua
```
print(env.USER or "unknown")
```


axis-os\src\kernel\usr\commands\xpm.lua
```
--
-- /usr/commands/xpm.lua
-- xpm — Xen Package Manager for AxisOS
--
-- Syntax (Void/Arch hybrid):
--   xpm sync                  Sync package database
--   xpm install <pkg> [...]   Install package(s)
--   xpm remove <pkg> [...]    Remove package(s)
--   xpm search <term>         Search available packages
--   xpm list                  List installed packages
--   xpm info <pkg>            Show package details
--   xpm update                Re-download all installed packages
--
-- Short flags:
--   xpm -Sy                   sync
--   xpm -S <pkg>              install
--   xpm -R <pkg>              remove
--   xpm -Ss <term>            search
--   xpm -Q                    list installed
--   xpm -Qi <pkg>             info
--   xpm -Syu                  sync + update all
--

local fs   = require("filesystem")
local http = require("http")
local tArgs = env.ARGS or {}

-- =============================================
-- CONFIGURATION
-- =============================================

local REPO_URL       = "https://repo.axis-os.ru"
local INDEX_URL      = REPO_URL .. "/_sys/pkgindex"
local DB_DIR         = "/etc/xpm"
local DB_PATH        = DB_DIR .. "/pkgdb.lua"
local INSTALLED_PATH = DB_DIR .. "/installed.lua"

-- =============================================
-- COLORS
-- =============================================

local C = {
  R   = "\27[37m",  BOLD = "\27[1m",
  RED = "\27[31m",  GRN  = "\27[32m",
  YLW = "\27[33m",  BLU  = "\27[34m",
  MAG = "\27[35m",  CYN  = "\27[36m",
  GRY = "\27[90m",  WHT  = "\27[37m",
}

local CAT_COLORS = {
  drivers    = C.RED,
  executable = C.GRN,
  modules    = C.CYN,
  multilib   = C.MAG,
}

local CAT_LABELS = {
  drivers    = "driver",
  executable = "command",
  modules    = "module",
  multilib   = "library",
}

-- =============================================
-- OUTPUT HELPERS
-- =============================================

local function arrow(s)   io.write(C.BLU .. ":: " .. C.R .. s .. "\n") end
local function step(s)    io.write(C.GRN .. "   " .. C.R .. s .. "\n") end
local function warn(s)    io.write(C.YLW .. ":: " .. C.R .. s .. "\n") end
local function fail(s)    io.write(C.RED .. ":: " .. C.R .. s .. "\n") end
local function dim(s)     io.write(C.GRY .. "   " .. s .. C.R .. "\n") end

local function fmtSize(n)
  if n >= 1048576 then return string.format("%.1f MB", n / 1048576) end
  if n >= 1024    then return string.format("%.1f KB", n / 1024) end
  return n .. " B"
end

local function progress(nCur, nTotal, sLabel)
  local nW = 28
  local nPct = math.floor((nCur / math.max(nTotal, 1)) * 100)
  local nFill = math.floor((nCur / math.max(nTotal, 1)) * nW)
  local sBar = string.rep("#", nFill) .. string.rep("-", nW - nFill)
  io.write(string.format("\r   [%s%s%s] %3d%%  %s",
    C.CYN, sBar, C.R, nPct, fmtSize(nCur)))
end

-- =============================================
-- DATABASE
-- =============================================

local g_tDb = nil         -- cached package index
local g_tInstalled = nil  -- installed tracking

local function ensureDir()
  fs.mkdir(DB_DIR)
end

local function loadLuaFile(sPath)
  local h = fs.open(sPath, "r")
  if not h then return nil end
  local s = fs.read(h, math.huge)
  fs.close(h)
  if not s or #s == 0 then return nil end
  local f = load(s, sPath, "t", {})
  if not f then return nil end
  local bOk, tResult = pcall(f)
  if bOk and type(tResult) == "table" then return tResult end
  return nil
end

local function saveLuaFile(sPath, tData)
  ensureDir()
  local h = fs.open(sPath, "w")
  if not h then return false end
  fs.write(h, "return {\n")
  for _, t in ipairs(tData) do
    local parts = {}
    for k, v in pairs(t) do
      if type(v) == "string" then
        table.insert(parts, k .. '="' .. v .. '"')
      elseif type(v) == "number" then
        table.insert(parts, k .. '=' .. v)
      end
    end
    fs.write(h, "  {" .. table.concat(parts, ",") .. "},\n")
  end
  fs.write(h, "}\n")
  fs.close(h)
  return true
end

local function loadDb()
  if g_tDb then return g_tDb end
  g_tDb = loadLuaFile(DB_PATH)
  return g_tDb
end

local function loadInstalled()
  if g_tInstalled then return g_tInstalled end
  g_tInstalled = loadLuaFile(INSTALLED_PATH) or {}
  return g_tInstalled
end

local function saveInstalled()
  if not g_tInstalled then return end
  saveLuaFile(INSTALLED_PATH, g_tInstalled)
end

local function findPkg(sName)
  local tDb = loadDb()
  if not tDb then return nil end
  for _, p in ipairs(tDb) do
    if p.name == sName then return p end
  end
  return nil
end

local function isInstalled(sName)
  local tInst = loadInstalled()
  for _, p in ipairs(tInst) do
    if p.name == sName then return true end
  end
  return false
end

local function addInstalled(tPkg)
  local tInst = loadInstalled()
  -- remove old entry if exists
  local tNew = {}
  for _, p in ipairs(tInst) do
    if p.name ~= tPkg.name then table.insert(tNew, p) end
  end
  table.insert(tNew, {
    name = tPkg.name,
    cat  = tPkg.cat,
    dest = tPkg.dest,
    file = tPkg.file,
    path = tPkg.dest .. tPkg.file,
  })
  g_tInstalled = tNew
  saveInstalled()
end

local function removeInstalled(sName)
  local tInst = loadInstalled()
  local tNew = {}
  for _, p in ipairs(tInst) do
    if p.name ~= sName then table.insert(tNew, p) end
  end
  g_tInstalled = tNew
  saveInstalled()
end

-- =============================================
-- NETWORK
-- =============================================

local function download(sUrl, sDest, nExpectedSize)
  local stream, sErr = http.open(sUrl)
  if not stream then return nil, sErr end

  if stream.code == 404 then
    stream:close()
    return nil, "404 Not Found"
  end

  if stream.code >= 400 then
    stream:close()
    return nil, "HTTP " .. stream.code
  end

  local hFile = fs.open(sDest, "w")
  if not hFile then
    stream:close()
    return nil, "Cannot write to " .. sDest
  end

  local nTotal = nExpectedSize or 0
  local nRecv = 0

  while true do
    local sChunk = stream:read(2048)
    if not sChunk then break end
    fs.write(hFile, sChunk)
    nRecv = nRecv + #sChunk
    if nTotal > 0 then
      progress(nRecv, nTotal)
    else
      io.write(string.format("\r   %s received...", fmtSize(nRecv)))
    end
  end

  fs.close(hFile)
  stream:close()
  io.write("\n")  -- newline after progress bar
  return nRecv
end

-- =============================================
-- COMMANDS
-- =============================================

-- === SYNC ===
local function cmdSync()
  arrow("Syncing package database...")
  dim(INDEX_URL)

  local resp = http.get(INDEX_URL)

  if not resp or resp.code ~= 200 or not resp.body then
    fail("Failed to fetch package index")
    if resp then dim("HTTP " .. (resp.code or "?") .. " " .. (resp.error or "")) end
    return false
  end

  -- Validate the response is actually Lua
  local fTest = load(resp.body, "pkgindex", "t", {})
  if not fTest then
    fail("Received invalid package index")
    return false
  end

  local bOk, tTest = pcall(fTest)
  if not bOk or type(tTest) ~= "table" then
    fail("Package index is corrupt")
    return false
  end

  -- Save to disk
  ensureDir()
  local h = fs.open(DB_PATH, "w")
  if not h then
    fail("Cannot write to " .. DB_PATH)
    return false
  end
  fs.write(h, resp.body)
  fs.close(h)

  g_tDb = tTest  -- update cache

  -- Count by category
  local tCounts = {}
  for _, p in ipairs(tTest) do
    tCounts[p.cat] = (tCounts[p.cat] or 0) + 1
  end

  local tParts = {}
  for cat, n in pairs(tCounts) do
    table.insert(tParts, n .. " " .. (CAT_LABELS[cat] or cat) .. (n > 1 and "s" or ""))
  end

  arrow(#tTest .. " packages available (" .. table.concat(tParts, ", ") .. ")")
  return true
end

-- === INSTALL ===
local function cmdInstall(tNames)
  if #tNames == 0 then
    fail("No package specified")
    print("   Usage: xpm install <package> [...]")
    return
  end

  -- Auto-sync if no DB
  if not loadDb() then
    warn("No package database. Syncing...")
    if not cmdSync() then return end
  end

  local nInstalled = 0

  for _, sName in ipairs(tNames) do
    arrow("Resolving " .. C.WHT .. sName .. C.R .. "...")

    local tPkg = findPkg(sName)
    if not tPkg then
      fail("Package not found: " .. sName)
      dim("Try: xpm search " .. sName)
      goto nextPkg
    end

    local sColor = CAT_COLORS[tPkg.cat] or C.GRY
    local sLabel = CAT_LABELS[tPkg.cat] or tPkg.cat
    local sDest  = tPkg.dest .. tPkg.file

    step(string.format("%s [%s%s%s] -> %s (%s)",
      sName, sColor, sLabel, C.R, sDest, fmtSize(tPkg.size)))

    if isInstalled(sName) then
      warn(sName .. " is already installed. Reinstalling...")
    end

    local sUrl = REPO_URL .. "/" .. tPkg.url
    arrow("Downloading...")
    dim(sUrl)

    local nBytes, sErr = download(sUrl, sDest, tPkg.size)

    if not nBytes then
      fail("Download failed: " .. tostring(sErr))
      goto nextPkg
    end

    -- Track installation
    addInstalled(tPkg)
    nInstalled = nInstalled + 1

    step(C.GRN .. "Installed " .. C.R .. sName ..
         C.GRY .. " (" .. fmtSize(nBytes) .. ")" .. C.R)

    -- Special post-install actions
    if tPkg.cat == "drivers" then
      dim("Load with: insmod " .. sDest)
    end

    ::nextPkg::
  end

  if nInstalled > 0 then
    print("")
    arrow(C.GRN .. nInstalled .. " package(s) installed." .. C.R)
  end
end

-- === REMOVE ===
local function cmdRemove(tNames)
  if #tNames == 0 then
    fail("No package specified")
    return
  end

  local tInst = loadInstalled()
  local nRemoved = 0

  for _, sName in ipairs(tNames) do
    -- Find in installed list
    local tEntry = nil
    for _, p in ipairs(tInst) do
      if p.name == sName then tEntry = p; break end
    end

    if not tEntry then
      fail(sName .. " is not installed")
      goto nextRm
    end

    arrow("Removing " .. C.WHT .. sName .. C.R .. "...")

    local sPath = tEntry.path or (tEntry.dest .. tEntry.file)
    local bOk = fs.remove(sPath)

    if bOk then
      removeInstalled(sName)
      nRemoved = nRemoved + 1
      step(sPath .. " " .. C.RED .. "deleted" .. C.R)
    else
      fail("Could not delete " .. sPath)
    end

    ::nextRm::
  end

  if nRemoved > 0 then
    arrow(nRemoved .. " package(s) removed.")
  end
end

-- === SEARCH ===
local function cmdSearch(sTerm)
  if not sTerm or #sTerm == 0 then
    fail("No search term")
    print("   Usage: xpm search <term>")
    return
  end

  if not loadDb() then
    warn("No package database. Syncing...")
    if not cmdSync() then return end
  end

  local sLower = sTerm:lower()
  local tMatches = {}

  for _, p in ipairs(g_tDb) do
    local bMatch = false
    if p.name:lower():find(sLower, 1, true) then bMatch = true end
    if p.desc and p.desc:lower():find(sLower, 1, true) then bMatch = true end
    if p.cat:lower():find(sLower, 1, true) then bMatch = true end
    if bMatch then table.insert(tMatches, p) end
  end

  if #tMatches == 0 then
    warn("No packages matching '" .. sTerm .. "'")
    return
  end

  arrow(#tMatches .. " result(s) for '" .. C.WHT .. sTerm .. C.R .. "':")
  print("")

  for _, p in ipairs(tMatches) do
    local sColor = CAT_COLORS[p.cat] or C.GRY
    local sLabel = CAT_LABELS[p.cat] or p.cat
    local sTag = isInstalled(p.name) and (C.GRN .. " [installed]" .. C.R) or ""
    local sDesc = p.desc and (C.GRY .. " " .. p.desc .. C.R) or ""

    io.write(string.format("   %s%-14s%s %s%-10s%s %6s%s%s\n",
      C.WHT, p.name, C.R,
      sColor, sLabel, C.R,
      fmtSize(p.size),
      sTag, sDesc))
  end
end

-- === LIST ===
local function cmdList()
  local tInst = loadInstalled()

  if #tInst == 0 then
    warn("No packages installed.")
    dim("Install with: xpm install <package>")
    return
  end

  arrow(#tInst .. " package(s) installed:")
  print("")

  io.write(string.format("   %s%-14s %-10s %s%s\n",
    C.GRY, "NAME", "TYPE", "PATH", C.R))
  io.write(C.GRY .. "   " .. string.rep("-", 54) .. C.R .. "\n")

  for _, p in ipairs(tInst) do
    local sColor = CAT_COLORS[p.cat] or C.GRY
    local sLabel = CAT_LABELS[p.cat] or p.cat
    local sPath  = p.path or (p.dest .. p.file)

    io.write(string.format("   %s%-14s%s %s%-10s%s %s\n",
      C.WHT, p.name, C.R,
      sColor, sLabel, C.R,
      sPath))
  end
end

-- === INFO ===
local function cmdInfo(sName)
  if not sName then
    fail("No package specified")
    return
  end

  if not loadDb() then
    warn("No database. Syncing...")
    if not cmdSync() then return end
  end

  local tPkg = findPkg(sName)

  if not tPkg then
    fail("Package not found: " .. sName)
    return
  end

  local sColor = CAT_COLORS[tPkg.cat] or C.GRY
  local sLabel = CAT_LABELS[tPkg.cat] or tPkg.cat
  local bInst  = isInstalled(sName)

  print("")
  arrow("Package: " .. C.WHT .. tPkg.name .. C.R)
  print("")
  io.write(string.format("   %-14s %s%s%s\n",    "Category:",    sColor, sLabel, C.R))
  io.write(string.format("   %-14s %s\n",         "File:",        tPkg.file))
  io.write(string.format("   %-14s %s%s\n",       "Install to:",  tPkg.dest, tPkg.file))
  io.write(string.format("   %-14s %s\n",         "Size:",        fmtSize(tPkg.size)))
  io.write(string.format("   %-14s %s\n",         "Remote URL:",  tPkg.url))

  if tPkg.sub then
    io.write(string.format("   %-14s %s\n",       "Subcategory:", tPkg.sub))
  end
  if tPkg.desc then
    io.write(string.format("   %-14s %s\n",       "Description:", tPkg.desc))
  end

  local sStatus = bInst
    and (C.GRN .. "installed" .. C.R)
    or  (C.GRY .. "not installed" .. C.R)
  io.write(string.format("   %-14s %s\n", "Status:", sStatus))
  print("")
end

-- === UPDATE ===
local function cmdUpdate()
  arrow("Syncing database...")
  if not cmdSync() then return end

  local tInst = loadInstalled()
  if #tInst == 0 then
    warn("No packages installed. Nothing to update.")
    return
  end

  arrow("Updating " .. #tInst .. " installed package(s)...")
  print("")

  local nUpdated = 0
  local nFailed  = 0

  for _, tEntry in ipairs(tInst) do
    -- Look up current info from fresh DB
    local tPkg = findPkg(tEntry.name)
    if not tPkg then
      warn(tEntry.name .. ": no longer in repository (skipped)")
      goto nextUp
    end

    local sDest = tPkg.dest .. tPkg.file
    local sUrl  = REPO_URL .. "/" .. tPkg.url

    io.write(string.format("   %s%-14s%s [%s] ",
      C.WHT, tPkg.name, C.R, CAT_LABELS[tPkg.cat] or tPkg.cat))

    local nBytes, sErr = download(sUrl, sDest, tPkg.size)

    if nBytes then
      addInstalled(tPkg)
      nUpdated = nUpdated + 1
    else
      io.write(C.RED .. " FAILED: " .. tostring(sErr) .. C.R .. "\n")
      nFailed = nFailed + 1
    end

    ::nextUp::
  end

  print("")
  arrow(string.format("%s%d updated%s, %s%d failed%s.",
    C.GRN, nUpdated, C.R,
    nFailed > 0 and C.RED or C.GRN, nFailed, C.R))
end

-- =============================================
-- HELP
-- =============================================

local function cmdHelp()
  print("")
  print(C.CYN .. "  xpm" .. C.R .. " — Xen Package Manager for AxisOS")
  print(C.GRY .. "  " .. string.rep("-", 44) .. C.R)
  print("")
  print("  " .. C.WHT .. "Commands:" .. C.R)
  print("    xpm sync              Sync package database")
  print("    xpm install <pkg>     Install package(s)")
  print("    xpm remove <pkg>      Remove package(s)")
  print("    xpm search <term>     Search available packages")
  print("    xpm list              List installed packages")
  print("    xpm info <pkg>        Show package details")
  print("    xpm update            Update all installed packages")
  print("")
  print("  " .. C.WHT .. "Short flags:" .. C.R)
  print("    -Sy                   sync")
  print("    -S <pkg>              install")
  print("    -R <pkg>              remove")
  print("    -Ss <term>            search")
  print("    -Q                    list installed")
  print("    -Qi <pkg>             info")
  print("    -Syu                  sync + update")
  print("")
  print("  " .. C.WHT .. "Examples:" .. C.R)
  print("    xpm install curl ping")
  print("    xpm search net")
  print("    xpm -S iter -Syu")
  print("")
end

-- =============================================
-- ARGUMENT DISPATCH
-- =============================================

if #tArgs == 0 then
  cmdHelp()
  return
end

local sCmd = tArgs[1]
local tRest = {}
for i = 2, #tArgs do table.insert(tRest, tArgs[i]) end

-- English commands
if sCmd == "sync"    then cmdSync()
elseif sCmd == "install" or sCmd == "add"    then cmdInstall(tRest)
elseif sCmd == "remove"  or sCmd == "rm"     then cmdRemove(tRest)
elseif sCmd == "search"  or sCmd == "find"   then cmdSearch(tRest[1])
elseif sCmd == "list"    or sCmd == "ls"     then cmdList()
elseif sCmd == "info"    or sCmd == "show"   then cmdInfo(tRest[1])
elseif sCmd == "update"  or sCmd == "upgrade"then cmdUpdate()
elseif sCmd == "help"    or sCmd == "-h"     then cmdHelp()

-- Pacman-style compound flags
elseif sCmd == "-Sy"   then cmdSync()
elseif sCmd == "-S"    then cmdInstall(tRest)
elseif sCmd == "-R"    then cmdRemove(tRest)
elseif sCmd == "-Ss"   then cmdSearch(tRest[1])
elseif sCmd == "-Q"    then cmdList()
elseif sCmd == "-Qi"   then cmdInfo(tRest[1])
elseif sCmd == "-Syu"  then cmdUpdate()

else
  -- Maybe they just typed a package name?
  if sCmd:sub(1, 1) ~= "-" then
    warn("Unknown command: " .. sCmd)
    dim("Did you mean: xpm install " .. sCmd .. "?")
  else
    fail("Unknown flag: " .. sCmd)
  end
  print("")
  cmdHelp()
end
```


axis-os\src\kernel\kernel.lua
```
--
-- /kernel.lua
-- AxisOS Xen XKA v0.32-alpha1
-- v3: Object Handles, sMLTR (Synapse Message Layer Token Randomization),
--     Ring 3 multitasking improvements.
--

local kernel = {
  tProcessTable = {},
  tPidMap = {},
  tRings = {},
  nNextPid = 1,
  
  tSyscallTable = {},
  tSyscallOverrides = {},
  
  tEventQueue = {},
  
  tVfs = {
    tMounts = {},
    oRootFs = nil,
    sRootUuid = nil,
  },
  
  tDriverRegistry = {},
  tComponentDriverMap = {},
  nPipelinePid = nil,
  tBootLog = {},
  tLoadedModules = {},
}

local g_nCurrentPid = 0
local g_nDebugY = 2
local g_bLogToScreen = true
local g_oGpu = nil
local g_nWidth, g_nHeight = 80, 25
local g_nCurrentLine = 0
local tBootArgs = boot_args or {} 

local g_bAxfsRoot = false
local g_oAxfsVol  = nil

local g_oPreempt = nil          -- loaded from /lib/preempt.lua at boot
local g_oIpc = nil  -- Kernel IPC subsystem

local g_tSchedStats = {
    nTotalResumes      = 0,
    nPreemptions       = 0,
    nWatchdogWarnings  = 0,
    nWatchdogKills     = 0,
    nMaxSliceMs        = 0,
}

local WATCHDOG_WARN_THRESHOLD = 2.0   -- seconds — warn if a single resume exceeds this
local WATCHDOG_KILL_STRIKES   = 3     -- kill after this many warnings

-- Object Manager (loaded at boot from /lib/ob_manager.lua)
local g_oObManager = nil
local g_oRegistry = nil

-- Color constants
local C_WHITE  = 0xFFFFFF
local C_GRAY   = 0xAAAAAA
local C_GREEN  = 0x55FF55
local C_RED    = 0xFF5555
local C_YELLOW = 0xFFFF55
local C_CYAN   = 0x55FFFF
local C_BLUE   = 0x5555FF

local tLogLevels = {
  ok    = { text = "[  OK  ]", color = C_GREEN },
  fail  = { text = "[ FAIL ]", color = C_RED },
  info  = { text = "[ INFO ]", color = C_CYAN },
  warn  = { text = "[ WARN ]", color = C_YELLOW },
  dev   = { text = "[ DEV  ]", color = C_BLUE },
  none  = { text = "         ", color = C_WHITE },
}

local tLogLevelsPriority = {
  debug = 0, info = 1, warn = 2, fail = 3, none = 4
}

local sCurrentLogLevel = string.lower(tBootArgs.loglevel or "info")
local nMinPriority = tLogLevelsPriority[sCurrentLogLevel] or 1

-------------------------------------------------
-- sMLTR: SYNAPSE TOKEN GENERATION
-------------------------------------------------

-- Counter for extra entropy in token generation
local g_nSynapseCounter = 0

-- Generate a cryptographically-ish unique synapse token.
-- Uses uptime, counter, and random values for entropy.
local function fGenerateSynapseToken()
    g_nSynapseCounter = g_nSynapseCounter + 1
    local nUptime = math.floor(raw_computer.uptime() * 100000)
    local t = {}
    for i = 1, 4 do
        local nEntropy = math.random(0, 0xFFFF)
        -- mix in counter and uptime bits
        nEntropy = (nEntropy + g_nSynapseCounter * 31 + nUptime) % 0xFFFF
        t[i] = string.format("%04x", nEntropy)
        -- rotate uptime bits for next iteration
        nUptime = math.floor(nUptime / 7) + math.random(0, 0xFF)
    end
    return "SYN-" .. table.concat(t, "-")
end

-------------------------------------------------
-- EARLY BOOT & DEBUG FUNCTIONS
-------------------------------------------------

local function __gpu_dprint(sText)
  local sGpuAddr, sScreenAddr
  for sAddr in raw_component.list("gpu") do sGpuAddr = sAddr; break end
  for sAddr in raw_component.list("screen") do sScreenAddr = sAddr; break end
  if sGpuAddr and sScreenAddr then
    local oGpu = raw_component.proxy(sGpuAddr)
    pcall(oGpu.bind, sScreenAddr)
    pcall(oGpu.fill, 1, g_nDebugY, 160, 1, " ")
    pcall(oGpu.set, 1, g_nDebugY, tostring(sText))
    g_nDebugY = g_nDebugY + 1
    if g_nDebugY > 40 then g_nDebugY = 2 end
  end
end

local function __logger_init()
  local sGpuAddr, sScreenAddr
  for sAddr in raw_component.list("gpu") do sGpuAddr = sAddr; break end
  for sAddr in raw_component.list("screen") do sScreenAddr = sAddr; break end
  if sGpuAddr and sScreenAddr then
    g_oGpu = raw_component.proxy(sGpuAddr)
    pcall(g_oGpu.bind, sScreenAddr)
    g_nWidth, g_nHeight = g_oGpu.getResolution()
    g_oGpu.fill(1, 1, g_nWidth, g_nHeight, " ")
    g_nCurrentLine = 0
  end
end

function kprint(sLevel, ...)
  local nMsgPriority = tLogLevelsPriority[sLevel] or 1
  if nMsgPriority < nMinPriority then return end 
  local tMsgParts = {...}
  local sMessage = ""
  for i, v in ipairs(tMsgParts) do
    sMessage = sMessage .. tostring(v) .. (i < #tMsgParts and " " or "")
  end
  local sFullLogMessage = string.format("[%s] %s", sLevel, sMessage)
  table.insert(kernel.tBootLog, sFullLogMessage)
  if not g_bLogToScreen then return end
  if not g_oGpu then return end
  if g_nCurrentLine >= g_nHeight then
    g_oGpu.copy(1, 2, g_nWidth, g_nHeight - 1, 0, -1)
    g_oGpu.fill(1, g_nHeight, g_nWidth, 1, " ")
  else
    g_nCurrentLine = g_nCurrentLine + 1
  end
  local tLevelInfo = tLogLevels[sLevel] or tLogLevels.none
  local nPrintY = g_nCurrentLine
  local nPrintX = 1
  g_oGpu.setForeground(C_GRAY)
  local sTimestamp = string.format("[%8.4f]", raw_computer.uptime())
  g_oGpu.set(nPrintX, nPrintY, sTimestamp)
  nPrintX = nPrintX + #sTimestamp + 1
  g_oGpu.setForeground(tLevelInfo.color)
  g_oGpu.set(nPrintX, nPrintY, tLevelInfo.text)
  nPrintX = nPrintX + #tLevelInfo.text + 1
  g_oGpu.setForeground(C_WHITE)
  g_oGpu.set(nPrintX, nPrintY, sMessage)
end

-------------------------------------------------
-- KERNEL PANIC
-------------------------------------------------

function kernel.panic(sReason, coFaulting)
  raw_computer.beep(1100, 1.3); raw_computer.pullSignal(0.1)
  local sGpuAddress, sScreenAddress
  for sAddr in raw_component.list("gpu") do sGpuAddress = sAddr; break end
  for sAddr in raw_component.list("screen") do sScreenAddress = sAddr; break end
  if not sGpuAddress or not sScreenAddress then
    while true do raw_computer.pullSignal(1) end
  end
  local oGpu = raw_component.proxy(sGpuAddress)
  pcall(oGpu.bind, sScreenAddress)
  local nW, nH = oGpu.getResolution()
  pcall(oGpu.setBackground, 0x0000AA)
  pcall(oGpu.setForeground, 0xFFFFFF)
  pcall(oGpu.fill, 1, 1, nW, nH, " ")
  local y = 1
  local function print_line(sText, sColor)
    if y > nH then return end
    pcall(oGpu.setForeground, sColor or 0xFFFFFF)
    pcall(oGpu.set, 2, y, tostring(sText or ""))
    y = y + 1
  end
  print_line(" ")
  print_line(":( A fatal error has occurred and AxisOS has been shut down.", 0xFFFFFF)
  print_line("   to prevent damage to your system.", 0xFFFFFF)
  y = y + 1
  print_line("[ KERNEL PANIC ]", 0xFF5555)
  y = y + 1
  print_line("Reason: " .. tostring(sReason or "No reason specified."), 0xFFFF55)
  y = y + 1
  print_line("---[ Faulting Context ]---", 0x55FFFF)
  local nFaultingPid = coFaulting and kernel.tPidMap[coFaulting]
  if nFaultingPid then
    local p = kernel.tProcessTable[nFaultingPid]
    print_line(string.format("PID: %d   Parent: %d   Ring: %d   Status: %s",
               nFaultingPid, p.parent or -1, p.ring or -1, p.status or "UNKNOWN"), 0xFFFFFF)
    local sPath = "N/A"
    if p.env and p.env.arg and type(p.env.arg) == "table" then sPath = p.env.arg[0] or "N/A" end
    print_line("Image Path: " .. sPath, 0xAAAAAA)
    -- sMLTR: show synapse token in panic
    print_line("Synapse Token: " .. tostring(p.synapseToken or "N/A"), 0xAAAAAA)
    y = y + 1
    print_line("Stack Trace:", 0x55FFFF)
    local sTraceback = debug.traceback(coFaulting)
    for line in sTraceback:gmatch("[^\r\n]+") do
      line = line:gsub("kernel.lua", "kernel"):gsub("pipeline_manager.lua", "pm"):gsub("dkms.lua", "dkms")
      print_line("  " .. line, 0xAAAAAA)
      if y > 22 then print_line("  ... (trace truncated)", 0xAAAAAA); break end
    end
  else
    print_line("Panic occurred outside of a managed process (e.g., during boot).", 0xFFFF55)
  end
  y = y + 1
  print_line("---[ System State ]---", 0x55FFFF)
  print_line(string.format("Uptime: %.4f seconds", raw_computer.uptime()), 0xFFFFFF)
  print_line(string.format("Total Processes: %d", kernel.nNextPid - 1), 0xFFFFFF)
  y = y + 1
  print_line("Process Table (Top 10):", 0x55FFFF)
  print_line(string.format("%-5s %-7s %-12s %-6s %-s", "PID", "PARENT", "STATUS", "RING", "IMAGE"), 0xAAAAAA)
  local nCount = 0
  for pid, p in pairs(kernel.tProcessTable) do
    if nCount >= 10 then break end
    local sPath = "N/A"
    if p.env and p.env.arg and type(p.env.arg) == "table" then sPath = p.env.arg[0] or "N/A" end
    print_line(string.format("%-5d %-7d %-12s %-6d %-s",
               pid, p.parent or -1, p.status or "??", p.ring or "?", sPath), 0xFFFFFF)
    nCount = nCount + 1
  end
  y = y + 1
  print_line("---[ Component Dump ]---", 0x55FFFF)
  local tComponents = {}
  for addr, ctype in raw_component.list() do table.insert(tComponents, {addr=addr, ctype=ctype}) end
  for i, comp in ipairs(tComponents) do
    if y > nH - 2 then print_line("... (list truncated)", 0xAAAAAA); break end
    print_line(string.format("[%s...] %s", comp.addr:sub(1, 13), comp.ctype), 0xFFFFFF)
  end
  pcall(oGpu.setForeground, 0xFFFF55)
  pcall(oGpu.set, 2, nH, "System halted. Please power cycle the machine.")
  while true do raw_computer.pullSignal(1) end
end

------------------------------------------------
-- BOOT MSG
------------------------------------------------

__logger_init()
kprint("info", "AxisOS Xen XKA v0.32-alpha1 starting...")
kprint("info", "Copyright (C) 2025 AxisOS")
kprint("none", "")

-------------------------------------------------
-- PRIMITIVE BOOTLOADER HELPERS
-------------------------------------------------

-- =============================================
-- ROOT FILESYSTEM BOOTSTRAP
-- Detects AXFS boot or falls back to managed FS
-- =============================================

local g_oPrimitiveFs

if _G.boot_fs_type == "axfs" then
  -- Booted from AXFS — create minimal volume reader
  -- Load bpack inline (can't require yet)
  local function r16(s,o) return s:byte(o)*256+s:byte(o+1) end
  local function r32(s,o) return s:byte(o)*16777216+s:byte(o+1)*65536+s:byte(o+2)*256+s:byte(o+3) end
  local function rstr(s,o,n) local r=s:sub(o,o+n-1); local z=r:find("\0",1,true); return z and r:sub(1,z-1) or r end

  local oDrv = raw_component.proxy(_G.boot_drive_addr)
  local nPOff = _G.boot_part_offset
  local ss = oDrv.getSectorSize()

  local function prs(n) return oDrv.readSector(nPOff + n + 1) end

  local sb = prs(0)
  local nDS = r16(sb, 20)
  local ips = math.floor(ss / 64)

  local function ri(n)
    local sec = 3+math.floor(n/ips); local off = (n%ips)*64
    local sd = prs(sec); if not sd then return nil end
    local o = off+1
    local t = {iType=r16(sd,o), size=r32(sd,o+8), nBlk=r16(sd,o+22), dir={}, ind=r16(sd,o+44)}
    for i=1,10 do t.dir[i]=r16(sd,o+24+(i-1)*2) end; return t
  end
  local function rb(n) return prs(nDS+n) end
  local function blks(t)
    local r={}
    for i=1,math.min(10,t.nBlk) do if t.dir[i] and t.dir[i]>0 then r[#r+1]=t.dir[i] end end
    if t.nBlk>10 and t.ind>0 then
      local si=rb(t.ind); if si then
        for i=1,math.floor(ss/2) do local p2=r16(si,(i-1)*2+1); if p2>0 then r[#r+1]=p2 end end
      end
    end; return r
  end
  local function dfind(di,nm)
    local dpb=math.floor(ss/32)
    for _,bn in ipairs(blks(di)) do
      local sd=rb(bn); if sd then
        for i=0,dpb-1 do local o=i*32+1; local ino=r16(sd,o)
          if ino>0 then local nl=sd:byte(o+3); if sd:sub(o+4,o+3+nl)==nm then return ino end end
        end
      end
    end
  end
  local function resolve(p)
    local c=1; for seg in p:gmatch("[^/]+") do
      local t=ri(c); if not t or t.iType~=2 then return nil end
      c=dfind(t,seg); if not c then return nil end
    end; return c
  end
  local function readfile(p)
    local n=resolve(p); if not n then return nil end
    local t=ri(n); if not t or t.iType~=1 then return nil end
    local ch={}; local rem=t.size
    for _,bn in ipairs(blks(t)) do
      local sd=rb(bn); if sd then ch[#ch+1]=sd:sub(1,math.min(rem,ss)); rem=rem-ss end
      if rem<=0 then break end
    end; return table.concat(ch)
  end

  -- Now load axfs_core + axfs_proxy properly
  local sAxCode = readfile("/lib/axfs_core.lua")
  local sBpCode = readfile("/lib/bpack.lua")
  local sPxCode = readfile("/lib/axfs_proxy.lua")

  if sAxCode and sBpCode and sPxCode then
    -- Load bpack
    local tBpEnv = {string=string, math=math, table=table}
    local fBp = load(sBpCode, "@bpack", "t", tBpEnv)
    local oBpack = fBp()

    -- Load axfs_core with bpack available
    local tAxEnv = {
      string=string, math=math, table=table, os=os, type=type,
      tostring=tostring, pairs=pairs, ipairs=ipairs, setmetatable=setmetatable,
      require=function(m)
        if m == "bpack" then return oBpack end
        error("Cannot require '"..m.."' during AXFS boot")
      end,
    }
    local fAx = load(sAxCode, "@axfs_core", "t", tAxEnv)
    local oAXFS = fAx()

    -- Load proxy module
    local tPxEnv = {
      string=string, math=math, table=table, tostring=tostring,
      type=type, pairs=pairs, ipairs=ipairs,
      require=function(m)
        if m == "axfs_core" then return oAXFS end
        if m == "bpack" then return oBpack end
      end,
    }
    local fPx = load(sPxCode, "@axfs_proxy", "t", tPxEnv)
    local oProxy = fPx()

    -- Create proper AXFS volume
    local tDisk = oAXFS.wrapDrive(oDrv, nPOff, _G.boot_part_size)
    local vol, vErr = oAXFS.mount(tDisk)

    if vol then
      g_oAxfsVol = vol
      g_bAxfsRoot = true
      g_oPrimitiveFs = oProxy.createProxy(vol, "root")
      __gpu_dprint("AXFS root mounted (" .. vol.su.label .. ")")
    else
      kernel.panic("Failed to mount AXFS root: " .. tostring(vErr))
    end
  else
    kernel.panic("AXFS boot: missing core libraries on disk")
  end
else
  -- Standard managed FS boot
  g_oPrimitiveFs = raw_component.proxy(boot_fs_address)
end

local function primitive_load(sPath)
  local hFile, sReason = g_oPrimitiveFs.open(sPath, "r")
  if not hFile then
    return nil, "primitive_load failed to open: " .. tostring(sReason or "Unknown error")
  end
  local tChunks = {}
  while true do
    local sChunk = g_oPrimitiveFs.read(hFile, math.huge)
    if not sChunk then break end
    tChunks[#tChunks + 1] = sChunk
  end
  g_oPrimitiveFs.close(hFile)
  local sData = table.concat(tChunks)
  if #sData == 0 then
    return nil, "primitive_load: empty file: " .. sPath
  end
  return sData
end

local function primitive_load_lua(sPath)
  local sCode, sErr = primitive_load(sPath)
  if not sCode then
    kernel.panic("CRITICAL: Failed to load " .. sPath .. ": " .. (sErr or "File not found"))
  end
  local fFunc, sLoadErr = load(sCode, "@" .. sPath, "t", {})
  if not fFunc then
    kernel.panic("CRITICAL: Failed to parse " .. sPath .. ": " .. sLoadErr)
  end
  return fFunc()
end

-------------------------------------------------
-- OBJECT MANAGER BOOT LOAD
-------------------------------------------------

local function __load_ob_manager()
  local sCode, sErr = primitive_load("/lib/ob_manager.lua")
  if not sCode then
    kprint("warn", "Object Manager not found at /lib/ob_manager.lua: " .. tostring(sErr))
    return nil
  end
  -- Provide a minimal sandbox for ob_manager to load in
  local tObEnv = {
    string = string, math = math, os = os,
    pairs = pairs, type = type, tostring = tostring, table = table,
    setmetatable = setmetatable, pcall = pcall, ipairs = ipairs,
    -- Give it access to raw_computer for uptime-based entropy
    raw_computer = raw_computer,
  }
  local fChunk, sLoadErr = load(sCode, "@ob_manager", "t", tObEnv)
  if not fChunk then
    kprint("fail", "Failed to parse ob_manager: " .. tostring(sLoadErr))
    return nil
  end
  local bOk, oResult = pcall(fChunk)
  if bOk and type(oResult) == "table" then
    return oResult
  else
    kprint("fail", "Failed to init ob_manager: " .. tostring(oResult))
    return nil
  end
end

local function __load_registry()
  local sCode, sErr = primitive_load("/lib/registry.lua")
  if not sCode then
    kprint("warn", "Registry not found at /lib/registry.lua: " .. tostring(sErr))
    return nil
  end
  local tRegEnv = {
    string = string, math = math, os = os,
    pairs = pairs, type = type, tostring = tostring, table = table,
    setmetatable = setmetatable, pcall = pcall, ipairs = ipairs,
    raw_computer = raw_computer,
  }
  local fChunk, sLoadErr = load(sCode, "@registry", "t", tRegEnv)
  if not fChunk then
    kprint("fail", "Failed to parse registry: " .. tostring(sLoadErr))
    return nil
  end
  local bOk, oResult = pcall(fChunk)
  if bOk and type(oResult) == "table" then
    return oResult
  else
    kprint("fail", "Failed to init registry: " .. tostring(oResult))
    return nil
  end
end

local function __load_preempt()
    local sCode, sErr = primitive_load("/lib/preempt.lua")
    if not sCode then
        kprint("warn", "Preempt module not found at /lib/preempt.lua: " .. tostring(sErr))
        return nil
    end
    local tEnv = {
        string = string, math = math, table = table,
        pairs = pairs, ipairs = ipairs, type = type,
        tostring = tostring, tonumber = tonumber,
    }
    local fChunk, sLoadErr = load(sCode, "@preempt", "t", tEnv)
    if not fChunk then
        kprint("fail", "Failed to parse preempt module: " .. tostring(sLoadErr))
        return nil
    end
    local bOk, oResult = pcall(fChunk)
    if bOk and type(oResult) == "table" then
        return oResult
    else
        kprint("fail", "Failed to init preempt module: " .. tostring(oResult))
        return nil
    end
end

local function __load_ke_ipc()
    local sCode, sErr = primitive_load("/lib/ke_ipc.lua")
    if not sCode then
        kprint("warn", "ke_ipc not found: " .. tostring(sErr))
        return nil
    end
    local tEnv = {
        string = string, math = math, os = os, table = table,
        pairs = pairs, ipairs = ipairs, type = type,
        tostring = tostring, tonumber = tonumber,
        pcall = pcall, select = select, next = next, error = error,
        setmetatable = setmetatable, coroutine = coroutine,
        raw_computer = raw_computer,
    }
    local fChunk, sLoadErr = load(sCode, "@ke_ipc", "t", tEnv)
    if not fChunk then
        kprint("fail", "Failed to parse ke_ipc: " .. tostring(sLoadErr))
        return nil
    end
    local bOk, oResult = pcall(fChunk)
    if bOk and type(oResult) == "table" then return oResult
    else kprint("fail", "Failed to init ke_ipc: " .. tostring(oResult)); return nil end
end

-------------------------------------------------
-- PROCESS & MODULE MANAGEMENT
-------------------------------------------------

function kernel.custom_require(sModulePath, nCallingPid)
  if kernel.tLoadedModules[sModulePath] then
    return kernel.tLoadedModules[sModulePath]
  end
  
  local tPathsToTry = {
    "/lib/" .. sModulePath .. ".lua",
    "/usr/lib/" .. sModulePath .. ".lua",
    "/drivers/" .. sModulePath .. ".lua",
    "/drivers/" .. sModulePath .. ".sys.lua",
    "/system/" .. sModulePath .. ".lua",
    "/system/lib/dk/" .. sModulePath .. ".lua",
    "/sys/security/" .. sModulePath .. ".lua",
  }
  
  local sCode, sErr
  local sFoundPath
  for _, sPath in ipairs(tPathsToTry) do
    sCode, sErr = kernel.syscalls.vfs_read_file(nCallingPid, sPath)
    if sCode then sFoundPath = sPath; break end
  end
  
  if not sCode then return nil, "Module not found: " .. sModulePath end
  
  local tEnv = kernel.tProcessTable[nCallingPid].env
  local fFunc, sLoadErr = load(sCode, "@" .. sFoundPath, "t", tEnv)
  if not fFunc then return nil, "Failed to load module " .. sModulePath .. ": " .. sLoadErr end
  
  local bIsOk, result = pcall(fFunc)
  if not bIsOk then return nil, "Failed to initialize module " .. sModulePath .. ": " .. result end
  
  kernel.tLoadedModules[sModulePath] = result
  return result
end

-- ANSI escape code stripper for NO_COLOR support
local function fStripAnsi(s)
    return s:gsub("\27%[[%d;]*[a-zA-Z]", "")
end


function kernel.create_sandbox(nPid, nRing)
  local tSandbox = {
    assert = assert,
    error = error,
    ipairs = ipairs,
    next = next,
    pairs = pairs,
    pcall = pcall,
    select = select,
    tonumber = tonumber,
    tostring = tostring,
    type = type,
    unpack = unpack,
    _VERSION = _VERSION,
    xpcall = xpcall,
    coroutine = coroutine,
    string = string,
    table = table,
    math = math,
    debug = debug,

    syscall = function(...)
        return kernel.syscall_dispatch(...)
    end,

    require = function(sModulePath)
        local mod, sErr = kernel.custom_require(sModulePath, nPid)
        if not mod then error(sErr, 2) end
        return mod
    end,
  }

  -- =========================================================
  -- PREEMPTIVE SCHEDULING:  __pc()  yield checkpoint
  --
  -- For Ring ≥ 2.5 processes the instrumenter rewrites source
  -- to call __pc() inside every loop / branch.  The function
  -- keeps a fast counter and only checks the wall clock every
  -- CHECK_INTERVAL calls.  When the quantum is exhausted it
  -- does a bare coroutine.yield() which the scheduler treats
  -- as "preempted → reschedule immediately".
  -- =========================================================
  if g_oPreempt and nRing >= 2.5 then
      local nPcCounter   = 0
      local nPcLastYield = raw_computer.uptime()
      local nPcQuantum   = g_oPreempt.DEFAULT_QUANTUM
      local nPcInterval  = g_oPreempt.CHECK_INTERVAL
      local fUptime      = raw_computer.uptime   -- captured ref

      tSandbox.__pc = function()
          nPcCounter = nPcCounter + 1
          if nPcCounter < nPcInterval then return end
          nPcCounter = 0
          -- Signal delivery (if any pending)
          if g_oIpc then
              local tProc = kernel.tProcessTable[nPid]
              if tProc and tProc.tPendingSignals and #tProc.tPendingSignals > 0 then
                  g_oIpc.DeliverSignals(nPid)
                  if tProc.status == "dead" then
                      coroutine.yield()
                      return
                  end
              end
          end
          -- Time quantum check
          local nNow = fUptime()
          if nNow - nPcLastYield >= nPcQuantum then
              coroutine.yield()
              nPcLastYield = fUptime()
          end
      end

      -- Wrap load() so that dynamically compiled code is also
      -- instrumented  (e.g.  load("while true do end")  ).
      local fKernelLoad = load
      tSandbox.load = function(sChunk, sName, sMode, tLoadEnv)
          if type(sChunk) == "string" then
              local sInst, nInj = g_oPreempt.instrument(sChunk, sName or "[dynamic]")
              if nInj > 0 then sChunk = sInst end
          end
          return fKernelLoad(sChunk, sName, sMode, tLoadEnv or tSandbox)
      end
  else
      tSandbox.__pc = function() end          -- no-op for system rings
  end

  -- print / io  (defined AFTER tSandbox so closures can read env)
  tSandbox.print = function(...)
      local tP = {}
      for i = 1, select("#", ...) do tP[i] = tostring(select(i, ...)) end
      local sOut = table.concat(tP, "\t") .. "\n"
      if tSandbox.env and tSandbox.env.NO_COLOR then
          sOut = fStripAnsi(sOut)
      end
      kernel.syscall_dispatch("vfs_write", -11, sOut)
  end

  tSandbox.io = {
      write = function(...)
          local tP = {}
          for i = 1, select("#", ...) do tP[i] = tostring(select(i, ...)) end
          local sOut = table.concat(tP)
          if tSandbox.env and tSandbox.env.NO_COLOR then
              sOut = fStripAnsi(sOut)
          end
          kernel.syscall_dispatch("vfs_write", -11, sOut)
      end,
      read = function()
          local _, _, data = kernel.syscall_dispatch("vfs_read", -10)
          return data
      end,
  }

  -- Safe os table
  local tSafeOs = {}
  for sKey, vValue in pairs(os) do
    if sKey ~= "exit" and sKey ~= "execute" and sKey ~= "remove" and sKey ~= "rename" then
      tSafeOs[sKey] = vValue
    end
  end
  tSandbox.os = tSafeOs

  -- Ring 0 gets god-mode
  if nRing == 0 then
    tSandbox.kernel = kernel
    tSandbox.raw_component = raw_component
    tSandbox.raw_computer = raw_computer
  end

  setmetatable(tSandbox, { __index = _G })
  tSandbox._G = tSandbox

  return tSandbox
end

function kernel.create_process(sPath, nRing, nParentPid, tPassEnv)
  local nPid = kernel.nNextPid
  kernel.nNextPid = kernel.nNextPid + 1

  kprint("info", "Creating process " .. nPid .. " ('" .. sPath .. "') at Ring " .. nRing)

  local sCode, sErr = kernel.syscalls.vfs_read_file(0, sPath)
  if not sCode then
    kprint("fail", "Failed to create process: " .. sErr)
    return nil, sErr
  end

  -- =========================================================
  -- PREEMPTIVE SCHEDULING:  instrument source for Ring ≥ 2.5
  -- Injects __pc() calls after every  do / then / repeat / else
  -- so the process yields back to the scheduler periodically.
  -- =========================================================
  if g_oPreempt and nRing >= 2.5 then
      local sInstrumented, nInjections = g_oPreempt.instrument(sCode, sPath)
      if nInjections > 0 then
          kprint("dev", string.format(
              "Preempt: %s → %d yield checkpoints injected", sPath, nInjections))
          sCode = sInstrumented
      else
          kprint("dev", "Preempt: " .. sPath .. " — no loops/branches to instrument")
      end
  end

  local tEnv = kernel.create_sandbox(nPid, nRing)
  if tPassEnv then tEnv.env = tPassEnv end

  local fFunc, sLoadErr = load(sCode, "@" .. sPath, "t", tEnv)
  if not fFunc then
    kprint("fail", "SYNTAX ERROR in " .. sPath .. ": " .. tostring(sLoadErr))
    return nil, sLoadErr
  end

  local coProcess = coroutine.create(function()
    local bIsOk, sErr = pcall(fFunc)
    if not bIsOk then
      kprint("fail", "!!! KERNEL ALERT: PROCESS " .. nPid .. " CRASHED !!!")
      kprint("fail", "Crash reason: " .. tostring(sErr))
    else
      kprint("info", "Process " .. nPid .. " exited normally.")
    end
    kernel.tProcessTable[nPid].status = "dead"
  end)

  -- sMLTR: Generate unique synapse token for this process
  local sSynapseToken = fGenerateSynapseToken()

  kernel.tProcessTable[nPid] = {
    co = coProcess,
    status = "ready",
    ring = nRing,
    parent = nParentPid,
    env = tEnv,
    fds = {},
    wait_queue = {},
    run_queue = {},
    uid = (tPassEnv and tPassEnv.UID) or 1000,
    -- sMLTR
    synapseToken = sSynapseToken,
    -- Thread tracking
    threads = {},
    -- Preemptive scheduler per-process stats
    nCpuTime         = 0,
    nPreemptCount    = 0,
    nLastSlice       = 0,
    nMaxSlice        = 0,
    nWatchdogStrikes = 0,
  }
  kernel.tPidMap[coProcess] = nPid
  kernel.tRings[nPid] = nRing

  -- Initialize IPC per-process state (signals, IRQL, process group)
  if g_oIpc then
      g_oIpc.InitProcessSignals(nPid)
  end

  -- Object Handle: Initialize per-process handle table
  if g_oObManager then
    g_oObManager.ObInitializeProcess(nPid)
    if nParentPid and nParentPid > 0 and kernel.tProcessTable[nParentPid] then
      g_oObManager.ObInheritHandles(nParentPid, nPid, sSynapseToken)
    end
  end

  kprint("dev", "  PID " .. nPid .. " synapse token: " .. sSynapseToken:sub(1, 16) .. "...")

  return nPid
end

function kernel.create_thread(fFunc, nParentPid)
  local nPid = kernel.nNextPid
  kernel.nNextPid = kernel.nNextPid + 1
  
  local tParentProcess = kernel.tProcessTable[nParentPid]
  if not tParentProcess then return nil, "Parent died" end
  
  kprint("dev", "Spawning thread " .. nPid .. " for parent " .. nParentPid)
  
  local tSharedEnv = tParentProcess.env
  
  local coThread = coroutine.create(function()
    local bOk, sErr = pcall(fFunc)
    if not bOk then
      kprint("fail", "Thread " .. nPid .. " crashed: " .. tostring(sErr))
    end
    kernel.tProcessTable[nPid].status = "dead"
  end)
  
  local sSynapseToken = tParentProcess.synapseToken
  
  kernel.tProcessTable[nPid] = {
    co = coThread,
    status = "ready",
    ring = tParentProcess.ring,
    parent = nParentPid,
    env = tSharedEnv,
    fds = tParentProcess.fds,
    wait_queue = {},
    run_queue = {},
    uid = tParentProcess.uid,
    synapseToken = sSynapseToken,
    threads = {},
    is_thread = true,
    -- Preemptive scheduler stats
    nCpuTime         = 0,
    nPreemptCount    = 0,
    nLastSlice       = 0,
    nMaxSlice        = 0,
    nWatchdogStrikes = 0,
  }
  
  kernel.tPidMap[coThread] = nPid
  kernel.tRings[nPid] = tParentProcess.ring

  if g_oObManager then
    g_oObManager.ObInitializeProcess(nPid)
    if nParentPid and nParentPid > 0 and kernel.tProcessTable[nParentPid] then
      g_oObManager.ObInheritHandles(nParentPid, nPid, sSynapseToken)
    end
  end
  
  -- Initialize IPC per-process state
  if g_oIpc then
      g_oIpc.InitProcessSignals(nPid)
  end
  
  table.insert(tParentProcess.threads, nPid)
  
  return nPid
end
-------------------------------------------------
-- SYSCALL DISPATCHER
-------------------------------------------------
kernel.syscalls = {}

function kernel.syscall_dispatch(sName, ...)
  local coCurrent = coroutine.running()
  local nPid = kernel.tPidMap[coCurrent]
  
  if not nPid then
    kernel.panic("Untracked coroutine tried to syscall: " .. sName)
  end
  
  g_nCurrentPid = nPid
  local nRing = kernel.tRings[nPid]
  
  -- PIPE FAST PATH: intercept vfs_read/vfs_write for kernel pipe handles
  -- This bypasses PM entirely, preventing PM from blocking on pipe I/O
  if g_oIpc and (sName == "vfs_read" or sName == "vfs_write") then
        local vHandle = select(1, ...)
        local bPcallOk, bIsPipe, r1, r2 = pcall(g_oIpc.TryPipeIo, nPid, sName, ...)
        if bPcallOk and bIsPipe then
            return r1, r2
        end
        if not bPcallOk then
            kprint("fail", "[IPC] Pipe fast-path error: " .. tostring(bIsPipe))
        end
    end

  -- Signal delivery point: deliver pending signals on every syscall entry
  if g_oIpc then
        local p = kernel.tProcessTable[nPid]
        if p and p.tPendingSignals and #p.tPendingSignals > 0 then
            local bKilled = g_oIpc.DeliverSignals(nPid)
            if bKilled then
                return nil, "Killed by signal"
            end
        end
  end

  -- Check for ring 1 overrides
  local nOverridePid = kernel.tSyscallOverrides[sName]
  if nOverridePid then
    local tProcess = kernel.tProcessTable[nPid]
    tProcess.status = "sleeping"
    tProcess.wait_reason = "syscall"
    
    -- sMLTR: Include the caller's synapse token in the IPC message
    local sSynapseToken = tProcess.synapseToken or "NO_TOKEN"
    
    local bIsOk, sErr = pcall(kernel.syscalls.signal_send, 0, nOverridePid, "syscall", {
      name = sName,
      args = {...},
      sender_pid = nPid,
      synapse_token = sSynapseToken,  -- sMLTR
    })
    
    if not bIsOk then
      tProcess.status = "ready"
      return nil, "Syscall IPC failed: " .. sErr
    end
    
    return coroutine.yield()
  end
  
  local tHandler = kernel.tSyscallTable[sName]
  if not tHandler then
    return nil, "Unknown syscall: " .. sName
  end
  
  -- RING CHECK
  local bIsAllowed = false
  for _, nAllowedRing in ipairs(tHandler.allowed_rings) do
    if nRing == nAllowedRing then bIsAllowed = true; break end
  end
  
  if not bIsAllowed then
    kprint("fail", "Ring violation: PID " .. nPid .. " (Ring " .. nRing .. ") tried to call " .. sName)
    kernel.tProcessTable[nPid].status = "dead"
    return coroutine.yield()
  end

  local tReturns = {pcall(tHandler.func, nPid, ...)}
  local bIsOk = table.remove(tReturns, 1)
  if not bIsOk then return nil, tReturns[1] end
  return table.unpack(tReturns)
end

-------------------------------------------------
-- SYSCALL DEFINITIONS
-------------------------------------------------

-- Kernel (Ring 0)
kernel.tSyscallTable["kernel_panic"] = {
  func = function(nPid, sReason) kernel.panic(sReason) end,
  allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["kernel_yield"] = {
    func = function() return coroutine.yield() end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["kernel_host_yield"] = {
  func = function() computer.pullSignal(0); return true end,
  allowed_rings = {0, 1} 
}

kernel.tSyscallTable["kernel_register_pipeline"] = {
  func = function(nPid) kernel.nPipelinePid = nPid end,
  allowed_rings = {0, 1}
}

kernel.tSyscallTable["kernel_register_driver"] = {
  func = function(nPid, sComponentType, nHandlerPid)
    if not kernel.tDriverRegistry[sComponentType] then kernel.tDriverRegistry[sComponentType] = {} end
    table.insert(kernel.tDriverRegistry[sComponentType], nHandlerPid)
  end,
  allowed_rings = {1}
}

kernel.tSyscallTable["kernel_map_component"] = {
  func = function(nPid, sAddress, nDriverPid) kernel.tComponentDriverMap[sAddress] = nDriverPid end,
  allowed_rings = {1}
}

kernel.tSyscallTable["kernel_get_root_fs"] = {
  func = function(nPid)
    if kernel.tVfs.sRootUuid and kernel.tVfs.oRootFs then
      return kernel.tVfs.sRootUuid, kernel.tVfs.oRootFs
    else return nil, "Root FS not mounted in kernel" end
  end,
  allowed_rings = {0, 1}
}

kernel.tSyscallTable["kernel_log"] = {
  func = function(nPid, sMessage) kprint("info", tostring(sMessage)); return true end,
  allowed_rings = {0, 1, 2, 3}
}

kernel.tSyscallTable["kernel_get_boot_log"] = {
  func = function(nPid)
    local sLog = table.concat(kernel.tBootLog, "\n")
    kernel.tBootLog = {}
    return sLog
  end,
  allowed_rings = {1, 2}
}

kernel.tSyscallTable["kernel_set_log_mode"] = {
  func = function(nPid, bEnable) g_bLogToScreen = bEnable; return true end,
  allowed_rings = {0, 1}
}

kernel.tSyscallTable["driver_load"] = {
  func = function(nPid, sPath) return nil, "Syscall not handled by PM" end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["syscall_override"] = {
  func = function(nPid, sSyscallName) kernel.tSyscallOverrides[sSyscallName] = nPid; return true end,
  allowed_rings = {1}
}

-- Process Management
kernel.tSyscallTable["process_spawn"] = {
  func = function(nPid, sPath, nRing, tPassEnv)
    local nParentRing = kernel.tRings[nPid]
    if nRing < nParentRing then
      return nil, "Permission denied: cannot spawn higher-privilege process"
    end
    local nNewPid, sErr = kernel.create_process(sPath, nRing, nPid, tPassEnv)
    if not nNewPid then return nil, sErr end
    return nNewPid
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_yield"] = {
  func = function(nPid)
    kernel.tProcessTable[nPid].status = "ready"
    coroutine.yield()
    return true
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_thread"] = {
  func = function(nPid, fFunc)
    if type(fFunc) ~= "function" then return nil, "Argument must be a function" end
    local nThreadPid, sErr = kernel.create_thread(fFunc, nPid)
    return nThreadPid, sErr
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_wait"] = {
  func = function(nPid, nTargetPid)
    if not kernel.tProcessTable[nTargetPid] then return nil, "Invalid PID" end
    if kernel.tProcessTable[nTargetPid].status == "dead" then return true end
    table.insert(kernel.tProcessTable[nTargetPid].wait_queue, nPid)
    kernel.tProcessTable[nPid].status = "sleeping"
    kernel.tProcessTable[nPid].wait_reason = "wait_pid"
    return coroutine.yield()
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_kill"] = {
  func = function(nPid, nTargetPid, nSignal)
    local tTarget = kernel.tProcessTable[nTargetPid]
    if not tTarget then return nil, "No such process" end
    local nCallerRing = kernel.tRings[nPid]
    if nCallerRing > 1 and tTarget.parent ~= nPid then
       return nil, "Permission denied"
    end
    -- Use signal system if available, otherwise direct kill
    if g_oIpc then
        nSignal = nSignal or g_oIpc.SIGTERM
        return g_oIpc.SignalSend(nTargetPid, nSignal)
    end
    tTarget.status = "dead"
    for _, nTid in ipairs(tTarget.threads or {}) do
      if kernel.tProcessTable[nTid] then
        kernel.tProcessTable[nTid].status = "dead"
      end
    end
    kprint("info", "Process " .. nTargetPid .. " killed by " .. nPid)
    return true
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_status"] = {
  func = function(nPid, nTargetPid)
    local tTarget = kernel.tProcessTable[nTargetPid or nPid]
    if tTarget then return tTarget.status else return nil end
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_list"] = {
    func = function(nPid)
        local tResult = {}
        for nProcPid, tProc in pairs(kernel.tProcessTable) do
            if tProc.status ~= "dead" then
                local sImage = "?"
                if tProc.env and tProc.env.env and tProc.env.env.arg then
                    sImage = tProc.env.env.arg[0] or "?"
                end
                table.insert(tResult, {
                    pid    = nProcPid,
                    parent = tProc.parent or 0,
                    ring   = tProc.ring or -1,
                    status = tProc.status or "?",
                    uid    = tProc.uid or -1,
                    image  = sImage,
                })
            end
        end
        table.sort(tResult, function(a, b) return a.pid < b.pid end)
        return tResult
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_list_threads"] = {
  func = function(nPid)
    local tProc = kernel.tProcessTable[nPid]
    if not tProc then return {} end
    local tAlive = {}
    for _, nTid in ipairs(tProc.threads or {}) do
      if kernel.tProcessTable[nTid] and kernel.tProcessTable[nTid].status ~= "dead" then
        table.insert(tAlive, nTid)
      end
    end
    tProc.threads = tAlive
    return tAlive
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_elevate"] = {
  func = function(nPid, nNewRing)
    if kernel.tRings[nPid] == 3 and nNewRing == 2.5 then
      kernel.tRings[nPid] = 2.5
      kernel.tProcessTable[nPid].ring = 2.5
      kernel.tProcessTable[nPid].env = kernel.create_sandbox(nPid, 2.5)
      -- sMLTR: Rotate synapse token on elevation for security
      kernel.tProcessTable[nPid].synapseToken = fGenerateSynapseToken()
      return true
    end
    return nil, "Permission denied"
  end,
  allowed_rings = {3}
}

kernel.tSyscallTable["process_get_ring"] = {
  func = function(nPid) return kernel.tRings[nPid] end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_get_pid"] = {
  func = function(nPid) return nPid end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_get_uid"] = {
  func = function(nPid, nTargetPid)
    local tP = kernel.tProcessTable[nTargetPid or nPid]
    if tP then return tP.uid else return nil end
  end,
  allowed_rings = {0, 1}
}


-- ==========================================
-- OBJECT HANDLE SYSCALLS (Ring 1 — used by PM)
-- ==========================================

kernel.tSyscallTable["ob_create_object"] = {
    func = function(nPid, sType, tBody)
        if not g_oObManager then return nil, "ObManager not loaded" end
        return g_oObManager.ObCreateObject(sType, tBody)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_reference_object"] = {
    func = function(nPid, pObj)
        if g_oObManager and pObj then g_oObManager.ObReferenceObject(pObj) end
        return true
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_dereference_object"] = {
    func = function(nPid, pObj)
        if g_oObManager and pObj then g_oObManager.ObDereferenceObject(pObj) end
        return true
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_insert_object"] = {
    func = function(nPid, pObj, sPath)
        if not g_oObManager then return nil end
        return g_oObManager.ObInsertObject(pObj, sPath)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_lookup_object"] = {
    func = function(nPid, sPath)
        if not g_oObManager then return nil end
        return g_oObManager.ObLookupObject(sPath)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_delete_object"] = {
    func = function(nPid, sPath)
        if not g_oObManager then return nil end
        return g_oObManager.ObDeleteObject(sPath)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_create_symlink"] = {
    func = function(nPid, sLink, sTarget)
        if not g_oObManager then return nil end
        return g_oObManager.ObCreateSymbolicLink(sLink, sTarget)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_delete_symlink"] = {
    func = function(nPid, sPath)
        if not g_oObManager then return nil end
        return g_oObManager.ObDeleteSymbolicLink(sPath)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_create_handle"] = {
    func = function(nPid, nTargetPid, pObj, nAccess, sSynapseToken, bInheritable)
        if not g_oObManager then return nil end
        return g_oObManager.ObCreateHandle(nTargetPid, pObj, nAccess, sSynapseToken, bInheritable)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_close_handle"] = {
    func = function(nPid, nTargetPid, vHandle)
        if not g_oObManager then return false end
        return g_oObManager.ObCloseHandle(nTargetPid, vHandle)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_reference_by_handle"] = {
    func = function(nPid, nTargetPid, vHandle, nDesiredAccess, sSynapseToken)
        if not g_oObManager then return nil end
        return g_oObManager.ObReferenceObjectByHandle(nTargetPid, vHandle, nDesiredAccess, sSynapseToken)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_set_standard_handle"] = {
    func = function(nPid, nTargetPid, nIndex, sToken)
        if not g_oObManager then return false end
        -- Security: Ring 3+ can only modify their OWN standard handles
        if kernel.tRings[nPid] >= 3 and nTargetPid ~= nPid then
            return nil, "Permission denied: can only set own standard handles"
        end
        return g_oObManager.ObSetStandardHandle(nTargetPid, nIndex, sToken)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["ob_get_standard_handle"] = {
    func = function(nPid, nTargetPid, nIndex)
        if not g_oObManager then return nil end
        -- Security: Ring 3+ can only query their OWN standard handles
        if kernel.tRings[nPid] >= 3 and nTargetPid ~= nPid then
            return nil, "Permission denied"
        end
        return g_oObManager.ObGetStandardHandle(nTargetPid, nIndex)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["ob_init_process"] = {
    func = function(nPid, nTargetPid)
        if not g_oObManager then return false end
        g_oObManager.ObInitializeProcess(nTargetPid)
        return true
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_destroy_process"] = {
    func = function(nPid, nTargetPid)
        if not g_oObManager then return false end
        g_oObManager.ObObDestroyProcess(nTargetPid)
        return true
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_inherit_handles"] = {
    func = function(nPid, nParentPid, nChildPid, sChildToken)
        if not g_oObManager then return false end
        g_oObManager.ObInheritHandles(nParentPid, nChildPid, sChildToken)
        return true
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_duplicate_handle"] = {
    func = function(nPid, nSrcPid, sSrcToken, nDstPid, nAccess, sSynToken)
        if not g_oObManager then return nil end
        return g_oObManager.ObDuplicateHandle(nSrcPid, sSrcToken, nDstPid, nAccess, sSynToken)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_list_handles"] = {
    func = function(nPid, nTargetPid)
        if not g_oObManager then return {} end
        return g_oObManager.ObListHandles(nTargetPid or nPid)
    end,
    allowed_rings = {0, 1}
}

kernel.tSyscallTable["ob_dump_directory"] = {
    func = function(nPid)
        if not g_oObManager then return {} end
        return g_oObManager.ObDumpDirectory()
    end,
    allowed_rings = {0, 1}
}

-- ==========================================
-- REGISTRY SYSCALLS (@VT)
-- ==========================================

kernel.tSyscallTable["reg_create_key"] = {
    func = function(nPid, sPath)
        if not g_oRegistry then return false, "Registry not loaded" end
        return g_oRegistry.CreateKey(sPath)
    end,
    allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["reg_delete_key"] = {
    func = function(nPid, sPath)
        if not g_oRegistry then return false end
        -- protect root hives
        if sPath == "@VT" or sPath == "@VT\\DEV" or sPath == "@VT\\DRV" or sPath == "@VT\\SYS" then
            return false, "Cannot delete root hive"
        end
        return g_oRegistry.DeleteKey(sPath)
    end,
    allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["reg_key_exists"] = {
    func = function(nPid, sPath)
        if not g_oRegistry then return false end
        return g_oRegistry.KeyExists(sPath)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["reg_set_value"] = {
    func = function(nPid, sPath, sName, vValue, sType)
        if not g_oRegistry then return false end
        return g_oRegistry.SetValue(sPath, sName, vValue, sType)
    end,
    allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["reg_get_value"] = {
    func = function(nPid, sPath, sName)
        if not g_oRegistry then return nil end
        return g_oRegistry.GetValue(sPath, sName)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["reg_delete_value"] = {
    func = function(nPid, sPath, sName)
        if not g_oRegistry then return false end
        return g_oRegistry.DeleteValue(sPath, sName)
    end,
    allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["reg_enum_keys"] = {
    func = function(nPid, sPath)
        if not g_oRegistry then return {} end
        return g_oRegistry.EnumKeys(sPath)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["reg_enum_values"] = {
    func = function(nPid, sPath)
        if not g_oRegistry then return {} end
        return g_oRegistry.EnumValues(sPath)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["reg_query_info"] = {
    func = function(nPid, sPath)
        if not g_oRegistry then return nil end
        return g_oRegistry.QueryInfo(sPath)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["reg_dump_tree"] = {
    func = function(nPid, sPath, nMaxDepth)
        if not g_oRegistry then return {} end
        return g_oRegistry.DumpTree(sPath, nMaxDepth)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["reg_alloc_device_id"] = {
    func = function(nPid, sClass)
        if not g_oRegistry then return nil end
        return g_oRegistry.AllocateDeviceId(sClass)
    end,
    allowed_rings = {0, 1, 2}
}


-- ==========================================
-- sMLTR SYSCALLS
-- ==========================================

-- Get own synapse token
kernel.tSyscallTable["synapse_get_token"] = {
  func = function(nPid)
    local tProc = kernel.tProcessTable[nPid]
    return tProc and tProc.synapseToken or nil
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Validate a target process's synapse token
kernel.tSyscallTable["synapse_validate"] = {
  func = function(nPid, nTargetPid, sToken)
    local tTarget = kernel.tProcessTable[nTargetPid]
    if tTarget and tTarget.synapseToken == sToken then return true end
    return false
  end,
  allowed_rings = {0, 1, 2}
}

-- Rotate a process's synapse token (security measure)
-- After rotation, all old handles bound to the old token become invalid.
kernel.tSyscallTable["synapse_rotate"] = {
  func = function(nPid, nTargetPid)
    local nTarget = nTargetPid or nPid
    local tTarget = kernel.tProcessTable[nTarget]
    if not tTarget then return nil, "No such process" end
    local sOldToken = tTarget.synapseToken
    tTarget.synapseToken = fGenerateSynapseToken()
    kprint("dev", "sMLTR: Rotated token for PID " .. nTarget .. " (old: " .. sOldToken:sub(1,12) .. "...)")
    return tTarget.synapseToken
  end,
  allowed_rings = {0, 1}
}

-- ==========================================
-- IPC SYSCALLS
-- ==========================================

-- IRQL
kernel.tSyscallTable["ke_raise_irql"] = {
    func = function(nPid, nLevel)
        if not g_oIpc then return nil end
        return g_oIpc.KeRaiseIrql(nPid, nLevel)
    end, allowed_rings = {0, 1, 2}
}
kernel.tSyscallTable["ke_lower_irql"] = {
    func = function(nPid, nLevel)
        if not g_oIpc then return end
        g_oIpc.KeLowerIrql(nPid, nLevel)
    end, allowed_rings = {0, 1, 2}
}
kernel.tSyscallTable["ke_get_irql"] = {
    func = function(nPid)
        if not g_oIpc then return 0 end
        return g_oIpc.KeGetCurrentIrql(nPid)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Events
kernel.tSyscallTable["ke_create_event"] = {
    func = function(nPid, bManual, bInit)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreateEvent(nPid, bManual, bInit)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_set_event"] = {
    func = function(nPid, sH)
        if not g_oIpc then return nil end
        return g_oIpc.KeSetEvent(nPid, sH)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_reset_event"] = {
    func = function(nPid, sH)
        if not g_oIpc then return nil end
        return g_oIpc.KeResetEvent(nPid, sH)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_pulse_event"] = {
    func = function(nPid, sH)
        if not g_oIpc then return nil end
        return g_oIpc.KePulseEvent(nPid, sH)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Mutexes
kernel.tSyscallTable["ke_create_mutex"] = {
    func = function(nPid, bOwned)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreateMutex(nPid, bOwned)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_release_mutex"] = {
    func = function(nPid, sH)
        if not g_oIpc then return nil end
        return g_oIpc.KeReleaseMutex(nPid, sH)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Semaphores
kernel.tSyscallTable["ke_create_semaphore"] = {
    func = function(nPid, nInit, nMax)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreateSemaphore(nPid, nInit, nMax)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_release_semaphore"] = {
    func = function(nPid, sH, nCount)
        if not g_oIpc then return nil end
        return g_oIpc.KeReleaseSemaphore(nPid, sH, nCount)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Timers
kernel.tSyscallTable["ke_create_timer"] = {
    func = function(nPid)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreateTimer(nPid)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_set_timer"] = {
    func = function(nPid, sH, nDelay, nPeriod)
        if not g_oIpc then return nil end
        return g_oIpc.KeSetTimer(nPid, sH, nDelay, nPeriod)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_cancel_timer"] = {
    func = function(nPid, sH)
        if not g_oIpc then return nil end
        return g_oIpc.KeCancelTimer(nPid, sH)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Pipes
kernel.tSyscallTable["ke_create_pipe"] = {
    func = function(nPid, nBuf)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreatePipe(nPid, nBuf)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_create_named_pipe"] = {
    func = function(nPid, sName, nBuf)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreateNamedPipe(nPid, sName, nBuf)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_connect_named_pipe"] = {
    func = function(nPid, sName)
        if not g_oIpc then return nil end
        return g_oIpc.KeConnectNamedPipe(nPid, sName)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_pipe_write"] = {
    func = function(nPid, sH, sData)
        if not g_oIpc then return nil end
        local pH = g_oObManager.ObReferenceObjectByHandle(
            nPid, sH, 0x0002, kernel.tProcessTable[nPid].synapseToken)
        if not pH or not pH.pBody then return nil, "Invalid pipe handle" end
        return g_oIpc.PipeWrite(nPid, pH.pBody, sData)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_pipe_read"] = {
    func = function(nPid, sH, nCount)
        if not g_oIpc then return nil end
        local pH = g_oObManager.ObReferenceObjectByHandle(
            nPid, sH, 0x0001, kernel.tProcessTable[nPid].synapseToken)
        if not pH or not pH.pBody then return nil, "Invalid pipe handle" end
        return g_oIpc.PipeRead(nPid, pH.pBody, nCount)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_pipe_close"] = {
    func = function(nPid, sH, bIsWrite)
        if not g_oIpc then return nil end
        return g_oIpc.PipeClose(nPid, sH, bIsWrite)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Wait
kernel.tSyscallTable["ke_wait_single"] = {
    func = function(nPid, sH, nTimeout)
        if not g_oIpc then return -1 end
        return g_oIpc.KeWaitSingle(nPid, sH, nTimeout)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_wait_multiple"] = {
    func = function(nPid, tHandles, bAll, nTimeout)
        if not g_oIpc then return -1 end
        return g_oIpc.KeWaitMultiple(nPid, tHandles, bAll, nTimeout)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Shared Memory
kernel.tSyscallTable["ke_create_section"] = {
    func = function(nPid, sName, nSize)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreateSection(nPid, sName, nSize)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_open_section"] = {
    func = function(nPid, sName)
        if not g_oIpc then return nil end
        return g_oIpc.KeOpenSection(nPid, sName)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_map_section"] = {
    func = function(nPid, sH)
        if not g_oIpc then return nil end
        return g_oIpc.KeMapSection(nPid, sH)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Message Queues
kernel.tSyscallTable["ke_create_mqueue"] = {
    func = function(nPid, sName, nMax, nSize)
        if not g_oIpc then return nil end
        return g_oIpc.KeCreateMqueue(nPid, sName, nMax, nSize)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_open_mqueue"] = {
    func = function(nPid, sName)
        if not g_oIpc then return nil end
        return g_oIpc.KeOpenMqueue(nPid, sName)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_mq_send"] = {
    func = function(nPid, sH, sMsg, nPri)
        if not g_oIpc then return nil end
        return g_oIpc.KeMqSend(nPid, sH, sMsg, nPri)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_mq_receive"] = {
    func = function(nPid, sH, nTimeout)
        if not g_oIpc then return nil end
        return g_oIpc.KeMqReceive(nPid, sH, nTimeout)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Signals
kernel.tSyscallTable["ke_signal_send"] = {
    func = function(nPid, nTarget, nSig)
        if not g_oIpc then return nil end
        return g_oIpc.SignalSend(nTarget, nSig)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_signal_handler"] = {
    func = function(nPid, nSig, fHandler)
        if not g_oIpc then return nil end
        return g_oIpc.SignalSetHandler(nPid, nSig, fHandler)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_signal_mask"] = {
    func = function(nPid, tMask)
        if not g_oIpc then return nil end
        return g_oIpc.SignalSetMask(nPid, tMask)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_signal_group"] = {
    func = function(nPid, nPgid, nSig)
        if not g_oIpc then return nil end
        return g_oIpc.SignalSendGroup(nPgid, nSig)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_setpgid"] = {
    func = function(nPid, nTarget, nPgid)
        if not g_oIpc then return nil end
        return g_oIpc.SetProcessGroup(nTarget or nPid, nPgid)
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_getpgid"] = {
    func = function(nPid)
        local p = kernel.tProcessTable[nPid]
        return p and (p.nPgid or nPid) or nil
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["ke_ipc_stats"] = {
    func = function(nPid)
        if not g_oIpc then return nil end
        return g_oIpc.GetStats()
    end, allowed_rings = {0, 1, 2, 2.5, 3}
}

-- ==========================================
-- SCHEDULER DIAGNOSTICS
-- ==========================================

kernel.tSyscallTable["sched_get_stats"] = {
    func = function(nPid)
        local tResult = {
            nTotalResumes     = g_tSchedStats.nTotalResumes,
            nPreemptions      = g_tSchedStats.nPreemptions,
            nWatchdogWarnings = g_tSchedStats.nWatchdogWarnings,
            nWatchdogKills    = g_tSchedStats.nWatchdogKills,
            nMaxSliceMs       = g_tSchedStats.nMaxSliceMs,
        }
        if g_oPreempt then
            local tP = g_oPreempt.getStats()
            tResult.nInstrumentedFiles    = tP.nTotalInstrumented
            tResult.nInjectedCheckpoints  = tP.nTotalInjections
            tResult.nQuantumMs            = tP.nQuantumMs
            tResult.nCheckInterval        = tP.nCheckInterval
        end
        return tResult
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["process_cpu_stats"] = {
    func = function(nPid, nTargetPid)
        local tTarget = kernel.tProcessTable[nTargetPid or nPid]
        if not tTarget then return nil end
        return {
            nCpuTime         = tTarget.nCpuTime         or 0,
            nPreemptCount    = tTarget.nPreemptCount    or 0,
            nLastSlice       = tTarget.nLastSlice       or 0,
            nMaxSlice        = tTarget.nMaxSlice        or 0,
            nWatchdogStrikes = tTarget.nWatchdogStrikes or 0,
        }
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Raw Component (Privileged)
kernel.tSyscallTable["raw_component_list"] = {
  func = function(nPid, sFilter)
    local bIsOk, tList = pcall(function()
        local tTempList = {}
        for sAddr, sCtype in raw_component.list(sFilter) do
          tTempList[sAddr] = sCtype
        end
        return tTempList
    end)
    if bIsOk then return true, tList else return false, tList end
  end,
  allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["raw_component_invoke"] = {
  func = function(nPid, sAddress, sMethod, ...)
    local oProxy = raw_component.proxy(sAddress)
    if not oProxy then return nil, "Invalid component" end
    return pcall(oProxy[sMethod], ...)
  end,
  allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["raw_component_proxy"] = {
  func = function(nPid, sAddress)
    local bIsOk, oProxy = pcall(raw_component.proxy, sAddress)
    if bIsOk then return oProxy else return nil, "Invalid component address" end
  end,
  allowed_rings = {0, 1, 2}
}

-- IPC
kernel.syscalls.signal_send = function(nPid, nTargetPid, ...)
  local tTarget = kernel.tProcessTable[nTargetPid]
  if not tTarget then return nil, "Invalid PID" end
  
  local tSignal = {nPid, ...}
  
  if tTarget.status == "sleeping" and (tTarget.wait_reason == "signal" or tTarget.wait_reason == "syscall") then
    tTarget.status = "ready"
    if tTarget.wait_reason == "syscall" then
        tTarget.resume_args = {tSignal[3], table.unpack(tSignal, 4)}
    else
        tTarget.resume_args = tSignal
    end
  else
    if not tTarget.signal_queue then tTarget.signal_queue = {} end
    table.insert(tTarget.signal_queue, tSignal)
  end
  
  return true
end

kernel.tSyscallTable["signal_send"] = {
  func = kernel.syscalls.signal_send,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["signal_pull"] = {
  func = function(nPid, nTimeout)
    local tProcess = kernel.tProcessTable[nPid]
    if tProcess.signal_queue and #tProcess.signal_queue > 0 then
      return true, table.unpack(table.remove(tProcess.signal_queue, 1))
    end
    tProcess.status = "sleeping"
    tProcess.wait_reason = "signal"
    return coroutine.yield()
  end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}

-- VFS (placeholders, overridden by PM)
kernel.syscalls.vfs_read_file = function(nPid, sPath)
  return primitive_load(sPath)
end

kernel.tSyscallTable["vfs_read_file"] = {
    func = kernel.syscalls.vfs_read_file,
    allowed_rings = {0, 1, 2}
}

kernel.tSyscallTable["vfs_open"]  = {
    func = function(nPid, sPath, sMode) return pcall(g_oPrimitiveFs.open, sPath, sMode) end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["vfs_read"]  = {
    func = function(nPid, hHandle, nCount) return pcall(g_oPrimitiveFs.read, hHandle, nCount or math.huge) end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["vfs_write"] = {
    func = function(nPid, hHandle, sData) return pcall(g_oPrimitiveFs.write, hHandle, sData) end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["vfs_close"] = {
    func = function(nPid, hHandle) return pcall(g_oPrimitiveFs.close, hHandle) end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["vfs_chmod"] = {
  func = function() return nil, "Not implemented in kernel" end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["vfs_device_control"] = {
  func = function() return nil, "Not implemented in kernel" end,
  allowed_rings = {0, 1, 2, 2.5, 3}
}
kernel.tSyscallTable["vfs_list"]  = {
    func = function(nPid, sPath)
        local bOk, tListOrErr = pcall(g_oPrimitiveFs.list, sPath)
        if bOk then return true, tListOrErr else return false, tListOrErr end
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["vfs_delete"] = {
    func = function(nPid, sPath)
        return pcall(g_oPrimitiveFs.remove, sPath)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

kernel.tSyscallTable["vfs_mkdir"] = {
    func = function(nPid, sPath)
        return pcall(g_oPrimitiveFs.makeDirectory, sPath)
    end,
    allowed_rings = {0, 1, 2, 2.5, 3}
}

-- Computer
kernel.tSyscallTable["computer_shutdown"] = {
  func = function()
    if g_oAxfsVol then g_oAxfsVol:flush() end
    raw_computer.shutdown()
  end,
  allowed_rings = {0, 1, 2, 2.5}
}
kernel.tSyscallTable["computer_reboot"] = {
  func = function()
    if g_oAxfsVol then g_oAxfsVol:flush() end
    raw_computer.shutdown(true)
  end,
  allowed_rings = {0, 1, 2, 2.5}
}

-------------------------------------------------
-- KERNEL INITIALIZATION
-------------------------------------------------
kprint("info", "Kernel entering initialization sequence (Ring 0).")
kprint("dev", "Initializing syscall dispatcher table...")

-- 0. Load Object Manager
g_oObManager = __load_ob_manager()
if g_oObManager then
    g_oObManager.ObInitSystem()
    kprint("ok", "Object Manager initialised.  Namespace: \\, \\Device, \\DosDevices")
else
    kprint("warn", "Object Manager not available. Running without handle security.")
end
kprint("ok", "sMLTR (Synapse Message Layer Token Randomisation) active.")

-- Load Virtual Registry
g_oRegistry = __load_registry()
if g_oRegistry then
    g_oRegistry.InitSystem()
    kprint("ok", "Virtual Registry (@VT) initialised.")
else
    kprint("warn", "Virtual Registry not available.")
end

-- Load Preemptive Scheduler module
g_oPreempt = __load_preempt()
if g_oPreempt then
    kprint("ok", string.format(
        "Preemptive scheduler active  (quantum=%dms, interval=%d, no debug hooks)",
        g_oPreempt.DEFAULT_QUANTUM * 1000,
        g_oPreempt.CHECK_INTERVAL))
else
    kprint("warn", "Preemptive scheduling unavailable — cooperative only.")
end

-- Load Kernel IPC subsystem
g_oIpc = __load_ke_ipc()
if g_oIpc and g_oObManager then
    g_oIpc.Initialize({
        tProcessTable = kernel.tProcessTable,
        fUptime       = raw_computer.uptime,
        fLog          = function(s) kprint("info", s) end,
        oObManager    = g_oObManager,
        fYield        = coroutine.yield,
    })
    -- Register new object types
    g_oObManager.ObCreateObjectType("KeMutex",          {})
    g_oObManager.ObCreateObjectType("KeSemaphore",      {})
    g_oObManager.ObCreateObjectType("KeTimer",          {})
    g_oObManager.ObCreateObjectType("IoPipeObject",     {})
    g_oObManager.ObCreateObjectType("IpcMessageQueue",  {})
    kprint("ok", "Kernel IPC subsystem online (Events, Mutexes, Semaphores,")
    kprint("ok", "  Pipes, Sections, MQueues, Signals, WaitMultiple, DPC, IRQL)")
else
    kprint("warn", "Kernel IPC subsystem not available.")
end

-- 1. Mount Root FS
kprint("info", "Reading fstab from /etc/fstab.lua...")
local tFstab = primitive_load_lua("/etc/fstab.lua")
if not tFstab then
    kprint("fail", "Failed to load /etc/fstab.lua")
  kernel.panic("fstab is missing or corrupt.")
end

local tRootEntry = tFstab[1]
if tRootEntry.type ~= "rootfs" then
  kprint("fail", "fstab[1] is not of type 'rootfs'.")
  kernel.panic("Invalid fstab configuration.")
end

if g_bAxfsRoot then
  kernel.tVfs.sRootUuid = g_oPrimitiveFs.address
  kernel.tVfs.oRootFs = g_oPrimitiveFs
  kprint("ok", "Mounted AXFS root filesystem (" .. g_oPrimitiveFs._label .. ")")
else
  kernel.tVfs.sRootUuid = tRootEntry.uuid
  kernel.tVfs.oRootFs = raw_component.proxy(tRootEntry.uuid)
  kprint("ok", "Mounted root filesystem on " .. kernel.tVfs.sRootUuid:sub(1,13) .. "...")
end

kernel.tVfs.tMounts["/"] = {
  type = "rootfs",
  proxy = kernel.tVfs.oRootFs,
  options = tRootEntry.options,
}
kprint("ok", "Mounted root filesystem on", kernel.tVfs.sRootUuid:sub(1,13).."...")

-- 2. Create PID 0 (Kernel Process)
local nKernelPid = kernel.nNextPid
kernel.nNextPid = kernel.nNextPid + 1
local coKernel = coroutine.running()
local tKernelEnv = kernel.create_sandbox(nKernelPid, 0)
kernel.tProcessTable[nKernelPid] = {
  co = coKernel, status = "running", ring = 0,
  parent = 0, env = tKernelEnv, fds = {},
  synapseToken = fGenerateSynapseToken(),
  threads = {},
}
kernel.tPidMap[coKernel] = nKernelPid
kernel.tRings[nKernelPid] = 0
g_nCurrentPid = nKernelPid
_G = tKernelEnv

if g_oObManager then g_oObManager.ObInitializeProcess(nKernelPid) end

kprint("ok", "Kernel process registered as PID", nKernelPid)

-- 3. Load Ring 1 Pipeline Manager
kprint("info", "Starting Ring 1 services...")
local tPmEnv = {
   SAFE_MODE = (tBootArgs.safemode == "Enabled"),
   INIT_PATH = tBootArgs.init or "/bin/init.lua"
}

local nPipelinePid, sErr = kernel.create_process("/lib/pipeline_manager.lua", 1, nKernelPid, tPmEnv)

if not nPipelinePid then
  kprint("fail", "Failed to start Ring 1 Pipeline Manager:", sErr)
  kernel.panic("Critical service failure: pipeline_manager")
end
kernel.nPipelinePid = nPipelinePid
kprint("ok", "Ring 1 Pipeline Manager started as PID", nPipelinePid)

-------------------------------------------------
-- MAIN KERNEL EVENT LOOP
-------------------------------------------------
kprint("info", "Handing off control to scheduler...")
kprint("ok", "Entering main event loop. Kernel is now running.")
kprint("none", "")

table.insert(kernel.tProcessTable[nPipelinePid].run_queue, "start")

-- =================================================================
-- MAIN KERNEL EVENT LOOP  —  Preemptive Round-Robin Scheduler
--
-- Key changes from cooperative-only:
--
--  1) After each coroutine.resume(), if the process status is still
--     "running" it was preempted by __pc() rather than yielding via
--     a syscall.  We set it back to "ready" so it runs again next
--     tick.
--
--  2) Between every process resume we call computer.pullSignal(0)
--     to RESET the OpenComputers "too long without yielding" timer.
--     Without this, the cumulative runtime of all processes in one
--     tick could exceed OC's ~5-second hard limit and crash the
--     machine.
--
--  3) We track wall-clock time per resume and maintain per-process
--     CPU accounting.  A watchdog warns (and eventually kills)
--     processes whose single resumes exceed WATCHDOG_WARN_THRESHOLD.
--
--  4) Hardware events captured during intermediate pullSignal(0)
--     calls are forwarded to the Pipeline Manager immediately,
--     improving input responsiveness.
-- =================================================================

while true do
  local nWorkDone = 0

  for nPid, tProcess in pairs(kernel.tProcessTable) do
    if tProcess.status == "ready" then
      nWorkDone = nWorkDone + 1
      g_nCurrentPid = nPid
      tProcess.status = "running"

      local nResumeStart = raw_computer.uptime()

      local tResumeParams = tProcess.resume_args
      tProcess.resume_args = nil

      local bIsOk, sErrOrSignalName
      if tResumeParams then
        bIsOk, sErrOrSignalName = coroutine.resume(
            tProcess.co, true, table.unpack(tResumeParams))
      else
        bIsOk, sErrOrSignalName = coroutine.resume(tProcess.co)
      end

      local nSliceTime = raw_computer.uptime() - nResumeStart

      g_nCurrentPid = nKernelPid

      -- ---------- per-process CPU accounting ----------
      tProcess.nCpuTime  = (tProcess.nCpuTime or 0) + nSliceTime
      tProcess.nLastSlice = nSliceTime
      if nSliceTime > (tProcess.nMaxSlice or 0) then
          tProcess.nMaxSlice = nSliceTime
      end

      -- ---------- global scheduler accounting ----------
      g_tSchedStats.nTotalResumes = g_tSchedStats.nTotalResumes + 1
      local nSliceMs = nSliceTime * 1000
      if nSliceMs > g_tSchedStats.nMaxSliceMs then
          g_tSchedStats.nMaxSliceMs = nSliceMs
      end

      -- ---------- crash handling ----------
      if not bIsOk then
        tProcess.status = "dead"
        kernel.panic(tostring(sErrOrSignalName), tProcess.co)
      end

      -- ---------- PREEMPTION DETECTION ----------
      if tProcess.status == "running" then
          tProcess.status = "ready"
          tProcess.nPreemptCount = (tProcess.nPreemptCount or 0) + 1
          g_tSchedStats.nPreemptions = g_tSchedStats.nPreemptions + 1
      end

      -- ---------- natural exit ----------
      if coroutine.status(tProcess.co) == "dead" then
        if tProcess.status ~= "dead" then
          kprint("info", "Process " .. nPid .. " exited normally.")
          tProcess.status = "dead"
        end
      end

      -- ---------- watchdog ----------
      if nSliceTime > WATCHDOG_WARN_THRESHOLD and tProcess.status ~= "dead" then
          tProcess.nWatchdogStrikes = (tProcess.nWatchdogStrikes or 0) + 1
          g_tSchedStats.nWatchdogWarnings = g_tSchedStats.nWatchdogWarnings + 1
          kprint("warn", string.format(
              "WATCHDOG: PID %d ran %.2fs without yielding (strike %d/%d)",
              nPid, nSliceTime,
              tProcess.nWatchdogStrikes, WATCHDOG_KILL_STRIKES))
          if tProcess.nWatchdogStrikes >= WATCHDOG_KILL_STRIKES then
              kprint("fail", "WATCHDOG: Killing PID " .. nPid ..
                             " — exceeded " .. WATCHDOG_KILL_STRIKES .. " strikes")
              tProcess.status = "dead"
              g_tSchedStats.nWatchdogKills = g_tSchedStats.nWatchdogKills + 1
          end
      end

      -- ---------- wake waiters / clean up dead ----------
      if tProcess.status == "dead" then
        if g_oIpc then
            g_oIpc.NotifyChildDeath(nPid)
        end
        if g_oObManager then
          g_oObManager.ObDestroyProcess(nPid)
        end

        for _, nWaiterPid in ipairs(tProcess.wait_queue or {}) do
          local tWaiter = kernel.tProcessTable[nWaiterPid]
          if tWaiter and tWaiter.status == "sleeping"
             and tWaiter.wait_reason == "wait_pid" then
            tWaiter.status = "ready"
            tWaiter.resume_args = {true}
          end
        end

        for _, nTid in ipairs(tProcess.threads or {}) do
          if kernel.tProcessTable[nTid]
             and kernel.tProcessTable[nTid].status ~= "dead" then
            kernel.tProcessTable[nTid].status = "dead"
            if g_oObManager then g_oObManager.ObDestroyProcess(nTid) end
          end
        end
      end

      -- ======================================================
      -- CRITICAL:  Reset the OC "too long without yielding"
      -- timer.  This MUST stay inside the per-process loop so
      -- that each individual resume gets a fresh 5-second window.
      -- Also picks up hardware events for responsiveness.
      -- ======================================================
      local sIntEvt, ip1, ip2, ip3, ip4, ip5 = computer.pullSignal(0)
      if sIntEvt then
          pcall(kernel.syscalls.signal_send, nKernelPid,
                kernel.nPipelinePid, "os_event",
                sIntEvt, ip1, ip2, ip3, ip4, ip5)
      end

    end  -- if status == "ready"
  end  -- for each process

  -- ====== IPC TICK: process DPCs and timers ONCE per iteration ======
  -- This runs AFTER all ready processes have had their turn,
  -- so DPCs queued during this tick's resumes execute here,
  -- and timers are checked exactly once per scheduler pass.
  if g_oIpc then
      g_oIpc.Tick()
  end

  -- Pull external events (block briefly if idle)
  local nTimeout = (nWorkDone > 0) and 0 or 0.05
  local sEventName, p1, p2, p3, p4, p5 = computer.pullSignal(nTimeout)

  if sEventName then
    pcall(kernel.syscalls.signal_send, nKernelPid,
          kernel.nPipelinePid, "os_event",
          sEventName, p1, p2, p3, p4, p5)
  end
end
```


